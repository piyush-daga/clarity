/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	var __webpack_modules__ = ({

/***/ "(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-opfs-async-proxy.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-opfs-async-proxy.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n  2022-09-16\n\n  The author disclaims copyright to this source code.  In place of a\n  legal notice, here is a blessing:\n\n  *   May you do good and not evil.\n  *   May you find forgiveness for yourself and forgive others.\n  *   May you share freely, never taking more than you give.\n\n  ***********************************************************************\n\n  A Worker which manages asynchronous OPFS handles on behalf of a\n  synchronous API which controls it via a combination of Worker\n  messages, SharedArrayBuffer, and Atomics. It is the asynchronous\n  counterpart of the API defined in sqlite3-vfs-opfs.js.\n\n  Highly indebted to:\n\n  https://github.com/rhashimoto/wa-sqlite/blob/master/src/examples/OriginPrivateFileSystemVFS.js\n\n  for demonstrating how to use the OPFS APIs.\n\n  This file is to be loaded as a Worker. It does not have any direct\n  access to the sqlite3 JS/WASM bits, so any bits which it needs (most\n  notably SQLITE_xxx integer codes) have to be imported into it via an\n  initialization process.\n\n  This file represents an implementation detail of a larger piece of\n  code, and not a public interface. Its details may change at any time\n  and are not intended to be used by any client-level code.\n\n  2022-11-27: Chrome v108 changes some async methods to synchronous, as\n  documented at:\n\n  https://developer.chrome.com/blog/sync-methods-for-accesshandles/\n\n  Firefox v111 and Safari 16.4, both released in March 2023, also\n  include this.\n\n  We cannot change to the sync forms at this point without breaking\n  clients who use Chrome v104-ish or higher. truncate(), getSize(),\n  flush(), and close() are now (as of v108) synchronous. Calling them\n  with an \"await\", as we have to for the async forms, is still legal\n  with the sync forms but is superfluous. Calling the async forms with\n  theFunc().then(...) is not compatible with the change to\n  synchronous, but we do do not use those APIs that way. i.e. we don't\n  _need_ to change anything for this, but at some point (after Chrome\n  versions (approximately) 104-107 are extinct) should change our\n  usage of those methods to remove the \"await\".\n*/\n\nconst wPost = (type, ...args) => postMessage({ type, payload: args });\nconst installAsyncProxy = function () {\n  const toss = function (...args) {\n    throw new Error(args.join(' '));\n  };\n  if (globalThis.window === globalThis) {\n    toss(\n      'This code cannot run from the main thread.',\n      'Load it as a Worker from a separate Worker.',\n    );\n  } else if (!navigator?.storage?.getDirectory) {\n    toss('This API requires navigator.storage.getDirectory.');\n  }\n\n  const state = Object.create(null);\n\n  state.verbose = 1;\n\n  const loggers = {\n    0: console.error.bind(console),\n    1: console.warn.bind(console),\n    2: console.log.bind(console),\n  };\n  const logImpl = (level, ...args) => {\n    if (state.verbose > level) loggers[level]('OPFS asyncer:', ...args);\n  };\n  const log = (...args) => logImpl(2, ...args);\n  const warn = (...args) => logImpl(1, ...args);\n  const error = (...args) => logImpl(0, ...args);\n\n  const __openFiles = Object.create(null);\n\n  const __implicitLocks = new Set();\n\n  const getResolvedPath = function (filename, splitIt) {\n    const p = new URL(filename, 'file://irrelevant').pathname;\n    return splitIt ? p.split('/').filter((v) => !!v) : p;\n  };\n\n  const getDirForFilename = async function f(absFilename, createDirs = false) {\n    const path = getResolvedPath(absFilename, true);\n    const filename = path.pop();\n    let dh = state.rootDir;\n    for (const dirName of path) {\n      if (dirName) {\n        dh = await dh.getDirectoryHandle(dirName, { create: !!createDirs });\n      }\n    }\n    return [dh, filename];\n  };\n\n  const closeSyncHandle = async (fh) => {\n    if (fh.syncHandle) {\n      log('Closing sync handle for', fh.filenameAbs);\n      const h = fh.syncHandle;\n      delete fh.syncHandle;\n      delete fh.xLock;\n      __implicitLocks.delete(fh.fid);\n      return h.close();\n    }\n  };\n\n  const closeSyncHandleNoThrow = async (fh) => {\n    try {\n      await closeSyncHandle(fh);\n    } catch (e) {\n      warn('closeSyncHandleNoThrow() ignoring:', e, fh);\n    }\n  };\n\n  const releaseImplicitLocks = async () => {\n    if (__implicitLocks.size) {\n      for (const fid of __implicitLocks) {\n        const fh = __openFiles[fid];\n        await closeSyncHandleNoThrow(fh);\n        log('Auto-unlocked', fid, fh.filenameAbs);\n      }\n    }\n  };\n\n  const releaseImplicitLock = async (fh) => {\n    if (fh.releaseImplicitLocks && __implicitLocks.has(fh.fid)) {\n      return closeSyncHandleNoThrow(fh);\n    }\n  };\n\n  class GetSyncHandleError extends Error {\n    constructor(errorObject, ...msg) {\n      super(\n        [...msg, ': ' + errorObject.name + ':', errorObject.message].join(' '),\n        {\n          cause: errorObject,\n        },\n      );\n      this.name = 'GetSyncHandleError';\n    }\n  }\n\n  GetSyncHandleError.convertRc = (e, rc) => {\n    if (e instanceof GetSyncHandleError) {\n      if (\n        e.cause.name === 'NoModificationAllowedError' ||\n        (e.cause.name === 'DOMException' &&\n          0 === e.cause.message.indexOf('Access Handles cannot'))\n      ) {\n        return state.sq3Codes.SQLITE_BUSY;\n      } else if ('NotFoundError' === e.cause.name) {\n        return state.sq3Codes.SQLITE_CANTOPEN;\n      }\n    } else if ('NotFoundError' === e?.name) {\n      return state.sq3Codes.SQLITE_CANTOPEN;\n    }\n    return rc;\n  };\n\n  const getSyncHandle = async (fh, opName) => {\n    if (!fh.syncHandle) {\n      const t = performance.now();\n      log('Acquiring sync handle for', fh.filenameAbs);\n      const maxTries = 6,\n        msBase = state.asyncIdleWaitTime * 2;\n      let i = 1,\n        ms = msBase;\n      for (; true; ms = msBase * ++i) {\n        try {\n          fh.syncHandle = await fh.fileHandle.createSyncAccessHandle();\n          break;\n        } catch (e) {\n          if (i === maxTries) {\n            throw new GetSyncHandleError(\n              e,\n              'Error getting sync handle for',\n              opName + '().',\n              maxTries,\n              'attempts failed.',\n              fh.filenameAbs,\n            );\n          }\n          warn(\n            'Error getting sync handle for',\n            opName + '(). Waiting',\n            ms,\n            'ms and trying again.',\n            fh.filenameAbs,\n            e,\n          );\n          Atomics.wait(state.sabOPView, state.opIds.retry, 0, ms);\n        }\n      }\n      log(\n        'Got',\n        opName + '() sync handle for',\n        fh.filenameAbs,\n        'in',\n        performance.now() - t,\n        'ms',\n      );\n      if (!fh.xLock) {\n        __implicitLocks.add(fh.fid);\n        log(\n          'Acquired implicit lock for',\n          opName + '()',\n          fh.fid,\n          fh.filenameAbs,\n        );\n      }\n    }\n    return fh.syncHandle;\n  };\n\n  const storeAndNotify = (opName, value) => {\n    log(opName + '() => notify(', value, ')');\n    Atomics.store(state.sabOPView, state.opIds.rc, value);\n    Atomics.notify(state.sabOPView, state.opIds.rc);\n  };\n\n  const affirmNotRO = function (opName, fh) {\n    if (fh.readOnly) toss(opName + '(): File is read-only: ' + fh.filenameAbs);\n  };\n\n  let flagAsyncShutdown = false;\n\n  const vfsAsyncImpls = {\n    'opfs-async-shutdown': async () => {\n      flagAsyncShutdown = true;\n      storeAndNotify('opfs-async-shutdown', 0);\n    },\n    mkdir: async (dirname) => {\n      let rc = 0;\n      try {\n        await getDirForFilename(dirname + '/filepart', true);\n      } catch (e) {\n        state.s11n.storeException(2, e);\n        rc = state.sq3Codes.SQLITE_IOERR;\n      }\n      storeAndNotify('mkdir', rc);\n    },\n    xAccess: async (filename) => {\n      let rc = 0;\n      try {\n        const [dh, fn] = await getDirForFilename(filename);\n        await dh.getFileHandle(fn);\n      } catch (e) {\n        state.s11n.storeException(2, e);\n        rc = state.sq3Codes.SQLITE_IOERR;\n      }\n      storeAndNotify('xAccess', rc);\n    },\n    xClose: async function (fid) {\n      const opName = 'xClose';\n      __implicitLocks.delete(fid);\n      const fh = __openFiles[fid];\n      let rc = 0;\n      if (fh) {\n        delete __openFiles[fid];\n        await closeSyncHandle(fh);\n        if (fh.deleteOnClose) {\n          try {\n            await fh.dirHandle.removeEntry(fh.filenamePart);\n          } catch (e) {\n            warn('Ignoring dirHandle.removeEntry() failure of', fh, e);\n          }\n        }\n      } else {\n        state.s11n.serialize();\n        rc = state.sq3Codes.SQLITE_NOTFOUND;\n      }\n      storeAndNotify(opName, rc);\n    },\n    xDelete: async function (...args) {\n      const rc = await vfsAsyncImpls.xDeleteNoWait(...args);\n      storeAndNotify('xDelete', rc);\n    },\n    xDeleteNoWait: async function (filename, syncDir = 0, recursive = false) {\n      let rc = 0;\n      try {\n        while (filename) {\n          const [hDir, filenamePart] = await getDirForFilename(filename, false);\n          if (!filenamePart) break;\n          await hDir.removeEntry(filenamePart, { recursive });\n          if (0x1234 !== syncDir) break;\n          recursive = false;\n          filename = getResolvedPath(filename, true);\n          filename.pop();\n          filename = filename.join('/');\n        }\n      } catch (e) {\n        state.s11n.storeException(2, e);\n        rc = state.sq3Codes.SQLITE_IOERR_DELETE;\n      }\n      return rc;\n    },\n    xFileSize: async function (fid) {\n      const fh = __openFiles[fid];\n      let rc = 0;\n      try {\n        const sz = await (await getSyncHandle(fh, 'xFileSize')).getSize();\n        state.s11n.serialize(Number(sz));\n      } catch (e) {\n        state.s11n.storeException(1, e);\n        rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR);\n      }\n      await releaseImplicitLock(fh);\n      storeAndNotify('xFileSize', rc);\n    },\n    xLock: async function (fid, lockType) {\n      const fh = __openFiles[fid];\n      let rc = 0;\n      const oldLockType = fh.xLock;\n      fh.xLock = lockType;\n      if (!fh.syncHandle) {\n        try {\n          await getSyncHandle(fh, 'xLock');\n          __implicitLocks.delete(fid);\n        } catch (e) {\n          state.s11n.storeException(1, e);\n          rc = GetSyncHandleError.convertRc(\n            e,\n            state.sq3Codes.SQLITE_IOERR_LOCK,\n          );\n          fh.xLock = oldLockType;\n        }\n      }\n      storeAndNotify('xLock', rc);\n    },\n    xOpen: async function (fid, filename, flags, opfsFlags) {\n      const opName = 'xOpen';\n      const create = state.sq3Codes.SQLITE_OPEN_CREATE & flags;\n      try {\n        let hDir, filenamePart;\n        try {\n          [hDir, filenamePart] = await getDirForFilename(filename, !!create);\n        } catch (e) {\n          state.s11n.storeException(1, e);\n          storeAndNotify(opName, state.sq3Codes.SQLITE_NOTFOUND);\n          return;\n        }\n        if (state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN & opfsFlags) {\n          try {\n            await hDir.removeEntry(filenamePart);\n          } catch (e) {}\n        }\n        const hFile = await hDir.getFileHandle(filenamePart, { create });\n        const fh = Object.assign(Object.create(null), {\n          fid: fid,\n          filenameAbs: filename,\n          filenamePart: filenamePart,\n          dirHandle: hDir,\n          fileHandle: hFile,\n          sabView: state.sabFileBufView,\n          readOnly: !create && !!(state.sq3Codes.SQLITE_OPEN_READONLY & flags),\n          deleteOnClose: !!(state.sq3Codes.SQLITE_OPEN_DELETEONCLOSE & flags),\n        });\n        fh.releaseImplicitLocks =\n          opfsFlags & state.opfsFlags.OPFS_UNLOCK_ASAP ||\n          state.opfsFlags.defaultUnlockAsap;\n        __openFiles[fid] = fh;\n        storeAndNotify(opName, 0);\n      } catch (e) {\n        error(opName, e);\n        state.s11n.storeException(1, e);\n        storeAndNotify(opName, state.sq3Codes.SQLITE_IOERR);\n      }\n    },\n    xRead: async function (fid, n, offset64) {\n      let rc = 0,\n        nRead;\n      const fh = __openFiles[fid];\n      try {\n        nRead = (await getSyncHandle(fh, 'xRead')).read(\n          fh.sabView.subarray(0, n),\n          { at: Number(offset64) },\n        );\n        if (nRead < n) {\n          fh.sabView.fill(0, nRead, n);\n          rc = state.sq3Codes.SQLITE_IOERR_SHORT_READ;\n        }\n      } catch (e) {\n        error('xRead() failed', e, fh);\n        state.s11n.storeException(1, e);\n        rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR_READ);\n      }\n      await releaseImplicitLock(fh);\n      storeAndNotify('xRead', rc);\n    },\n    xSync: async function (fid, flags) {\n      const fh = __openFiles[fid];\n      let rc = 0;\n      if (!fh.readOnly && fh.syncHandle) {\n        try {\n          await fh.syncHandle.flush();\n        } catch (e) {\n          state.s11n.storeException(2, e);\n          rc = state.sq3Codes.SQLITE_IOERR_FSYNC;\n        }\n      }\n      storeAndNotify('xSync', rc);\n    },\n    xTruncate: async function (fid, size) {\n      let rc = 0;\n      const fh = __openFiles[fid];\n      try {\n        affirmNotRO('xTruncate', fh);\n        await (await getSyncHandle(fh, 'xTruncate')).truncate(size);\n      } catch (e) {\n        error('xTruncate():', e, fh);\n        state.s11n.storeException(2, e);\n        rc = GetSyncHandleError.convertRc(\n          e,\n          state.sq3Codes.SQLITE_IOERR_TRUNCATE,\n        );\n      }\n      await releaseImplicitLock(fh);\n      storeAndNotify('xTruncate', rc);\n    },\n    xUnlock: async function (fid, lockType) {\n      let rc = 0;\n      const fh = __openFiles[fid];\n      if (fh.syncHandle && state.sq3Codes.SQLITE_LOCK_NONE === lockType) {\n        try {\n          await closeSyncHandle(fh);\n        } catch (e) {\n          state.s11n.storeException(1, e);\n          rc = state.sq3Codes.SQLITE_IOERR_UNLOCK;\n        }\n      }\n      storeAndNotify('xUnlock', rc);\n    },\n    xWrite: async function (fid, n, offset64) {\n      let rc;\n      const fh = __openFiles[fid];\n      try {\n        affirmNotRO('xWrite', fh);\n        rc =\n          n ===\n          (await getSyncHandle(fh, 'xWrite')).write(fh.sabView.subarray(0, n), {\n            at: Number(offset64),\n          })\n            ? 0\n            : state.sq3Codes.SQLITE_IOERR_WRITE;\n      } catch (e) {\n        error('xWrite():', e, fh);\n        state.s11n.storeException(1, e);\n        rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR_WRITE);\n      }\n      await releaseImplicitLock(fh);\n      storeAndNotify('xWrite', rc);\n    },\n  };\n\n  const initS11n = () => {\n    if (state.s11n) return state.s11n;\n    const textDecoder = new TextDecoder(),\n      textEncoder = new TextEncoder('utf-8'),\n      viewU8 = new Uint8Array(\n        state.sabIO,\n        state.sabS11nOffset,\n        state.sabS11nSize,\n      ),\n      viewDV = new DataView(\n        state.sabIO,\n        state.sabS11nOffset,\n        state.sabS11nSize,\n      );\n    state.s11n = Object.create(null);\n    const TypeIds = Object.create(null);\n    TypeIds.number = {\n      id: 1,\n      size: 8,\n      getter: 'getFloat64',\n      setter: 'setFloat64',\n    };\n    TypeIds.bigint = {\n      id: 2,\n      size: 8,\n      getter: 'getBigInt64',\n      setter: 'setBigInt64',\n    };\n    TypeIds.boolean = {\n      id: 3,\n      size: 4,\n      getter: 'getInt32',\n      setter: 'setInt32',\n    };\n    TypeIds.string = { id: 4 };\n    const getTypeId = (v) =>\n      TypeIds[typeof v] ||\n      toss('Maintenance required: this value type cannot be serialized.', v);\n    const getTypeIdById = (tid) => {\n      switch (tid) {\n        case TypeIds.number.id:\n          return TypeIds.number;\n        case TypeIds.bigint.id:\n          return TypeIds.bigint;\n        case TypeIds.boolean.id:\n          return TypeIds.boolean;\n        case TypeIds.string.id:\n          return TypeIds.string;\n        default:\n          toss('Invalid type ID:', tid);\n      }\n    };\n    state.s11n.deserialize = function (clear = false) {\n      const argc = viewU8[0];\n      const rc = argc ? [] : null;\n      if (argc) {\n        const typeIds = [];\n        let offset = 1,\n          i,\n          n,\n          v;\n        for (i = 0; i < argc; ++i, ++offset) {\n          typeIds.push(getTypeIdById(viewU8[offset]));\n        }\n        for (i = 0; i < argc; ++i) {\n          const t = typeIds[i];\n          if (t.getter) {\n            v = viewDV[t.getter](offset, state.littleEndian);\n            offset += t.size;\n          } else {\n            n = viewDV.getInt32(offset, state.littleEndian);\n            offset += 4;\n            v = textDecoder.decode(viewU8.slice(offset, offset + n));\n            offset += n;\n          }\n          rc.push(v);\n        }\n      }\n      if (clear) viewU8[0] = 0;\n\n      return rc;\n    };\n    state.s11n.serialize = function (...args) {\n      if (args.length) {\n        const typeIds = [];\n        let i = 0,\n          offset = 1;\n        viewU8[0] = args.length & 0xff;\n        for (; i < args.length; ++i, ++offset) {\n          typeIds.push(getTypeId(args[i]));\n          viewU8[offset] = typeIds[i].id;\n        }\n        for (i = 0; i < args.length; ++i) {\n          const t = typeIds[i];\n          if (t.setter) {\n            viewDV[t.setter](offset, args[i], state.littleEndian);\n            offset += t.size;\n          } else {\n            const s = textEncoder.encode(args[i]);\n            viewDV.setInt32(offset, s.byteLength, state.littleEndian);\n            offset += 4;\n            viewU8.set(s, offset);\n            offset += s.byteLength;\n          }\n        }\n      } else {\n        viewU8[0] = 0;\n      }\n    };\n\n    state.s11n.storeException = state.asyncS11nExceptions\n      ? (priority, e) => {\n          if (priority <= state.asyncS11nExceptions) {\n            state.s11n.serialize([e.name, ': ', e.message].join(''));\n          }\n        }\n      : () => {};\n\n    return state.s11n;\n  };\n\n  const waitLoop = async function f() {\n    const opHandlers = Object.create(null);\n    for (let k of Object.keys(state.opIds)) {\n      const vi = vfsAsyncImpls[k];\n      if (!vi) continue;\n      const o = Object.create(null);\n      opHandlers[state.opIds[k]] = o;\n      o.key = k;\n      o.f = vi;\n    }\n    while (!flagAsyncShutdown) {\n      try {\n        if (\n          'not-equal' !==\n          Atomics.wait(\n            state.sabOPView,\n            state.opIds.whichOp,\n            0,\n            state.asyncIdleWaitTime,\n          )\n        ) {\n          await releaseImplicitLocks();\n          continue;\n        }\n        const opId = Atomics.load(state.sabOPView, state.opIds.whichOp);\n        Atomics.store(state.sabOPView, state.opIds.whichOp, 0);\n        const hnd =\n          opHandlers[opId] ?? toss('No waitLoop handler for whichOp #', opId);\n        const args = state.s11n.deserialize(true) || [];\n\n        if (hnd.f) await hnd.f(...args);\n        else error('Missing callback for opId', opId);\n      } catch (e) {\n        error('in waitLoop():', e);\n      }\n    }\n  };\n\n  navigator.storage\n    .getDirectory()\n    .then(function (d) {\n      state.rootDir = d;\n      globalThis.onmessage = function ({ data }) {\n        switch (data.type) {\n          case 'opfs-async-init': {\n            const opt = data.args;\n            for (const k in opt) state[k] = opt[k];\n            state.verbose = opt.verbose ?? 1;\n            state.sabOPView = new Int32Array(state.sabOP);\n            state.sabFileBufView = new Uint8Array(\n              state.sabIO,\n              0,\n              state.fileBufferSize,\n            );\n            state.sabS11nView = new Uint8Array(\n              state.sabIO,\n              state.sabS11nOffset,\n              state.sabS11nSize,\n            );\n            Object.keys(vfsAsyncImpls).forEach((k) => {\n              if (!Number.isFinite(state.opIds[k])) {\n                toss('Maintenance required: missing state.opIds[', k, ']');\n              }\n            });\n            initS11n();\n            log('init state', state);\n            wPost('opfs-async-inited');\n            waitLoop();\n            break;\n          }\n          case 'opfs-async-restart':\n            if (flagAsyncShutdown) {\n              warn(\n                'Restarting after opfs-async-shutdown. Might or might not work.',\n              );\n              flagAsyncShutdown = false;\n              waitLoop();\n            }\n            break;\n        }\n      };\n      wPost('opfs-async-loaded');\n    })\n    .catch((e) => error('error initializing OPFS asyncer:', e));\n};\nif (!globalThis.SharedArrayBuffer) {\n  wPost(\n    'opfs-unavailable',\n    'Missing SharedArrayBuffer API.',\n    'The server must emit the COOP/COEP response headers to enable that.',\n  );\n} else if (!globalThis.Atomics) {\n  wPost(\n    'opfs-unavailable',\n    'Missing Atomics API.',\n    'The server must emit the COOP/COEP response headers to enable that.',\n  );\n} else if (\n  !globalThis.FileSystemHandle ||\n  !globalThis.FileSystemDirectoryHandle ||\n  !globalThis.FileSystemFileHandle ||\n  !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||\n  !navigator?.storage?.getDirectory\n) {\n  wPost('opfs-unavailable', 'Missing required OPFS APIs.');\n} else {\n  installAsyncProxy();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9zcWxpdGUtd2FzbS9qc3dhc20vc3FsaXRlMy1vcGZzLWFzeW5jLXByb3h5LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsK0NBQStDLHFCQUFxQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSwrREFBK0QsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGl5dXNoLmRhZ2FAcG9zdG1hbi5jb20vRG9jdW1lbnRzL1Byb2plY3RzL3BpeXVzaC1kYWdhL2V2YS0yL3Nlc3Npb24xLWJ1aWxkLXRvZG8tY2FsZW5kYXIvbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLW9wZnMtYXN5bmMtcHJveHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgMjAyMi0wOS0xNlxuXG4gIFRoZSBhdXRob3IgZGlzY2xhaW1zIGNvcHlyaWdodCB0byB0aGlzIHNvdXJjZSBjb2RlLiAgSW4gcGxhY2Ugb2YgYVxuICBsZWdhbCBub3RpY2UsIGhlcmUgaXMgYSBibGVzc2luZzpcblxuICAqICAgTWF5IHlvdSBkbyBnb29kIGFuZCBub3QgZXZpbC5cbiAgKiAgIE1heSB5b3UgZmluZCBmb3JnaXZlbmVzcyBmb3IgeW91cnNlbGYgYW5kIGZvcmdpdmUgb3RoZXJzLlxuICAqICAgTWF5IHlvdSBzaGFyZSBmcmVlbHksIG5ldmVyIHRha2luZyBtb3JlIHRoYW4geW91IGdpdmUuXG5cbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIFdvcmtlciB3aGljaCBtYW5hZ2VzIGFzeW5jaHJvbm91cyBPUEZTIGhhbmRsZXMgb24gYmVoYWxmIG9mIGFcbiAgc3luY2hyb25vdXMgQVBJIHdoaWNoIGNvbnRyb2xzIGl0IHZpYSBhIGNvbWJpbmF0aW9uIG9mIFdvcmtlclxuICBtZXNzYWdlcywgU2hhcmVkQXJyYXlCdWZmZXIsIGFuZCBBdG9taWNzLiBJdCBpcyB0aGUgYXN5bmNocm9ub3VzXG4gIGNvdW50ZXJwYXJ0IG9mIHRoZSBBUEkgZGVmaW5lZCBpbiBzcWxpdGUzLXZmcy1vcGZzLmpzLlxuXG4gIEhpZ2hseSBpbmRlYnRlZCB0bzpcblxuICBodHRwczovL2dpdGh1Yi5jb20vcmhhc2hpbW90by93YS1zcWxpdGUvYmxvYi9tYXN0ZXIvc3JjL2V4YW1wbGVzL09yaWdpblByaXZhdGVGaWxlU3lzdGVtVkZTLmpzXG5cbiAgZm9yIGRlbW9uc3RyYXRpbmcgaG93IHRvIHVzZSB0aGUgT1BGUyBBUElzLlxuXG4gIFRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWQgYXMgYSBXb3JrZXIuIEl0IGRvZXMgbm90IGhhdmUgYW55IGRpcmVjdFxuICBhY2Nlc3MgdG8gdGhlIHNxbGl0ZTMgSlMvV0FTTSBiaXRzLCBzbyBhbnkgYml0cyB3aGljaCBpdCBuZWVkcyAobW9zdFxuICBub3RhYmx5IFNRTElURV94eHggaW50ZWdlciBjb2RlcykgaGF2ZSB0byBiZSBpbXBvcnRlZCBpbnRvIGl0IHZpYSBhblxuICBpbml0aWFsaXphdGlvbiBwcm9jZXNzLlxuXG4gIFRoaXMgZmlsZSByZXByZXNlbnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBhIGxhcmdlciBwaWVjZSBvZlxuICBjb2RlLCBhbmQgbm90IGEgcHVibGljIGludGVyZmFjZS4gSXRzIGRldGFpbHMgbWF5IGNoYW5nZSBhdCBhbnkgdGltZVxuICBhbmQgYXJlIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIGJ5IGFueSBjbGllbnQtbGV2ZWwgY29kZS5cblxuICAyMDIyLTExLTI3OiBDaHJvbWUgdjEwOCBjaGFuZ2VzIHNvbWUgYXN5bmMgbWV0aG9kcyB0byBzeW5jaHJvbm91cywgYXNcbiAgZG9jdW1lbnRlZCBhdDpcblxuICBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2Jsb2cvc3luYy1tZXRob2RzLWZvci1hY2Nlc3NoYW5kbGVzL1xuXG4gIEZpcmVmb3ggdjExMSBhbmQgU2FmYXJpIDE2LjQsIGJvdGggcmVsZWFzZWQgaW4gTWFyY2ggMjAyMywgYWxzb1xuICBpbmNsdWRlIHRoaXMuXG5cbiAgV2UgY2Fubm90IGNoYW5nZSB0byB0aGUgc3luYyBmb3JtcyBhdCB0aGlzIHBvaW50IHdpdGhvdXQgYnJlYWtpbmdcbiAgY2xpZW50cyB3aG8gdXNlIENocm9tZSB2MTA0LWlzaCBvciBoaWdoZXIuIHRydW5jYXRlKCksIGdldFNpemUoKSxcbiAgZmx1c2goKSwgYW5kIGNsb3NlKCkgYXJlIG5vdyAoYXMgb2YgdjEwOCkgc3luY2hyb25vdXMuIENhbGxpbmcgdGhlbVxuICB3aXRoIGFuIFwiYXdhaXRcIiwgYXMgd2UgaGF2ZSB0byBmb3IgdGhlIGFzeW5jIGZvcm1zLCBpcyBzdGlsbCBsZWdhbFxuICB3aXRoIHRoZSBzeW5jIGZvcm1zIGJ1dCBpcyBzdXBlcmZsdW91cy4gQ2FsbGluZyB0aGUgYXN5bmMgZm9ybXMgd2l0aFxuICB0aGVGdW5jKCkudGhlbiguLi4pIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGNoYW5nZSB0b1xuICBzeW5jaHJvbm91cywgYnV0IHdlIGRvIGRvIG5vdCB1c2UgdGhvc2UgQVBJcyB0aGF0IHdheS4gaS5lLiB3ZSBkb24ndFxuICBfbmVlZF8gdG8gY2hhbmdlIGFueXRoaW5nIGZvciB0aGlzLCBidXQgYXQgc29tZSBwb2ludCAoYWZ0ZXIgQ2hyb21lXG4gIHZlcnNpb25zIChhcHByb3hpbWF0ZWx5KSAxMDQtMTA3IGFyZSBleHRpbmN0KSBzaG91bGQgY2hhbmdlIG91clxuICB1c2FnZSBvZiB0aG9zZSBtZXRob2RzIHRvIHJlbW92ZSB0aGUgXCJhd2FpdFwiLlxuKi9cbid1c2Ugc3RyaWN0JztcbmNvbnN0IHdQb3N0ID0gKHR5cGUsIC4uLmFyZ3MpID0+IHBvc3RNZXNzYWdlKHsgdHlwZSwgcGF5bG9hZDogYXJncyB9KTtcbmNvbnN0IGluc3RhbGxBc3luY1Byb3h5ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB0b3NzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICB9O1xuICBpZiAoZ2xvYmFsVGhpcy53aW5kb3cgPT09IGdsb2JhbFRoaXMpIHtcbiAgICB0b3NzKFxuICAgICAgJ1RoaXMgY29kZSBjYW5ub3QgcnVuIGZyb20gdGhlIG1haW4gdGhyZWFkLicsXG4gICAgICAnTG9hZCBpdCBhcyBhIFdvcmtlciBmcm9tIGEgc2VwYXJhdGUgV29ya2VyLicsXG4gICAgKTtcbiAgfSBlbHNlIGlmICghbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3RvcnkpIHtcbiAgICB0b3NzKCdUaGlzIEFQSSByZXF1aXJlcyBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkuJyk7XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgc3RhdGUudmVyYm9zZSA9IDE7XG5cbiAgY29uc3QgbG9nZ2VycyA9IHtcbiAgICAwOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgMTogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSksXG4gICAgMjogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgfTtcbiAgY29uc3QgbG9nSW1wbCA9IChsZXZlbCwgLi4uYXJncykgPT4ge1xuICAgIGlmIChzdGF0ZS52ZXJib3NlID4gbGV2ZWwpIGxvZ2dlcnNbbGV2ZWxdKCdPUEZTIGFzeW5jZXI6JywgLi4uYXJncyk7XG4gIH07XG4gIGNvbnN0IGxvZyA9ICguLi5hcmdzKSA9PiBsb2dJbXBsKDIsIC4uLmFyZ3MpO1xuICBjb25zdCB3YXJuID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMSwgLi4uYXJncyk7XG4gIGNvbnN0IGVycm9yID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMCwgLi4uYXJncyk7XG5cbiAgY29uc3QgX19vcGVuRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IF9faW1wbGljaXRMb2NrcyA9IG5ldyBTZXQoKTtcblxuICBjb25zdCBnZXRSZXNvbHZlZFBhdGggPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHNwbGl0SXQpIHtcbiAgICBjb25zdCBwID0gbmV3IFVSTChmaWxlbmFtZSwgJ2ZpbGU6Ly9pcnJlbGV2YW50JykucGF0aG5hbWU7XG4gICAgcmV0dXJuIHNwbGl0SXQgPyBwLnNwbGl0KCcvJykuZmlsdGVyKCh2KSA9PiAhIXYpIDogcDtcbiAgfTtcblxuICBjb25zdCBnZXREaXJGb3JGaWxlbmFtZSA9IGFzeW5jIGZ1bmN0aW9uIGYoYWJzRmlsZW5hbWUsIGNyZWF0ZURpcnMgPSBmYWxzZSkge1xuICAgIGNvbnN0IHBhdGggPSBnZXRSZXNvbHZlZFBhdGgoYWJzRmlsZW5hbWUsIHRydWUpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5wb3AoKTtcbiAgICBsZXQgZGggPSBzdGF0ZS5yb290RGlyO1xuICAgIGZvciAoY29uc3QgZGlyTmFtZSBvZiBwYXRoKSB7XG4gICAgICBpZiAoZGlyTmFtZSkge1xuICAgICAgICBkaCA9IGF3YWl0IGRoLmdldERpcmVjdG9yeUhhbmRsZShkaXJOYW1lLCB7IGNyZWF0ZTogISFjcmVhdGVEaXJzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2RoLCBmaWxlbmFtZV07XG4gIH07XG5cbiAgY29uc3QgY2xvc2VTeW5jSGFuZGxlID0gYXN5bmMgKGZoKSA9PiB7XG4gICAgaWYgKGZoLnN5bmNIYW5kbGUpIHtcbiAgICAgIGxvZygnQ2xvc2luZyBzeW5jIGhhbmRsZSBmb3InLCBmaC5maWxlbmFtZUFicyk7XG4gICAgICBjb25zdCBoID0gZmguc3luY0hhbmRsZTtcbiAgICAgIGRlbGV0ZSBmaC5zeW5jSGFuZGxlO1xuICAgICAgZGVsZXRlIGZoLnhMb2NrO1xuICAgICAgX19pbXBsaWNpdExvY2tzLmRlbGV0ZShmaC5maWQpO1xuICAgICAgcmV0dXJuIGguY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xvc2VTeW5jSGFuZGxlTm9UaHJvdyA9IGFzeW5jIChmaCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbG9zZVN5bmNIYW5kbGUoZmgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ2Nsb3NlU3luY0hhbmRsZU5vVGhyb3coKSBpZ25vcmluZzonLCBlLCBmaCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlbGVhc2VJbXBsaWNpdExvY2tzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChfX2ltcGxpY2l0TG9ja3Muc2l6ZSkge1xuICAgICAgZm9yIChjb25zdCBmaWQgb2YgX19pbXBsaWNpdExvY2tzKSB7XG4gICAgICAgIGNvbnN0IGZoID0gX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgICAgYXdhaXQgY2xvc2VTeW5jSGFuZGxlTm9UaHJvdyhmaCk7XG4gICAgICAgIGxvZygnQXV0by11bmxvY2tlZCcsIGZpZCwgZmguZmlsZW5hbWVBYnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWxlYXNlSW1wbGljaXRMb2NrID0gYXN5bmMgKGZoKSA9PiB7XG4gICAgaWYgKGZoLnJlbGVhc2VJbXBsaWNpdExvY2tzICYmIF9faW1wbGljaXRMb2Nrcy5oYXMoZmguZmlkKSkge1xuICAgICAgcmV0dXJuIGNsb3NlU3luY0hhbmRsZU5vVGhyb3coZmgpO1xuICAgIH1cbiAgfTtcblxuICBjbGFzcyBHZXRTeW5jSGFuZGxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JPYmplY3QsIC4uLm1zZykge1xuICAgICAgc3VwZXIoXG4gICAgICAgIFsuLi5tc2csICc6ICcgKyBlcnJvck9iamVjdC5uYW1lICsgJzonLCBlcnJvck9iamVjdC5tZXNzYWdlXS5qb2luKCcgJyksXG4gICAgICAgIHtcbiAgICAgICAgICBjYXVzZTogZXJyb3JPYmplY3QsXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdGhpcy5uYW1lID0gJ0dldFN5bmNIYW5kbGVFcnJvcic7XG4gICAgfVxuICB9XG5cbiAgR2V0U3luY0hhbmRsZUVycm9yLmNvbnZlcnRSYyA9IChlLCByYykgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgR2V0U3luY0hhbmRsZUVycm9yKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGUuY2F1c2UubmFtZSA9PT0gJ05vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yJyB8fFxuICAgICAgICAoZS5jYXVzZS5uYW1lID09PSAnRE9NRXhjZXB0aW9uJyAmJlxuICAgICAgICAgIDAgPT09IGUuY2F1c2UubWVzc2FnZS5pbmRleE9mKCdBY2Nlc3MgSGFuZGxlcyBjYW5ub3QnKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0JVU1k7XG4gICAgICB9IGVsc2UgaWYgKCdOb3RGb3VuZEVycm9yJyA9PT0gZS5jYXVzZS5uYW1lKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnTm90Rm91bmRFcnJvcicgPT09IGU/Lm5hbWUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfQ0FOVE9QRU47XG4gICAgfVxuICAgIHJldHVybiByYztcbiAgfTtcblxuICBjb25zdCBnZXRTeW5jSGFuZGxlID0gYXN5bmMgKGZoLCBvcE5hbWUpID0+IHtcbiAgICBpZiAoIWZoLnN5bmNIYW5kbGUpIHtcbiAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGxvZygnQWNxdWlyaW5nIHN5bmMgaGFuZGxlIGZvcicsIGZoLmZpbGVuYW1lQWJzKTtcbiAgICAgIGNvbnN0IG1heFRyaWVzID0gNixcbiAgICAgICAgbXNCYXNlID0gc3RhdGUuYXN5bmNJZGxlV2FpdFRpbWUgKiAyO1xuICAgICAgbGV0IGkgPSAxLFxuICAgICAgICBtcyA9IG1zQmFzZTtcbiAgICAgIGZvciAoOyB0cnVlOyBtcyA9IG1zQmFzZSAqICsraSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZoLnN5bmNIYW5kbGUgPSBhd2FpdCBmaC5maWxlSGFuZGxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChpID09PSBtYXhUcmllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdldFN5bmNIYW5kbGVFcnJvcihcbiAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgJ0Vycm9yIGdldHRpbmcgc3luYyBoYW5kbGUgZm9yJyxcbiAgICAgICAgICAgICAgb3BOYW1lICsgJygpLicsXG4gICAgICAgICAgICAgIG1heFRyaWVzLFxuICAgICAgICAgICAgICAnYXR0ZW1wdHMgZmFpbGVkLicsXG4gICAgICAgICAgICAgIGZoLmZpbGVuYW1lQWJzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdFcnJvciBnZXR0aW5nIHN5bmMgaGFuZGxlIGZvcicsXG4gICAgICAgICAgICBvcE5hbWUgKyAnKCkuIFdhaXRpbmcnLFxuICAgICAgICAgICAgbXMsXG4gICAgICAgICAgICAnbXMgYW5kIHRyeWluZyBhZ2Fpbi4nLFxuICAgICAgICAgICAgZmguZmlsZW5hbWVBYnMsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmV0cnksIDAsIG1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nKFxuICAgICAgICAnR290JyxcbiAgICAgICAgb3BOYW1lICsgJygpIHN5bmMgaGFuZGxlIGZvcicsXG4gICAgICAgIGZoLmZpbGVuYW1lQWJzLFxuICAgICAgICAnaW4nLFxuICAgICAgICBwZXJmb3JtYW5jZS5ub3coKSAtIHQsXG4gICAgICAgICdtcycsXG4gICAgICApO1xuICAgICAgaWYgKCFmaC54TG9jaykge1xuICAgICAgICBfX2ltcGxpY2l0TG9ja3MuYWRkKGZoLmZpZCk7XG4gICAgICAgIGxvZyhcbiAgICAgICAgICAnQWNxdWlyZWQgaW1wbGljaXQgbG9jayBmb3InLFxuICAgICAgICAgIG9wTmFtZSArICcoKScsXG4gICAgICAgICAgZmguZmlkLFxuICAgICAgICAgIGZoLmZpbGVuYW1lQWJzLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmguc3luY0hhbmRsZTtcbiAgfTtcblxuICBjb25zdCBzdG9yZUFuZE5vdGlmeSA9IChvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgbG9nKG9wTmFtZSArICcoKSA9PiBub3RpZnkoJywgdmFsdWUsICcpJyk7XG4gICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjLCB2YWx1ZSk7XG4gICAgQXRvbWljcy5ub3RpZnkoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYyk7XG4gIH07XG5cbiAgY29uc3QgYWZmaXJtTm90Uk8gPSBmdW5jdGlvbiAob3BOYW1lLCBmaCkge1xuICAgIGlmIChmaC5yZWFkT25seSkgdG9zcyhvcE5hbWUgKyAnKCk6IEZpbGUgaXMgcmVhZC1vbmx5OiAnICsgZmguZmlsZW5hbWVBYnMpO1xuICB9O1xuXG4gIGxldCBmbGFnQXN5bmNTaHV0ZG93biA9IGZhbHNlO1xuXG4gIGNvbnN0IHZmc0FzeW5jSW1wbHMgPSB7XG4gICAgJ29wZnMtYXN5bmMtc2h1dGRvd24nOiBhc3luYyAoKSA9PiB7XG4gICAgICBmbGFnQXN5bmNTaHV0ZG93biA9IHRydWU7XG4gICAgICBzdG9yZUFuZE5vdGlmeSgnb3Bmcy1hc3luYy1zaHV0ZG93bicsIDApO1xuICAgIH0sXG4gICAgbWtkaXI6IGFzeW5jIChkaXJuYW1lKSA9PiB7XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZ2V0RGlyRm9yRmlsZW5hbWUoZGlybmFtZSArICcvZmlsZXBhcnQnLCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbigyLCBlKTtcbiAgICAgICAgcmMgPSBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlI7XG4gICAgICB9XG4gICAgICBzdG9yZUFuZE5vdGlmeSgnbWtkaXInLCByYyk7XG4gICAgfSxcbiAgICB4QWNjZXNzOiBhc3luYyAoZmlsZW5hbWUpID0+IHtcbiAgICAgIGxldCByYyA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbZGgsIGZuXSA9IGF3YWl0IGdldERpckZvckZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMiwgZSk7XG4gICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSO1xuICAgICAgfVxuICAgICAgc3RvcmVBbmROb3RpZnkoJ3hBY2Nlc3MnLCByYyk7XG4gICAgfSxcbiAgICB4Q2xvc2U6IGFzeW5jIGZ1bmN0aW9uIChmaWQpIHtcbiAgICAgIGNvbnN0IG9wTmFtZSA9ICd4Q2xvc2UnO1xuICAgICAgX19pbXBsaWNpdExvY2tzLmRlbGV0ZShmaWQpO1xuICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIGlmIChmaCkge1xuICAgICAgICBkZWxldGUgX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgICAgYXdhaXQgY2xvc2VTeW5jSGFuZGxlKGZoKTtcbiAgICAgICAgaWYgKGZoLmRlbGV0ZU9uQ2xvc2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZmguZGlySGFuZGxlLnJlbW92ZUVudHJ5KGZoLmZpbGVuYW1lUGFydCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgd2FybignSWdub3JpbmcgZGlySGFuZGxlLnJlbW92ZUVudHJ5KCkgZmFpbHVyZSBvZicsIGZoLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKCk7XG4gICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgfVxuICAgICAgc3RvcmVBbmROb3RpZnkob3BOYW1lLCByYyk7XG4gICAgfSxcbiAgICB4RGVsZXRlOiBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgY29uc3QgcmMgPSBhd2FpdCB2ZnNBc3luY0ltcGxzLnhEZWxldGVOb1dhaXQoLi4uYXJncyk7XG4gICAgICBzdG9yZUFuZE5vdGlmeSgneERlbGV0ZScsIHJjKTtcbiAgICB9LFxuICAgIHhEZWxldGVOb1dhaXQ6IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSwgc3luY0RpciA9IDAsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKGZpbGVuYW1lKSB7XG4gICAgICAgICAgY29uc3QgW2hEaXIsIGZpbGVuYW1lUGFydF0gPSBhd2FpdCBnZXREaXJGb3JGaWxlbmFtZShmaWxlbmFtZSwgZmFsc2UpO1xuICAgICAgICAgIGlmICghZmlsZW5hbWVQYXJ0KSBicmVhaztcbiAgICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KGZpbGVuYW1lUGFydCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgaWYgKDB4MTIzNCAhPT0gc3luY0RpcikgYnJlYWs7XG4gICAgICAgICAgcmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgICAgZmlsZW5hbWUgPSBnZXRSZXNvbHZlZFBhdGgoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAgIGZpbGVuYW1lLnBvcCgpO1xuICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMiwgZSk7XG4gICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX0RFTEVURTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuICAgIHhGaWxlU2l6ZTogYXN5bmMgZnVuY3Rpb24gKGZpZCkge1xuICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN6ID0gYXdhaXQgKGF3YWl0IGdldFN5bmNIYW5kbGUoZmgsICd4RmlsZVNpemUnKSkuZ2V0U2l6ZSgpO1xuICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZShOdW1iZXIoc3opKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbigxLCBlKTtcbiAgICAgICAgcmMgPSBHZXRTeW5jSGFuZGxlRXJyb3IuY29udmVydFJjKGUsIHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUik7XG4gICAgICB9XG4gICAgICBhd2FpdCByZWxlYXNlSW1wbGljaXRMb2NrKGZoKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4RmlsZVNpemUnLCByYyk7XG4gICAgfSxcbiAgICB4TG9jazogYXN5bmMgZnVuY3Rpb24gKGZpZCwgbG9ja1R5cGUpIHtcbiAgICAgIGNvbnN0IGZoID0gX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgIGxldCByYyA9IDA7XG4gICAgICBjb25zdCBvbGRMb2NrVHlwZSA9IGZoLnhMb2NrO1xuICAgICAgZmgueExvY2sgPSBsb2NrVHlwZTtcbiAgICAgIGlmICghZmguc3luY0hhbmRsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGdldFN5bmNIYW5kbGUoZmgsICd4TG9jaycpO1xuICAgICAgICAgIF9faW1wbGljaXRMb2Nrcy5kZWxldGUoZmlkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgICAgcmMgPSBHZXRTeW5jSGFuZGxlRXJyb3IuY29udmVydFJjKFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUl9MT0NLLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZmgueExvY2sgPSBvbGRMb2NrVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RvcmVBbmROb3RpZnkoJ3hMb2NrJywgcmMpO1xuICAgIH0sXG4gICAgeE9wZW46IGFzeW5jIGZ1bmN0aW9uIChmaWQsIGZpbGVuYW1lLCBmbGFncywgb3Bmc0ZsYWdzKSB7XG4gICAgICBjb25zdCBvcE5hbWUgPSAneE9wZW4nO1xuICAgICAgY29uc3QgY3JlYXRlID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX09QRU5fQ1JFQVRFICYgZmxhZ3M7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgaERpciwgZmlsZW5hbWVQYXJ0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIFtoRGlyLCBmaWxlbmFtZVBhcnRdID0gYXdhaXQgZ2V0RGlyRm9yRmlsZW5hbWUoZmlsZW5hbWUsICEhY3JlYXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgICAgc3RvcmVBbmROb3RpZnkob3BOYW1lLCBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfTk9URk9VTkQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUub3Bmc0ZsYWdzLk9QRlNfVU5MSU5LX0JFRk9SRV9PUEVOICYgb3Bmc0ZsYWdzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGhEaXIucmVtb3ZlRW50cnkoZmlsZW5hbWVQYXJ0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZpbGVuYW1lUGFydCwgeyBjcmVhdGUgfSk7XG4gICAgICAgIGNvbnN0IGZoID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgZmlkOiBmaWQsXG4gICAgICAgICAgZmlsZW5hbWVBYnM6IGZpbGVuYW1lLFxuICAgICAgICAgIGZpbGVuYW1lUGFydDogZmlsZW5hbWVQYXJ0LFxuICAgICAgICAgIGRpckhhbmRsZTogaERpcixcbiAgICAgICAgICBmaWxlSGFuZGxlOiBoRmlsZSxcbiAgICAgICAgICBzYWJWaWV3OiBzdGF0ZS5zYWJGaWxlQnVmVmlldyxcbiAgICAgICAgICByZWFkT25seTogIWNyZWF0ZSAmJiAhIShzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfT1BFTl9SRUFET05MWSAmIGZsYWdzKSxcbiAgICAgICAgICBkZWxldGVPbkNsb3NlOiAhIShzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFICYgZmxhZ3MpLFxuICAgICAgICB9KTtcbiAgICAgICAgZmgucmVsZWFzZUltcGxpY2l0TG9ja3MgPVxuICAgICAgICAgIG9wZnNGbGFncyAmIHN0YXRlLm9wZnNGbGFncy5PUEZTX1VOTE9DS19BU0FQIHx8XG4gICAgICAgICAgc3RhdGUub3Bmc0ZsYWdzLmRlZmF1bHRVbmxvY2tBc2FwO1xuICAgICAgICBfX29wZW5GaWxlc1tmaWRdID0gZmg7XG4gICAgICAgIHN0b3JlQW5kTm90aWZ5KG9wTmFtZSwgMCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKG9wTmFtZSwgZSk7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgIHN0b3JlQW5kTm90aWZ5KG9wTmFtZSwgc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHhSZWFkOiBhc3luYyBmdW5jdGlvbiAoZmlkLCBuLCBvZmZzZXQ2NCkge1xuICAgICAgbGV0IHJjID0gMCxcbiAgICAgICAgblJlYWQ7XG4gICAgICBjb25zdCBmaCA9IF9fb3BlbkZpbGVzW2ZpZF07XG4gICAgICB0cnkge1xuICAgICAgICBuUmVhZCA9IChhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneFJlYWQnKSkucmVhZChcbiAgICAgICAgICBmaC5zYWJWaWV3LnN1YmFycmF5KDAsIG4pLFxuICAgICAgICAgIHsgYXQ6IE51bWJlcihvZmZzZXQ2NCkgfSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG5SZWFkIDwgbikge1xuICAgICAgICAgIGZoLnNhYlZpZXcuZmlsbCgwLCBuUmVhZCwgbik7XG4gICAgICAgICAgcmMgPSBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlJfU0hPUlRfUkVBRDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcigneFJlYWQoKSBmYWlsZWQnLCBlLCBmaCk7XG4gICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgIHJjID0gR2V0U3luY0hhbmRsZUVycm9yLmNvbnZlcnRSYyhlLCBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlJfUkVBRCk7XG4gICAgICB9XG4gICAgICBhd2FpdCByZWxlYXNlSW1wbGljaXRMb2NrKGZoKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4UmVhZCcsIHJjKTtcbiAgICB9LFxuICAgIHhTeW5jOiBhc3luYyBmdW5jdGlvbiAoZmlkLCBmbGFncykge1xuICAgICAgY29uc3QgZmggPSBfX29wZW5GaWxlc1tmaWRdO1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIGlmICghZmgucmVhZE9ubHkgJiYgZmguc3luY0hhbmRsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGZoLnN5bmNIYW5kbGUuZmx1c2goKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMiwgZSk7XG4gICAgICAgICAgcmMgPSBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlJfRlNZTkM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4U3luYycsIHJjKTtcbiAgICB9LFxuICAgIHhUcnVuY2F0ZTogYXN5bmMgZnVuY3Rpb24gKGZpZCwgc2l6ZSkge1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIGNvbnN0IGZoID0gX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFmZmlybU5vdFJPKCd4VHJ1bmNhdGUnLCBmaCk7XG4gICAgICAgIGF3YWl0IChhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneFRydW5jYXRlJykpLnRydW5jYXRlKHNpemUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcigneFRydW5jYXRlKCk6JywgZSwgZmgpO1xuICAgICAgICBzdGF0ZS5zMTFuLnN0b3JlRXhjZXB0aW9uKDIsIGUpO1xuICAgICAgICByYyA9IEdldFN5bmNIYW5kbGVFcnJvci5jb252ZXJ0UmMoXG4gICAgICAgICAgZSxcbiAgICAgICAgICBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlJfVFJVTkNBVEUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhd2FpdCByZWxlYXNlSW1wbGljaXRMb2NrKGZoKTtcbiAgICAgIHN0b3JlQW5kTm90aWZ5KCd4VHJ1bmNhdGUnLCByYyk7XG4gICAgfSxcbiAgICB4VW5sb2NrOiBhc3luYyBmdW5jdGlvbiAoZmlkLCBsb2NrVHlwZSkge1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIGNvbnN0IGZoID0gX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgIGlmIChmaC5zeW5jSGFuZGxlICYmIHN0YXRlLnNxM0NvZGVzLlNRTElURV9MT0NLX05PTkUgPT09IGxvY2tUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgY2xvc2VTeW5jSGFuZGxlKGZoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN0YXRlLnMxMW4uc3RvcmVFeGNlcHRpb24oMSwgZSk7XG4gICAgICAgICAgcmMgPSBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlJfVU5MT0NLO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdG9yZUFuZE5vdGlmeSgneFVubG9jaycsIHJjKTtcbiAgICB9LFxuICAgIHhXcml0ZTogYXN5bmMgZnVuY3Rpb24gKGZpZCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgIGxldCByYztcbiAgICAgIGNvbnN0IGZoID0gX19vcGVuRmlsZXNbZmlkXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFmZmlybU5vdFJPKCd4V3JpdGUnLCBmaCk7XG4gICAgICAgIHJjID1cbiAgICAgICAgICBuID09PVxuICAgICAgICAgIChhd2FpdCBnZXRTeW5jSGFuZGxlKGZoLCAneFdyaXRlJykpLndyaXRlKGZoLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHtcbiAgICAgICAgICAgIGF0OiBOdW1iZXIob2Zmc2V0NjQpLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX1dSSVRFO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcigneFdyaXRlKCk6JywgZSwgZmgpO1xuICAgICAgICBzdGF0ZS5zMTFuLnN0b3JlRXhjZXB0aW9uKDEsIGUpO1xuICAgICAgICByYyA9IEdldFN5bmNIYW5kbGVFcnJvci5jb252ZXJ0UmMoZSwgc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSX1dSSVRFKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlbGVhc2VJbXBsaWNpdExvY2soZmgpO1xuICAgICAgc3RvcmVBbmROb3RpZnkoJ3hXcml0ZScsIHJjKTtcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IGluaXRTMTFuID0gKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zMTFuKSByZXR1cm4gc3RhdGUuczExbjtcbiAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JyksXG4gICAgICB2aWV3VTggPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgKSxcbiAgICAgIHZpZXdEViA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgKTtcbiAgICBzdGF0ZS5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBUeXBlSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBUeXBlSWRzLm51bWJlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgc2l6ZTogOCxcbiAgICAgIGdldHRlcjogJ2dldEZsb2F0NjQnLFxuICAgICAgc2V0dGVyOiAnc2V0RmxvYXQ2NCcsXG4gICAgfTtcbiAgICBUeXBlSWRzLmJpZ2ludCA9IHtcbiAgICAgIGlkOiAyLFxuICAgICAgc2l6ZTogOCxcbiAgICAgIGdldHRlcjogJ2dldEJpZ0ludDY0JyxcbiAgICAgIHNldHRlcjogJ3NldEJpZ0ludDY0JyxcbiAgICB9O1xuICAgIFR5cGVJZHMuYm9vbGVhbiA9IHtcbiAgICAgIGlkOiAzLFxuICAgICAgc2l6ZTogNCxcbiAgICAgIGdldHRlcjogJ2dldEludDMyJyxcbiAgICAgIHNldHRlcjogJ3NldEludDMyJyxcbiAgICB9O1xuICAgIFR5cGVJZHMuc3RyaW5nID0geyBpZDogNCB9O1xuICAgIGNvbnN0IGdldFR5cGVJZCA9ICh2KSA9PlxuICAgICAgVHlwZUlkc1t0eXBlb2Ygdl0gfHxcbiAgICAgIHRvc3MoJ01haW50ZW5hbmNlIHJlcXVpcmVkOiB0aGlzIHZhbHVlIHR5cGUgY2Fubm90IGJlIHNlcmlhbGl6ZWQuJywgdik7XG4gICAgY29uc3QgZ2V0VHlwZUlkQnlJZCA9ICh0aWQpID0+IHtcbiAgICAgIHN3aXRjaCAodGlkKSB7XG4gICAgICAgIGNhc2UgVHlwZUlkcy5udW1iZXIuaWQ6XG4gICAgICAgICAgcmV0dXJuIFR5cGVJZHMubnVtYmVyO1xuICAgICAgICBjYXNlIFR5cGVJZHMuYmlnaW50LmlkOlxuICAgICAgICAgIHJldHVybiBUeXBlSWRzLmJpZ2ludDtcbiAgICAgICAgY2FzZSBUeXBlSWRzLmJvb2xlYW4uaWQ6XG4gICAgICAgICAgcmV0dXJuIFR5cGVJZHMuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBUeXBlSWRzLnN0cmluZy5pZDpcbiAgICAgICAgICByZXR1cm4gVHlwZUlkcy5zdHJpbmc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIElEOicsIHRpZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGNsZWFyID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGFyZ2MgPSB2aWV3VThbMF07XG4gICAgICBjb25zdCByYyA9IGFyZ2MgPyBbXSA6IG51bGw7XG4gICAgICBpZiAoYXJnYykge1xuICAgICAgICBjb25zdCB0eXBlSWRzID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSAxLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICB2O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgKytpLCArK29mZnNldCkge1xuICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWRCeUlkKHZpZXdVOFtvZmZzZXRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgIGlmICh0LmdldHRlcikge1xuICAgICAgICAgICAgdiA9IHZpZXdEVlt0LmdldHRlcl0ob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHQuc2l6ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiA9IHZpZXdEVi5nZXRJbnQzMihvZmZzZXQsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHYgPSB0ZXh0RGVjb2Rlci5kZWNvZGUodmlld1U4LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJjLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjbGVhcikgdmlld1U4WzBdID0gMDtcblxuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG4gICAgc3RhdGUuczExbi5zZXJpYWxpemUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIHZpZXdVOFswXSA9IGFyZ3MubGVuZ3RoICYgMHhmZjtcbiAgICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgKytpLCArK29mZnNldCkge1xuICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWQoYXJnc1tpXSkpO1xuICAgICAgICAgIHZpZXdVOFtvZmZzZXRdID0gdHlwZUlkc1tpXS5pZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgIGlmICh0LnNldHRlcikge1xuICAgICAgICAgICAgdmlld0RWW3Quc2V0dGVyXShvZmZzZXQsIGFyZ3NbaV0sIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGV4dEVuY29kZXIuZW5jb2RlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgdmlld0RWLnNldEludDMyKG9mZnNldCwgcy5ieXRlTGVuZ3RoLCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB2aWV3VTguc2V0KHMsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld1U4WzBdID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhdGUuczExbi5zdG9yZUV4Y2VwdGlvbiA9IHN0YXRlLmFzeW5jUzExbkV4Y2VwdGlvbnNcbiAgICAgID8gKHByaW9yaXR5LCBlKSA9PiB7XG4gICAgICAgICAgaWYgKHByaW9yaXR5IDw9IHN0YXRlLmFzeW5jUzExbkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKFtlLm5hbWUsICc6ICcsIGUubWVzc2FnZV0uam9pbignJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgOiAoKSA9PiB7fTtcblxuICAgIHJldHVybiBzdGF0ZS5zMTFuO1xuICB9O1xuXG4gIGNvbnN0IHdhaXRMb29wID0gYXN5bmMgZnVuY3Rpb24gZigpIHtcbiAgICBjb25zdCBvcEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBrIG9mIE9iamVjdC5rZXlzKHN0YXRlLm9wSWRzKSkge1xuICAgICAgY29uc3QgdmkgPSB2ZnNBc3luY0ltcGxzW2tdO1xuICAgICAgaWYgKCF2aSkgY29udGludWU7XG4gICAgICBjb25zdCBvID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wSGFuZGxlcnNbc3RhdGUub3BJZHNba11dID0gbztcbiAgICAgIG8ua2V5ID0gaztcbiAgICAgIG8uZiA9IHZpO1xuICAgIH1cbiAgICB3aGlsZSAoIWZsYWdBc3luY1NodXRkb3duKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgJ25vdC1lcXVhbCcgIT09XG4gICAgICAgICAgQXRvbWljcy53YWl0KFxuICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3LFxuICAgICAgICAgICAgc3RhdGUub3BJZHMud2hpY2hPcCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBzdGF0ZS5hc3luY0lkbGVXYWl0VGltZSxcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGF3YWl0IHJlbGVhc2VJbXBsaWNpdExvY2tzKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BJZCA9IEF0b21pY3MubG9hZChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3ApO1xuICAgICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMud2hpY2hPcCwgMCk7XG4gICAgICAgIGNvbnN0IGhuZCA9XG4gICAgICAgICAgb3BIYW5kbGVyc1tvcElkXSA/PyB0b3NzKCdObyB3YWl0TG9vcCBoYW5kbGVyIGZvciB3aGljaE9wICMnLCBvcElkKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHN0YXRlLnMxMW4uZGVzZXJpYWxpemUodHJ1ZSkgfHwgW107XG5cbiAgICAgICAgaWYgKGhuZC5mKSBhd2FpdCBobmQuZiguLi5hcmdzKTtcbiAgICAgICAgZWxzZSBlcnJvcignTWlzc2luZyBjYWxsYmFjayBmb3Igb3BJZCcsIG9wSWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignaW4gd2FpdExvb3AoKTonLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbmF2aWdhdG9yLnN0b3JhZ2VcbiAgICAuZ2V0RGlyZWN0b3J5KClcbiAgICAudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgc3RhdGUucm9vdERpciA9IGQ7XG4gICAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICh7IGRhdGEgfSkge1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtaW5pdCc6IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRhdGEuYXJncztcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBvcHQpIHN0YXRlW2tdID0gb3B0W2tdO1xuICAgICAgICAgICAgc3RhdGUudmVyYm9zZSA9IG9wdC52ZXJib3NlID8/IDE7XG4gICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXcgPSBuZXcgSW50MzJBcnJheShzdGF0ZS5zYWJPUCk7XG4gICAgICAgICAgICBzdGF0ZS5zYWJGaWxlQnVmVmlldyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgc3RhdGUuZmlsZUJ1ZmZlclNpemUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3RhdGUuc2FiUzExblZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZmc0FzeW5jSW1wbHMpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhdGUub3BJZHNba10pKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG1pc3Npbmcgc3RhdGUub3BJZHNbJywgaywgJ10nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbml0UzExbigpO1xuICAgICAgICAgICAgbG9nKCdpbml0IHN0YXRlJywgc3RhdGUpO1xuICAgICAgICAgICAgd1Bvc3QoJ29wZnMtYXN5bmMtaW5pdGVkJyk7XG4gICAgICAgICAgICB3YWl0TG9vcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtcmVzdGFydCc6XG4gICAgICAgICAgICBpZiAoZmxhZ0FzeW5jU2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnUmVzdGFydGluZyBhZnRlciBvcGZzLWFzeW5jLXNodXRkb3duLiBNaWdodCBvciBtaWdodCBub3Qgd29yay4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFnQXN5bmNTaHV0ZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICB3YWl0TG9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3UG9zdCgnb3Bmcy1hc3luYy1sb2FkZWQnKTtcbiAgICB9KVxuICAgIC5jYXRjaCgoZSkgPT4gZXJyb3IoJ2Vycm9yIGluaXRpYWxpemluZyBPUEZTIGFzeW5jZXI6JywgZSkpO1xufTtcbmlmICghZ2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcikge1xuICB3UG9zdChcbiAgICAnb3Bmcy11bmF2YWlsYWJsZScsXG4gICAgJ01pc3NpbmcgU2hhcmVkQXJyYXlCdWZmZXIgQVBJLicsXG4gICAgJ1RoZSBzZXJ2ZXIgbXVzdCBlbWl0IHRoZSBDT09QL0NPRVAgcmVzcG9uc2UgaGVhZGVycyB0byBlbmFibGUgdGhhdC4nLFxuICApO1xufSBlbHNlIGlmICghZ2xvYmFsVGhpcy5BdG9taWNzKSB7XG4gIHdQb3N0KFxuICAgICdvcGZzLXVuYXZhaWxhYmxlJyxcbiAgICAnTWlzc2luZyBBdG9taWNzIEFQSS4nLFxuICAgICdUaGUgc2VydmVyIG11c3QgZW1pdCB0aGUgQ09PUC9DT0VQIHJlc3BvbnNlIGhlYWRlcnMgdG8gZW5hYmxlIHRoYXQuJyxcbiAgKTtcbn0gZWxzZSBpZiAoXG4gICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgfHxcbiAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8fFxuICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSB8fFxuICAhbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3Rvcnlcbikge1xuICB3UG9zdCgnb3Bmcy11bmF2YWlsYWJsZScsICdNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy4nKTtcbn0gZWxzZSB7XG4gIGluc3RhbGxBc3luY1Byb3h5KCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-opfs-async-proxy.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("static/webpack/" + __webpack_require__.h() + ".9d2bf30f188f153d.hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("84300688a80b52c1")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script),
/******/ 					createScriptURL: (url) => (url)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	(() => {
/******/ 		__webpack_require__.tu = (url) => (__webpack_require__.tt().createScriptURL(url));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		var createStylesheet = (chunkId, fullhref, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 			if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {
/******/ 				linkTag.crossOrigin = "anonymous";
/******/ 			}
/******/ 			(function(linkTag) {
/******/ 			                if (typeof _N_E_STYLE_LOAD === 'function') {
/******/ 			                    const { href, onload, onerror } = linkTag;
/******/ 			                    _N_E_STYLE_LOAD(href.indexOf(window.location.origin) === 0 ? new URL(href).pathname : href).then(()=>onload == null ? void 0 : onload.call(linkTag, {
/******/ 			                            type: 'load'
/******/ 			                        }), ()=>onerror == null ? void 0 : onerror.call(linkTag, {}));
/******/ 			                } else {
/******/ 			                    document.head.appendChild(linkTag);
/******/ 			                }
/******/ 			            })(linkTag)
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = (options) => {
/******/ 			return { dispose: () => {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: () => {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = (chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) => {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach((chunkId) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise((resolve, reject) => {
/******/ 					var tag = createStylesheet(chunkId, fullhref, () => {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"_app-pages-browser_node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-opfs-async--00ff5e": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = (_, moreModules, runtime) => {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScriptsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScripts = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScripts = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScriptsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-opfs-async-proxy.js");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;