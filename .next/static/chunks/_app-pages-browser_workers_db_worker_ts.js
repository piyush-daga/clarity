/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   sqlite3Worker1Promiser: () => (/* binding */ sqlite3Worker1Promiser)\n/* harmony export */ });\n/* harmony import */ var _sqlite_wasm_jswasm_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs */ \"(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs\");\n/* harmony import */ var _sqlite_wasm_jswasm_sqlite3_worker1_promiser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs */ \"(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs\");\n\n\n\nconst sqlite3Worker1Promiser = globalThis.sqlite3Worker1Promiser;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_sqlite_wasm_jswasm_sqlite3_bundler_friendly_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRztBQUN0Qzs7QUFFM0Q7O0FBRUEsaUVBQWUsd0ZBQWlCLEVBQUM7QUFDQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BpeXVzaC5kYWdhQHBvc3RtYW4uY29tL0RvY3VtZW50cy9Qcm9qZWN0cy9waXl1c2gtZGFnYS9ldmEtMi9zZXNzaW9uMS1idWlsZC10b2RvLWNhbGVuZGFyL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdCBhcyBzcWxpdGUzSW5pdE1vZHVsZSB9IGZyb20gJy4vc3FsaXRlLXdhc20vanN3YXNtL3NxbGl0ZTMtYnVuZGxlci1mcmllbmRseS5tanMnO1xuaW1wb3J0ICcuL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLXdvcmtlcjEtcHJvbWlzZXIubWpzJztcblxuY29uc3Qgc3FsaXRlM1dvcmtlcjFQcm9taXNlciA9IGdsb2JhbFRoaXMuc3FsaXRlM1dvcmtlcjFQcm9taXNlcjtcblxuZXhwb3J0IGRlZmF1bHQgc3FsaXRlM0luaXRNb2R1bGU7XG5leHBvcnQgeyBzcWxpdGUzV29ya2VyMVByb21pc2VyIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/*\n ** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.\n **\n ** This bundle (typically released as sqlite3.js or sqlite3.mjs)\n ** is an amalgamation of JavaScript source code from two projects:\n **\n ** 1) https://emscripten.org: the Emscripten \"glue code\" is covered by\n **    the terms of the MIT license and University of Illinois/NCSA\n **    Open Source License, as described at:\n **\n **    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html\n **\n ** 2) https://sqlite.org: all code and documentation labeled as being\n **    from this source are released under the same terms as the sqlite3\n **    C library:\n **\n ** 2022-10-16\n **\n ** The author disclaims copyright to this source code.  In place of a\n ** legal notice, here is a blessing:\n **\n ** *   May you do good and not evil.\n ** *   May you find forgiveness for yourself and forgive others.\n ** *   May you share freely, never taking more than you give.\n */\n/*\n ** This code was built from sqlite3 version...\n **\n ** SQLITE_VERSION \"3.50.4\"\n ** SQLITE_VERSION_NUMBER 3050004\n ** SQLITE_SOURCE_ID \"2025-07-30 19:33:53 4d8adfb30e03f9cf27f800a2c1ba3c48fb4ca1b08b0f5ed59a4d5ecbf45e20a3\"\n **\n ** Using the Emscripten SDK version 3.1.70.\n */\n\nvar sqlite3InitModule = (() => {\n  var _scriptName = \"file:///Users/piyush.daga@postman.com/Documents/Projects/piyush-daga/eva-2/session1-build-todo-calendar/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs\";\n\n  return function (moduleArg = {}) {\n    var moduleRtn;\n\n    var Module = moduleArg;\n\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n\n    var ENVIRONMENT_IS_WEB = typeof window == 'object';\n    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n\n    var ENVIRONMENT_IS_NODE =\n      typeof process == 'object' &&\n      typeof process.versions == 'object' &&\n      typeof process.versions.node == 'string' &&\n      process.type != 'renderer';\n    var ENVIRONMENT_IS_SHELL =\n      !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n    const sqlite3InitModuleState =\n      globalThis.sqlite3InitModuleState ||\n      Object.assign(Object.create(null), {\n        debugModule: () => {},\n      });\n    delete globalThis.sqlite3InitModuleState;\n    sqlite3InitModuleState.debugModule(\n      'globalThis.location =',\n      globalThis.location,\n    );\n\n    var moduleOverrides = Object.assign({}, Module);\n\n    var arguments_ = [];\n    var thisProgram = './this.program';\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n\n    var scriptDirectory = '';\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    var readAsync, readBinary;\n\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != 'undefined' && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n\n      if (_scriptName) {\n        scriptDirectory = _scriptName;\n      }\n\n      if (scriptDirectory.startsWith('blob:')) {\n        scriptDirectory = '';\n      } else {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,\n        );\n      }\n\n      {\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            xhr.responseType = 'arraybuffer';\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n\n        readAsync = (url) => {\n          return fetch(url, { credentials: 'same-origin' }).then((response) => {\n            if (response.ok) {\n              return response.arrayBuffer();\n            }\n            return Promise.reject(\n              new Error(response.status + ' : ' + response.url),\n            );\n          });\n        };\n      }\n    } else {\n    }\n\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.error.bind(console);\n\n    Object.assign(Module, moduleOverrides);\n\n    moduleOverrides = null;\n\n    if (Module['arguments']) arguments_ = Module['arguments'];\n\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\n    var wasmBinary = Module['wasmBinary'];\n\n    var wasmMemory;\n\n    var ABORT = false;\n\n    var EXITSTATUS;\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort(text);\n      }\n    }\n\n    var HEAP,\n      HEAP8,\n      HEAPU8,\n      HEAP16,\n      HEAPU16,\n      HEAP32,\n      HEAPU32,\n      HEAPF32,\n      HEAP64,\n      HEAPU64,\n      HEAPF64;\n\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module['HEAP8'] = HEAP8 = new Int8Array(b);\n      Module['HEAP16'] = HEAP16 = new Int16Array(b);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n      Module['HEAP32'] = HEAP32 = new Int32Array(b);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n      Module['HEAP64'] = HEAP64 = new BigInt64Array(b);\n      Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);\n    }\n\n    if (Module['wasmMemory']) {\n      wasmMemory = Module['wasmMemory'];\n    } else {\n      var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;\n\n      wasmMemory = new WebAssembly.Memory({\n        initial: INITIAL_MEMORY / 65536,\n\n        maximum: 32768,\n      });\n    }\n\n    updateMemoryViews();\n\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATEXIT__ = [];\n    var __ATPOSTRUN__ = [];\n\n    var runtimeInitialized = false;\n\n    function preRun() {\n      var preRuns = Module['preRun'];\n      if (preRuns) {\n        if (typeof preRuns == 'function') preRuns = [preRuns];\n        preRuns.forEach(addOnPreRun);\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      runtimeInitialized = true;\n\n      if (!Module['noFSInit'] && !FS.initialized) FS.init();\n      FS.ignorePermissions = false;\n\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function postRun() {\n      var postRuns = Module['postRun'];\n      if (postRuns) {\n        if (typeof postRuns == 'function') postRuns = [postRuns];\n        postRuns.forEach(addOnPostRun);\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      Module['monitorRunDependencies']?.(runDependencies);\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      Module['monitorRunDependencies']?.(runDependencies);\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    function abort(what) {\n      Module['onAbort']?.(what);\n\n      what = 'Aborted(' + what + ')';\n\n      err(what);\n\n      ABORT = true;\n\n      what += '. Build with -sASSERTIONS for more info.';\n\n      var e = new WebAssembly.RuntimeError(what);\n\n      readyPromiseReject(e);\n\n      throw e;\n    }\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n\n    var isFileURI = (filename) => filename.startsWith('file://');\n\n    function findWasmBinary() {\n      if (Module['locateFile']) {\n        var f = 'sqlite3.wasm';\n        if (!isDataURI(f)) {\n          return locateFile(f);\n        }\n        return f;\n      }\n\n      return /* asset import */ new __webpack_require__.U(__webpack_require__(/*! sqlite3.wasm */ \"(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm\")).href;\n    }\n\n    var wasmBinaryFile;\n\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'both async and sync fetching of the wasm failed';\n    }\n\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary) {\n        return readAsync(binaryFile).then(\n          (response) => new Uint8Array(response),\n\n          () => getBinarySync(binaryFile),\n        );\n      }\n\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then((binary) => {\n          return WebAssembly.instantiate(binary, imports);\n        })\n        .then(receiver, (reason) => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (\n        !binary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(binaryFile) &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(binaryFile, { credentials: 'same-origin' }).then(\n          (response) => {\n            var result = WebAssembly.instantiateStreaming(response, imports);\n\n            return result.then(callback, function (reason) {\n              err(`wasm streaming compile failed: ${reason}`);\n              err('falling back to ArrayBuffer instantiation');\n              return instantiateArrayBuffer(binaryFile, imports, callback);\n            });\n          },\n        );\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n\n    function getWasmImports() {\n      return {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports,\n      };\n    }\n\n    function createWasm() {\n      var info = getWasmImports();\n\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n\n        addOnInit(wasmExports['__wasm_call_ctors']);\n\n        removeRunDependency('wasm-instantiate');\n        return wasmExports;\n      }\n\n      addRunDependency('wasm-instantiate');\n\n      function receiveInstantiationResult(result) {\n        receiveInstance(result['instance']);\n      }\n\n      if (Module['instantiateWasm']) {\n        try {\n          return Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n\n          readyPromiseReject(e);\n        }\n      }\n\n      wasmBinaryFile ??= findWasmBinary();\n\n      instantiateAsync(\n        wasmBinary,\n        wasmBinaryFile,\n        info,\n        receiveInstantiationResult,\n      ).catch(readyPromiseReject);\n      return {};\n    }\n\n    function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n\n    var callRuntimeCallbacks = (callbacks) => {\n      callbacks.forEach((f) => f(Module));\n    };\n\n    function getValue(ptr, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr];\n        case 'i8':\n          return HEAP8[ptr];\n        case 'i16':\n          return HEAP16[ptr >> 1];\n        case 'i32':\n          return HEAP32[ptr >> 2];\n        case 'i64':\n          return HEAP64[ptr >> 3];\n        case 'float':\n          return HEAPF32[ptr >> 2];\n        case 'double':\n          return HEAPF64[ptr >> 3];\n        case '*':\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n\n    var noExitRuntime = Module['noExitRuntime'] || true;\n\n    function setValue(ptr, value, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr] = value;\n          break;\n        case 'i8':\n          HEAP8[ptr] = value;\n          break;\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n        case 'i64':\n          HEAP64[ptr >> 3] = BigInt(value);\n          break;\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case '*':\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n\n    var stackRestore = (val) => __emscripten_stack_restore(val);\n\n    var stackSave = () => _emscripten_stack_get_current();\n\n    var PATH = {\n      isAbs: (path) => path.charAt(0) === '/',\n      splitPath: (filename) => {\n        var splitPathRe =\n          /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: (parts, allowAboveRoot) => {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },\n      normalize: (path) => {\n        var isAbsolute = PATH.isAbs(path),\n          trailingSlash = path.substr(-1) === '/';\n\n        path = PATH.normalizeArray(\n          path.split('/').filter((p) => !!p),\n          !isAbsolute,\n        ).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: (path) => {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          return '.';\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: (path) => {\n        if (path === '/') return '/';\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, '');\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: (...paths) => PATH.normalize(paths.join('/')),\n      join2: (l, r) => PATH.normalize(l + '/' + r),\n    };\n\n    var initRandomFill = () => {\n      if (\n        typeof crypto == 'object' &&\n        typeof crypto['getRandomValues'] == 'function'\n      ) {\n        return (view) => crypto.getRandomValues(view);\n      } else abort('initRandomDevice');\n    };\n    var randomFill = (view) => {\n      return (randomFill = initRandomFill())(view);\n    };\n\n    var PATH_FS = {\n      resolve: (...args) => {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? args[i] : FS.cwd();\n\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return '';\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n\n        resolvedPath = PATH.normalizeArray(\n          resolvedPath.split('/').filter((p) => !!p),\n          !resolvedAbsolute,\n        ).join('/');\n        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n      },\n      relative: (from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      },\n    };\n\n    var UTF8Decoder =\n      typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xe0) == 0xc0) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xf0) == 0xe0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          u0 =\n            ((u0 & 7) << 18) |\n            (u1 << 12) |\n            (u2 << 6) |\n            (heapOrArray[idx++] & 63);\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(\n            0xd800 | (ch >> 10),\n            0xdc00 | (ch & 0x3ff),\n          );\n        }\n      }\n      return str;\n    };\n\n    var FS_stdin_getChar_buffer = [];\n\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 0x7f) {\n          len++;\n        } else if (c <= 0x7ff) {\n          len += 2;\n        } else if (c >= 0xd800 && c <= 0xdfff) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      if (!(maxBytesToWrite > 0)) return 0;\n\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 0xd800 && u <= 0xdfff) {\n          var u1 = str.charCodeAt(++i);\n          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);\n        }\n        if (u <= 0x7f) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7ff) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xc0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xffff) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xe0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 0xf0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(\n        stringy,\n        u8array,\n        0,\n        u8array.length,\n      );\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (\n          typeof window != 'undefined' &&\n          typeof window.prompt == 'function'\n        ) {\n          result = window.prompt('Input: ');\n          if (result !== null) {\n            result += '\\n';\n          }\n        } else {\n        }\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init() {},\n      shutdown() {},\n      register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        },\n      },\n      default_tty_ops: {\n        get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets(tty) {\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a,\n              0x00, 0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            ],\n          };\n        },\n        ioctl_tcsets(tty, optional_actions, data) {\n          return 0;\n        },\n        ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        },\n      },\n      default_tty1_ops: {\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n      },\n    };\n\n    var zeroMemory = (address, size) => {\n      HEAPU8.fill(0, address, address + size);\n    };\n\n    var alignMemory = (size, alignment) => {\n      return Math.ceil(size / alignment) * alignment;\n    };\n    var mmapAlloc = (size) => {\n      size = alignMemory(size, 65536);\n      var ptr = _emscripten_builtin_memalign(65536, size);\n      if (ptr) zeroMemory(ptr, size);\n      return ptr;\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount(mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511, 0);\n      },\n      createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table ||= {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink,\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n            },\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync,\n            },\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink,\n            },\n            stream: {},\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n            },\n            stream: FS.chrdev_stream_ops,\n          },\n        };\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray)\n          return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(\n          newCapacity,\n          (prevCapacity *\n            (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>>\n            0,\n        );\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0)\n          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(\n              oldContents.subarray(0, Math.min(newSize, node.usedBytes)),\n            );\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr(node) {\n          var attr = {};\n\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n        unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir(node) {\n          var entries = ['.', '..'];\n          for (var key of Object.keys(node.contents)) {\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        },\n      },\n      stream_ops: {\n        read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++)\n              buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write(stream, buffer, offset, length, position, canOwn) {\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(\n                buffer.subarray(offset, offset + length),\n                position,\n              );\n              return length;\n            }\n          }\n\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(\n              buffer.subarray(offset, offset + length),\n              position,\n            );\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(\n            stream.node.usedBytes,\n            offset + length,\n          );\n        },\n        mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(\n                    contents,\n                    position,\n                    position + length,\n                  );\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n        msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n\n          return 0;\n        },\n      },\n    };\n\n    var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\n      readAsync(url).then(\n        (arrayBuffer) => {\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        },\n        (err) => {\n          if (onerror) {\n            onerror();\n          } else {\n            throw `Loading data file \"${url}\" failed.`;\n          }\n        },\n      );\n      if (dep) addRunDependency(dep);\n    };\n\n    var FS_createDataFile = (\n      parent,\n      name,\n      fileData,\n      canRead,\n      canWrite,\n      canOwn,\n    ) => {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n\n    var preloadPlugins = Module['preloadPlugins'] || [];\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      if (typeof Browser != 'undefined') Browser.init();\n\n      var handled = false;\n      preloadPlugins.forEach((plugin) => {\n        if (handled) return;\n        if (plugin['canHandle'](fullname)) {\n          plugin['handle'](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = (\n      parent,\n      name,\n      url,\n      canRead,\n      canWrite,\n      onload,\n      onerror,\n      dontCreateFile,\n      canOwn,\n      preFinish,\n    ) => {\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`);\n      function processData(byteArray) {\n        function finish(byteArray) {\n          preFinish?.();\n          if (!dontCreateFile) {\n            FS_createDataFile(\n              parent,\n              name,\n              byteArray,\n              canRead,\n              canWrite,\n              canOwn,\n            );\n          }\n          onload?.();\n          removeRunDependency(dep);\n        }\n        if (\n          FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n            onerror?.();\n            removeRunDependency(dep);\n          })\n        ) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == 'string') {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n\n    var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        r: 0,\n        'r+': 2,\n        w: 512 | 64 | 1,\n        'w+': 512 | 64 | 2,\n        a: 1024 | 64 | 1,\n        'a+': 1024 | 64 | 2,\n      };\n      var flags = flagModes[str];\n      if (typeof flags == 'undefined') {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n\n    var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: '/',\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: class {\n        constructor(errno) {\n          this.name = 'ErrnoError';\n          this.errno = errno;\n        }\n      },\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      readFiles: {},\n      FSStream: class {\n        constructor() {\n          this.shared = {};\n        }\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return this.flags & 1024;\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n      FSNode: class {\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this;\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 | 73;\n          this.writeMode = 146;\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? (this.mode |= this.readMode) : (this.mode &= ~this.readMode);\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? (this.mode |= this.writeMode) : (this.mode &= ~this.writeMode);\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n      lookupPath(path, opts = {}) {\n        path = PATH_FS.resolve(path);\n\n        if (!path) return { path: '', node: null };\n\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0,\n        };\n        opts = Object.assign(defaults, opts);\n\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n\n        var parts = path.split('/').filter((p) => !!p);\n\n        var current = FS.root;\n        var current_path = '/';\n\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count + 1,\n              });\n              current = lookup.node;\n\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n\n        return { path: current_path, node: current };\n      },\n      getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== '/'\n              ? `${mount}/${path}`\n              : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n      hashName(parentid, name) {\n        var hash = 0;\n\n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n\n        return FS.lookup(parent, name);\n      },\n      createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n\n        FS.hashAddNode(node);\n\n        return node;\n      },\n      destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString(flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if (flag & 512) {\n          perms += 'w';\n        }\n        return perms;\n      },\n      nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, 'wx');\n      },\n      mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: (fd) => FS.streams[fd],\n      createStream(stream, fd = -1) {\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      dupStream(origStream, fd = -1) {\n        var stream = FS.createStream(origStream, fd);\n        stream.stream_ops?.dup?.(stream);\n        return stream;\n      },\n      chrdev_stream_ops: {\n        open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n\n          stream.stream_ops = device.stream_ops;\n\n          stream.stream_ops.open?.(stream);\n        },\n        llseek() {\n          throw new FS.ErrnoError(70);\n        },\n      },\n      major: (dev) => dev >> 8,\n      minor: (dev) => dev & 0xff,\n      makedev: (ma, mi) => (ma << 8) | mi,\n      registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n      getDevice: (dev) => FS.devices[dev],\n      getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n\n        while (check.length) {\n          var m = check.pop();\n\n          mounts.push(m);\n\n          check.push(...m.mounts);\n        }\n\n        return mounts;\n      },\n      syncfs(populate, callback) {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n\n        FS.syncFSRequests++;\n\n        if (FS.syncFSRequests > 1) {\n          err(\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`,\n          );\n        }\n\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount(type, opts, mountpoint) {\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n          mountpoint = lookup.path;\n          node = lookup.node;\n\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n\n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: [],\n        };\n\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n\n        return mountRoot;\n      },\n      unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n\n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            var next = current.name_next;\n\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n\n            current = next;\n          }\n        });\n\n        node.mounted = null;\n\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create(path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree(path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev(path, mode, dev) {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n\n        var lookup, old_dir, new_dir;\n\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n\n        var old_node = FS.lookupNode(old_dir, old_name);\n\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n\n        if (old_node === new_node) {\n          return;\n        }\n\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        errCode = new_node\n          ? FS.mayDelete(new_dir, new_name, isdir)\n          : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (\n          FS.isMountpoint(old_node) ||\n          (new_node && FS.isMountpoint(new_node))\n        ) {\n          throw new FS.ErrnoError(10);\n        }\n\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n\n        FS.hashRemoveNode(old_node);\n\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(\n          FS.getPath(link.parent),\n          link.node_ops.readlink(link),\n        );\n      },\n      stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now(),\n        });\n      },\n      lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now(),\n        });\n      },\n      lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now(),\n        });\n      },\n      ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime),\n        });\n      },\n      open(path, flags, mode) {\n        if (path === '') {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n        if (flags & 64) {\n          mode = typeof mode == 'undefined' ? 438 : mode;\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072),\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n\n        flags &= ~(128 | 512 | 131072);\n\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n\n          ungotten: [],\n          error: false,\n        });\n\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n        );\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n          canOwn,\n        );\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap(stream, length, position, prot, flags) {\n        if (\n          (prot & 2) !== 0 &&\n          (flags & 2) === 0 &&\n          (stream.flags & 2097155) !== 2\n        ) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(\n          stream,\n          buffer,\n          offset,\n          length,\n          mmapFlags,\n        );\n      },\n      ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },\n      cwd: () => FS.currentPath,\n      chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories() {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },\n      createDefaultDevices() {\n        FS.mkdir('/dev');\n\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length,\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n\n        var randomBuffer = new Uint8Array(1024),\n          randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice('/dev', 'random', randomByte);\n        FS.createDevice('/dev', 'urandom', randomByte);\n\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },\n      createSpecialDirectories() {\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount(\n          {\n            mount() {\n              var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73);\n              node.node_ops = {\n                lookup(parent, name) {\n                  var fd = +name;\n                  var stream = FS.getStreamChecked(fd);\n                  var ret = {\n                    parent: null,\n                    mount: { mountpoint: 'fake' },\n                    node_ops: { readlink: () => stream.path },\n                  };\n                  ret.parent = ret;\n                  return ret;\n                },\n              };\n              return node;\n            },\n          },\n          {},\n          '/proc/self/fd',\n        );\n      },\n      createStandardStreams(input, output, error) {\n        if (input) {\n          FS.createDevice('/dev', 'stdin', input);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (output) {\n          FS.createDevice('/dev', 'stdout', null, output);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (error) {\n          FS.createDevice('/dev', 'stderr', null, error);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n      },\n      staticInit() {\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n\n        FS.nameTable = new Array(4096);\n\n        FS.mount(MEMFS, {}, '/');\n\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n\n        FS.filesystems = {\n          MEMFS: MEMFS,\n        };\n      },\n      init(input, output, error) {\n        FS.initialized = true;\n\n        input ??= Module['stdin'];\n        output ??= Module['stdout'];\n        error ??= Module['stderr'];\n\n        FS.createStandardStreams(input, output, error);\n      },\n      quit() {\n        FS.initialized = false;\n\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null,\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n          parent = current;\n        }\n        return current;\n      },\n      createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(\n          typeof parent == 'string' ? parent : FS.getPath(parent),\n          name,\n        );\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i)\n              arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n      createDevice(parent, name, input, output) {\n        var path = PATH.join2(\n          typeof parent == 'string' ? parent : FS.getPath(parent),\n          name,\n        );\n        var mode = FS_getMode(!!input, !!output);\n        FS.createDevice.major ??= 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            if (output?.buffer?.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          },\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\n          return true;\n        if (typeof XMLHttpRequest != 'undefined') {\n          throw new Error(\n            'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.',\n          );\n        } else {\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n      createLazyFile(parent, name, url, canRead, canWrite) {\n        class LazyUint8Array {\n          constructor() {\n            this.lengthKnown = false;\n            this.chunks = [];\n          }\n          get(idx) {\n            if (idx > this.length - 1 || idx < 0) {\n              return undefined;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = (idx / this.chunkSize) | 0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            var xhr = new XMLHttpRequest();\n            xhr.open('HEAD', url, false);\n            xhr.send(null);\n            if (\n              !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\n            )\n              throw new Error(\n                \"Couldn't load \" + url + '. Status: ' + xhr.status,\n              );\n            var datalength = Number(xhr.getResponseHeader('Content-length'));\n            var header;\n            var hasByteServing =\n              (header = xhr.getResponseHeader('Accept-Ranges')) &&\n              header === 'bytes';\n            var usesGzip =\n              (header = xhr.getResponseHeader('Content-Encoding')) &&\n              header === 'gzip';\n\n            var chunkSize = 1024 * 1024;\n\n            if (!hasByteServing) chunkSize = datalength;\n\n            var doXHR = (from, to) => {\n              if (from > to)\n                throw new Error(\n                  'invalid range (' +\n                    from +\n                    ', ' +\n                    to +\n                    ') or no bytes requested!',\n                );\n              if (to > datalength - 1)\n                throw new Error(\n                  'only ' + datalength + ' bytes available! programmer error!',\n                );\n\n              var xhr = new XMLHttpRequest();\n              xhr.open('GET', url, false);\n              if (datalength !== chunkSize)\n                xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);\n\n              xhr.responseType = 'arraybuffer';\n              if (xhr.overrideMimeType) {\n                xhr.overrideMimeType('text/plain; charset=x-user-defined');\n              }\n\n              xhr.send(null);\n              if (\n                !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)\n              )\n                throw new Error(\n                  \"Couldn't load \" + url + '. Status: ' + xhr.status,\n                );\n              if (xhr.response !== undefined) {\n                return new Uint8Array(xhr.response || []);\n              }\n              return intArrayFromString(xhr.responseText || '', true);\n            };\n            var lazyArray = this;\n            lazyArray.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum + 1) * chunkSize - 1;\n              end = Math.min(end, datalength - 1);\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined')\n                throw new Error('doXHR failed!');\n              return lazyArray.chunks[chunkNum];\n            });\n\n            if (usesGzip || !datalength) {\n              chunkSize = datalength = 1;\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out(\n                'LazyFiles on gzip forces download of the whole file when length is accessed',\n              );\n            }\n\n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n\n        if (typeof XMLHttpRequest != 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER)\n            throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function () {\n              return this.contents.length;\n            },\n          },\n        });\n\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n    };\n\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[(buf + 4) >> 2] = stat.mode;\n        HEAPU32[(buf + 8) >> 2] = stat.nlink;\n        HEAP32[(buf + 12) >> 2] = stat.uid;\n        HEAP32[(buf + 16) >> 2] = stat.gid;\n        HEAP32[(buf + 20) >> 2] = stat.rdev;\n        HEAP64[(buf + 24) >> 3] = BigInt(stat.size);\n        HEAP32[(buf + 32) >> 2] = 4096;\n        HEAP32[(buf + 36) >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        HEAP64[(buf + 40) >> 3] = BigInt(Math.floor(atime / 1000));\n        HEAPU32[(buf + 48) >> 2] = (atime % 1000) * 1000 * 1000;\n        HEAP64[(buf + 56) >> 3] = BigInt(Math.floor(mtime / 1000));\n        HEAPU32[(buf + 64) >> 2] = (mtime % 1000) * 1000 * 1000;\n        HEAP64[(buf + 72) >> 3] = BigInt(Math.floor(ctime / 1000));\n        HEAPU32[(buf + 80) >> 2] = (ctime % 1000) * 1000 * 1000;\n        HEAP64[(buf + 88) >> 3] = BigInt(stat.ino);\n        return 0;\n      },\n      doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n      varargs: undefined,\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n    };\n    function ___syscall_chmod(path, mode) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.chmod(path, mode);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_faccessat(dirfd, path, amode, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (amode & ~7) {\n          return -28;\n        }\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node) {\n          return -44;\n        }\n        var perms = '';\n        if (amode & 4) perms += 'r';\n        if (amode & 2) perms += 'w';\n        if (amode & 1) perms += 'x';\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -2;\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fchmod(fd, mode) {\n      try {\n        FS.fchmod(fd, mode);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fchown32(fd, owner, group) {\n      try {\n        FS.fchown(fd, owner, group);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function syscallGetVarargI() {\n      var ret = HEAP32[+SYSCALLS.varargs >> 2];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n    var syscallGetVarargP = syscallGetVarargI;\n\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0: {\n            var arg = syscallGetVarargI();\n            if (arg < 0) {\n              return -28;\n            }\n            while (FS.streams[arg]) {\n              arg++;\n            }\n            var newStream;\n            newStream = FS.dupStream(stream, arg);\n            return newStream.fd;\n          }\n          case 1:\n          case 2:\n            return 0;\n          case 3:\n            return stream.flags;\n          case 4: {\n            var arg = syscallGetVarargI();\n            stream.flags |= arg;\n            return 0;\n          }\n          case 12: {\n            var arg = syscallGetVarargP();\n            var offset = 0;\n\n            HEAP16[(arg + offset) >> 1] = 2;\n            return 0;\n          }\n          case 13:\n          case 14:\n            return 0;\n        }\n        return -28;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_fstat64(fd, buf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return SYSCALLS.doStat(FS.stat, stream.path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var INT53_MAX = 9007199254740992;\n\n    var INT53_MIN = -9007199254740992;\n    var bigintToI53Checked = (num) =>\n      num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);\n    function ___syscall_ftruncate64(fd, length) {\n      length = bigintToI53Checked(length);\n\n      try {\n        if (isNaN(length)) return 61;\n        FS.ftruncate(fd, length);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    function ___syscall_getcwd(buf, size) {\n      try {\n        if (size === 0) return -28;\n        var cwd = FS.cwd();\n        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;\n        if (size < cwdLengthInBytes) return -68;\n        stringToUTF8(cwd, buf, size);\n        return cwdLengthInBytes;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21505: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcgets) {\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\n              var argp = syscallGetVarargP();\n              HEAP32[argp >> 2] = termios.c_iflag || 0;\n              HEAP32[(argp + 4) >> 2] = termios.c_oflag || 0;\n              HEAP32[(argp + 8) >> 2] = termios.c_cflag || 0;\n              HEAP32[(argp + 12) >> 2] = termios.c_lflag || 0;\n              for (var i = 0; i < 32; i++) {\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n              }\n              return 0;\n            }\n            return 0;\n          }\n          case 21510:\n          case 21511:\n          case 21512: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21506:\n          case 21507:\n          case 21508: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcsets) {\n              var argp = syscallGetVarargP();\n              var c_iflag = HEAP32[argp >> 2];\n              var c_oflag = HEAP32[(argp + 4) >> 2];\n              var c_cflag = HEAP32[(argp + 8) >> 2];\n              var c_lflag = HEAP32[(argp + 12) >> 2];\n              var c_cc = [];\n              for (var i = 0; i < 32; i++) {\n                c_cc.push(HEAP8[argp + i + 17]);\n              }\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                c_iflag,\n                c_oflag,\n                c_cflag,\n                c_lflag,\n                c_cc,\n              });\n            }\n            return 0;\n          }\n          case 21519: {\n            if (!stream.tty) return -59;\n            var argp = syscallGetVarargP();\n            HEAP32[argp >> 2] = 0;\n            return 0;\n          }\n          case 21520: {\n            if (!stream.tty) return -59;\n            return -28;\n          }\n          case 21531: {\n            var argp = syscallGetVarargP();\n            return FS.ioctl(stream, op, argp);\n          }\n          case 21523: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n              var argp = syscallGetVarargP();\n              HEAP16[argp >> 1] = winsize[0];\n              HEAP16[(argp + 2) >> 1] = winsize[1];\n            }\n            return 0;\n          }\n          case 21524: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21515: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          default:\n            return -28;\n        }\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_lstat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.lstat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_mkdirat(dirfd, path, mode) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === '/')\n          path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_newfstatat(dirfd, path, buf, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        var nofollow = flags & 256;\n        var allowEmpty = flags & 4096;\n        flags = flags & ~6400;\n        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        var mode = varargs ? syscallGetVarargI() : 0;\n        return FS.open(path, flags, mode).fd;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_readlinkat(dirfd, path, buf, bufsize) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (bufsize <= 0) return -28;\n        var ret = FS.readlink(path);\n\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n\n        HEAP8[buf + len] = endChar;\n        return len;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_rmdir(path) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.rmdir(path);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_stat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function ___syscall_unlinkat(dirfd, path, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (flags === 0) {\n          FS.unlink(path);\n        } else if (flags === 512) {\n          FS.rmdir(path);\n        } else {\n          abort('Invalid flags passed to unlinkat');\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var readI53FromI64 = (ptr) => {\n      return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;\n    };\n\n    function ___syscall_utimensat(dirfd, path, times, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path, true);\n        var now = Date.now(),\n          atime,\n          mtime;\n        if (!times) {\n          atime = now;\n          mtime = now;\n        } else {\n          var seconds = readI53FromI64(times);\n          var nanoseconds = HEAP32[(times + 8) >> 2];\n          if (nanoseconds == 1073741823) {\n            atime = now;\n          } else if (nanoseconds == 1073741822) {\n            atime = -1;\n          } else {\n            atime = seconds * 1000 + nanoseconds / (1000 * 1000);\n          }\n          times += 16;\n          seconds = readI53FromI64(times);\n          nanoseconds = HEAP32[(times + 8) >> 2];\n          if (nanoseconds == 1073741823) {\n            mtime = now;\n          } else if (nanoseconds == 1073741822) {\n            mtime = -1;\n          } else {\n            mtime = seconds * 1000 + nanoseconds / (1000 * 1000);\n          }\n        }\n\n        if (mtime != -1 || atime != -1) {\n          FS.utime(path, atime, mtime);\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var nowIsMonotonic = 1;\n    var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;\n\n    var isLeapYear = (year) =>\n      year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n\n    var MONTH_DAYS_LEAP_CUMULATIVE = [\n      0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335,\n    ];\n\n    var MONTH_DAYS_REGULAR_CUMULATIVE = [\n      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,\n    ];\n    var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = leap\n        ? MONTH_DAYS_LEAP_CUMULATIVE\n        : MONTH_DAYS_REGULAR_CUMULATIVE;\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;\n\n      return yday;\n    };\n\n    function __localtime_js(time, tmPtr) {\n      time = bigintToI53Checked(time);\n\n      var date = new Date(time * 1000);\n      HEAP32[tmPtr >> 2] = date.getSeconds();\n      HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\n      HEAP32[(tmPtr + 8) >> 2] = date.getHours();\n      HEAP32[(tmPtr + 12) >> 2] = date.getDate();\n      HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\n      HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\n      HEAP32[(tmPtr + 24) >> 2] = date.getDay();\n\n      var yday = ydayFromDate(date) | 0;\n      HEAP32[(tmPtr + 28) >> 2] = yday;\n      HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\n\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst =\n        (summerOffset != winterOffset &&\n          date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n      HEAP32[(tmPtr + 32) >> 2] = dst;\n    }\n\n    function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {\n      offset = bigintToI53Checked(offset);\n\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var res = FS.mmap(stream, len, offset, prot, flags);\n        var ptr = res.ptr;\n        HEAP32[allocated >> 2] = res.allocated;\n        HEAPU32[addr >> 2] = ptr;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    function __munmap_js(addr, len, prot, flags, fd, offset) {\n      offset = bigintToI53Checked(offset);\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if (prot & 2) {\n          SYSCALLS.doMsync(addr, stream, len, flags, offset);\n        }\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n\n    var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n\n      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n\n      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n\n      var extractZone = (timezoneOffset) => {\n        var sign = timezoneOffset >= 0 ? '-' : '+';\n\n        var absOffset = Math.abs(timezoneOffset);\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, '0');\n        var minutes = String(absOffset % 60).padStart(2, '0');\n\n        return `UTC${sign}${hours}${minutes}`;\n      };\n\n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      if (summerOffset < winterOffset) {\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n\n    var _emscripten_date_now = () => Date.now();\n\n    var _emscripten_get_now = () => performance.now();\n\n    var getHeapMax = () => 2147483648;\n\n    var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = ((size - b.byteLength + 65535) / 65536) | 0;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {}\n    };\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n\n      requestedSize >>>= 0;\n\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n\n        overGrownHeapSize = Math.min(\n          overGrownHeapSize,\n          requestedSize + 100663296,\n        );\n\n        var newSize = Math.min(\n          maxHeapSize,\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536),\n        );\n\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    var ENV = {};\n\n    var getExecutableName = () => {\n      return thisProgram || './this.program';\n    };\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang =\n          (\n            (typeof navigator == 'object' &&\n              navigator.languages &&\n              navigator.languages[0]) ||\n            'C'\n          ).replace('-', '_') + '.UTF-8';\n        var env = {\n          USER: 'web_user',\n          LOGNAME: 'web_user',\n          PATH: '/',\n          PWD: '/',\n          HOME: '/home/web_user',\n          LANG: lang,\n          _: getExecutableName(),\n        };\n\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[(__environ + i * 4) >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach((string) => (bufSize += string.length + 1));\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_fdstat_get(fd, pbuf) {\n      try {\n        var rightsBase = 0;\n        var rightsInheriting = 0;\n        var flags = 0;\n        {\n          var stream = SYSCALLS.getStreamFromFD(fd);\n\n          var type = stream.tty\n            ? 2\n            : FS.isDir(stream.mode)\n              ? 3\n              : FS.isLink(stream.mode)\n                ? 7\n                : 4;\n        }\n        HEAP8[pbuf] = type;\n        HEAP16[(pbuf + 2) >> 1] = flags;\n        HEAP64[(pbuf + 8) >> 3] = BigInt(rightsBase);\n        HEAP64[(pbuf + 16) >> 3] = BigInt(rightsInheriting);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break;\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_seek(fd, offset, whence, newOffset) {\n      offset = bigintToI53Checked(offset);\n\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        HEAP64[newOffset >> 3] = BigInt(stream.position);\n        if (stream.getdents && offset === 0 && whence === 0)\n          stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    function _fd_sync(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if (stream.stream_ops?.fsync) {\n          return stream.stream_ops.fsync(stream);\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          break;\n        }\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n\n    var wasmImports = {\n      __syscall_chmod: ___syscall_chmod,\n\n      __syscall_faccessat: ___syscall_faccessat,\n\n      __syscall_fchmod: ___syscall_fchmod,\n\n      __syscall_fchown32: ___syscall_fchown32,\n\n      __syscall_fcntl64: ___syscall_fcntl64,\n\n      __syscall_fstat64: ___syscall_fstat64,\n\n      __syscall_ftruncate64: ___syscall_ftruncate64,\n\n      __syscall_getcwd: ___syscall_getcwd,\n\n      __syscall_ioctl: ___syscall_ioctl,\n\n      __syscall_lstat64: ___syscall_lstat64,\n\n      __syscall_mkdirat: ___syscall_mkdirat,\n\n      __syscall_newfstatat: ___syscall_newfstatat,\n\n      __syscall_openat: ___syscall_openat,\n\n      __syscall_readlinkat: ___syscall_readlinkat,\n\n      __syscall_rmdir: ___syscall_rmdir,\n\n      __syscall_stat64: ___syscall_stat64,\n\n      __syscall_unlinkat: ___syscall_unlinkat,\n\n      __syscall_utimensat: ___syscall_utimensat,\n\n      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n\n      _localtime_js: __localtime_js,\n\n      _mmap_js: __mmap_js,\n\n      _munmap_js: __munmap_js,\n\n      _tzset_js: __tzset_js,\n\n      emscripten_date_now: _emscripten_date_now,\n\n      emscripten_get_now: _emscripten_get_now,\n\n      emscripten_resize_heap: _emscripten_resize_heap,\n\n      environ_get: _environ_get,\n\n      environ_sizes_get: _environ_sizes_get,\n\n      fd_close: _fd_close,\n\n      fd_fdstat_get: _fd_fdstat_get,\n\n      fd_read: _fd_read,\n\n      fd_seek: _fd_seek,\n\n      fd_sync: _fd_sync,\n\n      fd_write: _fd_write,\n\n      memory: wasmMemory,\n    };\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = () =>\n      (___wasm_call_ctors = wasmExports['__wasm_call_ctors'])();\n    var _sqlite3_status64 = (Module['_sqlite3_status64'] = (a0, a1, a2, a3) =>\n      (_sqlite3_status64 = Module['_sqlite3_status64'] =\n        wasmExports['sqlite3_status64'])(a0, a1, a2, a3));\n    var _sqlite3_status = (Module['_sqlite3_status'] = (a0, a1, a2, a3) =>\n      (_sqlite3_status = Module['_sqlite3_status'] =\n        wasmExports['sqlite3_status'])(a0, a1, a2, a3));\n    var _sqlite3_db_status = (Module['_sqlite3_db_status'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_db_status = Module['_sqlite3_db_status'] =\n        wasmExports['sqlite3_db_status'])(a0, a1, a2, a3, a4));\n    var _sqlite3_msize = (Module['_sqlite3_msize'] = (a0) =>\n      (_sqlite3_msize = Module['_sqlite3_msize'] =\n        wasmExports['sqlite3_msize'])(a0));\n    var _sqlite3_vfs_find = (Module['_sqlite3_vfs_find'] = (a0) =>\n      (_sqlite3_vfs_find = Module['_sqlite3_vfs_find'] =\n        wasmExports['sqlite3_vfs_find'])(a0));\n    var _sqlite3_initialize = (Module['_sqlite3_initialize'] = () =>\n      (_sqlite3_initialize = Module['_sqlite3_initialize'] =\n        wasmExports['sqlite3_initialize'])());\n    var _sqlite3_malloc = (Module['_sqlite3_malloc'] = (a0) =>\n      (_sqlite3_malloc = Module['_sqlite3_malloc'] =\n        wasmExports['sqlite3_malloc'])(a0));\n    var _sqlite3_free = (Module['_sqlite3_free'] = (a0) =>\n      (_sqlite3_free = Module['_sqlite3_free'] = wasmExports['sqlite3_free'])(\n        a0,\n      ));\n    var _sqlite3_vfs_register = (Module['_sqlite3_vfs_register'] = (a0, a1) =>\n      (_sqlite3_vfs_register = Module['_sqlite3_vfs_register'] =\n        wasmExports['sqlite3_vfs_register'])(a0, a1));\n    var _sqlite3_vfs_unregister = (Module['_sqlite3_vfs_unregister'] = (a0) =>\n      (_sqlite3_vfs_unregister = Module['_sqlite3_vfs_unregister'] =\n        wasmExports['sqlite3_vfs_unregister'])(a0));\n    var _sqlite3_malloc64 = (Module['_sqlite3_malloc64'] = (a0) =>\n      (_sqlite3_malloc64 = Module['_sqlite3_malloc64'] =\n        wasmExports['sqlite3_malloc64'])(a0));\n    var _sqlite3_realloc = (Module['_sqlite3_realloc'] = (a0, a1) =>\n      (_sqlite3_realloc = Module['_sqlite3_realloc'] =\n        wasmExports['sqlite3_realloc'])(a0, a1));\n    var _sqlite3_realloc64 = (Module['_sqlite3_realloc64'] = (a0, a1) =>\n      (_sqlite3_realloc64 = Module['_sqlite3_realloc64'] =\n        wasmExports['sqlite3_realloc64'])(a0, a1));\n    var _sqlite3_value_text = (Module['_sqlite3_value_text'] = (a0) =>\n      (_sqlite3_value_text = Module['_sqlite3_value_text'] =\n        wasmExports['sqlite3_value_text'])(a0));\n    var _sqlite3_randomness = (Module['_sqlite3_randomness'] = (a0, a1) =>\n      (_sqlite3_randomness = Module['_sqlite3_randomness'] =\n        wasmExports['sqlite3_randomness'])(a0, a1));\n    var _sqlite3_stricmp = (Module['_sqlite3_stricmp'] = (a0, a1) =>\n      (_sqlite3_stricmp = Module['_sqlite3_stricmp'] =\n        wasmExports['sqlite3_stricmp'])(a0, a1));\n    var _sqlite3_strnicmp = (Module['_sqlite3_strnicmp'] = (a0, a1, a2) =>\n      (_sqlite3_strnicmp = Module['_sqlite3_strnicmp'] =\n        wasmExports['sqlite3_strnicmp'])(a0, a1, a2));\n    var _sqlite3_uri_parameter = (Module['_sqlite3_uri_parameter'] = (a0, a1) =>\n      (_sqlite3_uri_parameter = Module['_sqlite3_uri_parameter'] =\n        wasmExports['sqlite3_uri_parameter'])(a0, a1));\n    var _sqlite3_uri_boolean = (Module['_sqlite3_uri_boolean'] = (a0, a1, a2) =>\n      (_sqlite3_uri_boolean = Module['_sqlite3_uri_boolean'] =\n        wasmExports['sqlite3_uri_boolean'])(a0, a1, a2));\n    var _sqlite3_serialize = (Module['_sqlite3_serialize'] = (a0, a1, a2, a3) =>\n      (_sqlite3_serialize = Module['_sqlite3_serialize'] =\n        wasmExports['sqlite3_serialize'])(a0, a1, a2, a3));\n    var _sqlite3_prepare_v2 = (Module['_sqlite3_prepare_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_prepare_v2 = Module['_sqlite3_prepare_v2'] =\n        wasmExports['sqlite3_prepare_v2'])(a0, a1, a2, a3, a4));\n    var _sqlite3_step = (Module['_sqlite3_step'] = (a0) =>\n      (_sqlite3_step = Module['_sqlite3_step'] = wasmExports['sqlite3_step'])(\n        a0,\n      ));\n    var _sqlite3_column_int64 = (Module['_sqlite3_column_int64'] = (a0, a1) =>\n      (_sqlite3_column_int64 = Module['_sqlite3_column_int64'] =\n        wasmExports['sqlite3_column_int64'])(a0, a1));\n    var _sqlite3_reset = (Module['_sqlite3_reset'] = (a0) =>\n      (_sqlite3_reset = Module['_sqlite3_reset'] =\n        wasmExports['sqlite3_reset'])(a0));\n    var _sqlite3_exec = (Module['_sqlite3_exec'] = (a0, a1, a2, a3, a4) =>\n      (_sqlite3_exec = Module['_sqlite3_exec'] = wasmExports['sqlite3_exec'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n      ));\n    var _sqlite3_column_int = (Module['_sqlite3_column_int'] = (a0, a1) =>\n      (_sqlite3_column_int = Module['_sqlite3_column_int'] =\n        wasmExports['sqlite3_column_int'])(a0, a1));\n    var _sqlite3_finalize = (Module['_sqlite3_finalize'] = (a0) =>\n      (_sqlite3_finalize = Module['_sqlite3_finalize'] =\n        wasmExports['sqlite3_finalize'])(a0));\n    var _sqlite3_file_control = (Module['_sqlite3_file_control'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_file_control = Module['_sqlite3_file_control'] =\n        wasmExports['sqlite3_file_control'])(a0, a1, a2, a3));\n    var _sqlite3_column_name = (Module['_sqlite3_column_name'] = (a0, a1) =>\n      (_sqlite3_column_name = Module['_sqlite3_column_name'] =\n        wasmExports['sqlite3_column_name'])(a0, a1));\n    var _sqlite3_column_text = (Module['_sqlite3_column_text'] = (a0, a1) =>\n      (_sqlite3_column_text = Module['_sqlite3_column_text'] =\n        wasmExports['sqlite3_column_text'])(a0, a1));\n    var _sqlite3_column_type = (Module['_sqlite3_column_type'] = (a0, a1) =>\n      (_sqlite3_column_type = Module['_sqlite3_column_type'] =\n        wasmExports['sqlite3_column_type'])(a0, a1));\n    var _sqlite3_errmsg = (Module['_sqlite3_errmsg'] = (a0) =>\n      (_sqlite3_errmsg = Module['_sqlite3_errmsg'] =\n        wasmExports['sqlite3_errmsg'])(a0));\n    var _sqlite3_deserialize = (Module['_sqlite3_deserialize'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3_deserialize = Module['_sqlite3_deserialize'] =\n        wasmExports['sqlite3_deserialize'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3_clear_bindings = (Module['_sqlite3_clear_bindings'] = (a0) =>\n      (_sqlite3_clear_bindings = Module['_sqlite3_clear_bindings'] =\n        wasmExports['sqlite3_clear_bindings'])(a0));\n    var _sqlite3_value_blob = (Module['_sqlite3_value_blob'] = (a0) =>\n      (_sqlite3_value_blob = Module['_sqlite3_value_blob'] =\n        wasmExports['sqlite3_value_blob'])(a0));\n    var _sqlite3_value_bytes = (Module['_sqlite3_value_bytes'] = (a0) =>\n      (_sqlite3_value_bytes = Module['_sqlite3_value_bytes'] =\n        wasmExports['sqlite3_value_bytes'])(a0));\n    var _sqlite3_value_double = (Module['_sqlite3_value_double'] = (a0) =>\n      (_sqlite3_value_double = Module['_sqlite3_value_double'] =\n        wasmExports['sqlite3_value_double'])(a0));\n    var _sqlite3_value_int = (Module['_sqlite3_value_int'] = (a0) =>\n      (_sqlite3_value_int = Module['_sqlite3_value_int'] =\n        wasmExports['sqlite3_value_int'])(a0));\n    var _sqlite3_value_int64 = (Module['_sqlite3_value_int64'] = (a0) =>\n      (_sqlite3_value_int64 = Module['_sqlite3_value_int64'] =\n        wasmExports['sqlite3_value_int64'])(a0));\n    var _sqlite3_value_subtype = (Module['_sqlite3_value_subtype'] = (a0) =>\n      (_sqlite3_value_subtype = Module['_sqlite3_value_subtype'] =\n        wasmExports['sqlite3_value_subtype'])(a0));\n    var _sqlite3_value_pointer = (Module['_sqlite3_value_pointer'] = (a0, a1) =>\n      (_sqlite3_value_pointer = Module['_sqlite3_value_pointer'] =\n        wasmExports['sqlite3_value_pointer'])(a0, a1));\n    var _sqlite3_value_type = (Module['_sqlite3_value_type'] = (a0) =>\n      (_sqlite3_value_type = Module['_sqlite3_value_type'] =\n        wasmExports['sqlite3_value_type'])(a0));\n    var _sqlite3_value_nochange = (Module['_sqlite3_value_nochange'] = (a0) =>\n      (_sqlite3_value_nochange = Module['_sqlite3_value_nochange'] =\n        wasmExports['sqlite3_value_nochange'])(a0));\n    var _sqlite3_value_frombind = (Module['_sqlite3_value_frombind'] = (a0) =>\n      (_sqlite3_value_frombind = Module['_sqlite3_value_frombind'] =\n        wasmExports['sqlite3_value_frombind'])(a0));\n    var _sqlite3_value_dup = (Module['_sqlite3_value_dup'] = (a0) =>\n      (_sqlite3_value_dup = Module['_sqlite3_value_dup'] =\n        wasmExports['sqlite3_value_dup'])(a0));\n    var _sqlite3_value_free = (Module['_sqlite3_value_free'] = (a0) =>\n      (_sqlite3_value_free = Module['_sqlite3_value_free'] =\n        wasmExports['sqlite3_value_free'])(a0));\n    var _sqlite3_result_blob = (Module['_sqlite3_result_blob'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_result_blob = Module['_sqlite3_result_blob'] =\n        wasmExports['sqlite3_result_blob'])(a0, a1, a2, a3));\n    var _sqlite3_result_error_toobig = (Module['_sqlite3_result_error_toobig'] =\n      (a0) =>\n        (_sqlite3_result_error_toobig = Module['_sqlite3_result_error_toobig'] =\n          wasmExports['sqlite3_result_error_toobig'])(a0));\n    var _sqlite3_result_error_nomem = (Module['_sqlite3_result_error_nomem'] = (\n      a0,\n    ) =>\n      (_sqlite3_result_error_nomem = Module['_sqlite3_result_error_nomem'] =\n        wasmExports['sqlite3_result_error_nomem'])(a0));\n    var _sqlite3_result_double = (Module['_sqlite3_result_double'] = (a0, a1) =>\n      (_sqlite3_result_double = Module['_sqlite3_result_double'] =\n        wasmExports['sqlite3_result_double'])(a0, a1));\n    var _sqlite3_result_error = (Module['_sqlite3_result_error'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_result_error = Module['_sqlite3_result_error'] =\n        wasmExports['sqlite3_result_error'])(a0, a1, a2));\n    var _sqlite3_result_int = (Module['_sqlite3_result_int'] = (a0, a1) =>\n      (_sqlite3_result_int = Module['_sqlite3_result_int'] =\n        wasmExports['sqlite3_result_int'])(a0, a1));\n    var _sqlite3_result_int64 = (Module['_sqlite3_result_int64'] = (a0, a1) =>\n      (_sqlite3_result_int64 = Module['_sqlite3_result_int64'] =\n        wasmExports['sqlite3_result_int64'])(a0, a1));\n    var _sqlite3_result_null = (Module['_sqlite3_result_null'] = (a0) =>\n      (_sqlite3_result_null = Module['_sqlite3_result_null'] =\n        wasmExports['sqlite3_result_null'])(a0));\n    var _sqlite3_result_pointer = (Module['_sqlite3_result_pointer'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_result_pointer = Module['_sqlite3_result_pointer'] =\n        wasmExports['sqlite3_result_pointer'])(a0, a1, a2, a3));\n    var _sqlite3_result_subtype = (Module['_sqlite3_result_subtype'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_subtype = Module['_sqlite3_result_subtype'] =\n        wasmExports['sqlite3_result_subtype'])(a0, a1));\n    var _sqlite3_result_text = (Module['_sqlite3_result_text'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_result_text = Module['_sqlite3_result_text'] =\n        wasmExports['sqlite3_result_text'])(a0, a1, a2, a3));\n    var _sqlite3_result_zeroblob = (Module['_sqlite3_result_zeroblob'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_zeroblob = Module['_sqlite3_result_zeroblob'] =\n        wasmExports['sqlite3_result_zeroblob'])(a0, a1));\n    var _sqlite3_result_zeroblob64 = (Module['_sqlite3_result_zeroblob64'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_zeroblob64 = Module['_sqlite3_result_zeroblob64'] =\n        wasmExports['sqlite3_result_zeroblob64'])(a0, a1));\n    var _sqlite3_result_error_code = (Module['_sqlite3_result_error_code'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_result_error_code = Module['_sqlite3_result_error_code'] =\n        wasmExports['sqlite3_result_error_code'])(a0, a1));\n    var _sqlite3_user_data = (Module['_sqlite3_user_data'] = (a0) =>\n      (_sqlite3_user_data = Module['_sqlite3_user_data'] =\n        wasmExports['sqlite3_user_data'])(a0));\n    var _sqlite3_context_db_handle = (Module['_sqlite3_context_db_handle'] = (\n      a0,\n    ) =>\n      (_sqlite3_context_db_handle = Module['_sqlite3_context_db_handle'] =\n        wasmExports['sqlite3_context_db_handle'])(a0));\n    var _sqlite3_vtab_nochange = (Module['_sqlite3_vtab_nochange'] = (a0) =>\n      (_sqlite3_vtab_nochange = Module['_sqlite3_vtab_nochange'] =\n        wasmExports['sqlite3_vtab_nochange'])(a0));\n    var _sqlite3_vtab_in_first = (Module['_sqlite3_vtab_in_first'] = (a0, a1) =>\n      (_sqlite3_vtab_in_first = Module['_sqlite3_vtab_in_first'] =\n        wasmExports['sqlite3_vtab_in_first'])(a0, a1));\n    var _sqlite3_vtab_in_next = (Module['_sqlite3_vtab_in_next'] = (a0, a1) =>\n      (_sqlite3_vtab_in_next = Module['_sqlite3_vtab_in_next'] =\n        wasmExports['sqlite3_vtab_in_next'])(a0, a1));\n    var _sqlite3_aggregate_context = (Module['_sqlite3_aggregate_context'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_aggregate_context = Module['_sqlite3_aggregate_context'] =\n        wasmExports['sqlite3_aggregate_context'])(a0, a1));\n    var _sqlite3_get_auxdata = (Module['_sqlite3_get_auxdata'] = (a0, a1) =>\n      (_sqlite3_get_auxdata = Module['_sqlite3_get_auxdata'] =\n        wasmExports['sqlite3_get_auxdata'])(a0, a1));\n    var _sqlite3_set_auxdata = (Module['_sqlite3_set_auxdata'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_set_auxdata = Module['_sqlite3_set_auxdata'] =\n        wasmExports['sqlite3_set_auxdata'])(a0, a1, a2, a3));\n    var _sqlite3_column_count = (Module['_sqlite3_column_count'] = (a0) =>\n      (_sqlite3_column_count = Module['_sqlite3_column_count'] =\n        wasmExports['sqlite3_column_count'])(a0));\n    var _sqlite3_data_count = (Module['_sqlite3_data_count'] = (a0) =>\n      (_sqlite3_data_count = Module['_sqlite3_data_count'] =\n        wasmExports['sqlite3_data_count'])(a0));\n    var _sqlite3_column_blob = (Module['_sqlite3_column_blob'] = (a0, a1) =>\n      (_sqlite3_column_blob = Module['_sqlite3_column_blob'] =\n        wasmExports['sqlite3_column_blob'])(a0, a1));\n    var _sqlite3_column_bytes = (Module['_sqlite3_column_bytes'] = (a0, a1) =>\n      (_sqlite3_column_bytes = Module['_sqlite3_column_bytes'] =\n        wasmExports['sqlite3_column_bytes'])(a0, a1));\n    var _sqlite3_column_double = (Module['_sqlite3_column_double'] = (a0, a1) =>\n      (_sqlite3_column_double = Module['_sqlite3_column_double'] =\n        wasmExports['sqlite3_column_double'])(a0, a1));\n    var _sqlite3_column_value = (Module['_sqlite3_column_value'] = (a0, a1) =>\n      (_sqlite3_column_value = Module['_sqlite3_column_value'] =\n        wasmExports['sqlite3_column_value'])(a0, a1));\n    var _sqlite3_column_decltype = (Module['_sqlite3_column_decltype'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_column_decltype = Module['_sqlite3_column_decltype'] =\n        wasmExports['sqlite3_column_decltype'])(a0, a1));\n    var _sqlite3_bind_blob = (Module['_sqlite3_bind_blob'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_bind_blob = Module['_sqlite3_bind_blob'] =\n        wasmExports['sqlite3_bind_blob'])(a0, a1, a2, a3, a4));\n    var _sqlite3_bind_double = (Module['_sqlite3_bind_double'] = (a0, a1, a2) =>\n      (_sqlite3_bind_double = Module['_sqlite3_bind_double'] =\n        wasmExports['sqlite3_bind_double'])(a0, a1, a2));\n    var _sqlite3_bind_int = (Module['_sqlite3_bind_int'] = (a0, a1, a2) =>\n      (_sqlite3_bind_int = Module['_sqlite3_bind_int'] =\n        wasmExports['sqlite3_bind_int'])(a0, a1, a2));\n    var _sqlite3_bind_int64 = (Module['_sqlite3_bind_int64'] = (a0, a1, a2) =>\n      (_sqlite3_bind_int64 = Module['_sqlite3_bind_int64'] =\n        wasmExports['sqlite3_bind_int64'])(a0, a1, a2));\n    var _sqlite3_bind_null = (Module['_sqlite3_bind_null'] = (a0, a1) =>\n      (_sqlite3_bind_null = Module['_sqlite3_bind_null'] =\n        wasmExports['sqlite3_bind_null'])(a0, a1));\n    var _sqlite3_bind_pointer = (Module['_sqlite3_bind_pointer'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_bind_pointer = Module['_sqlite3_bind_pointer'] =\n        wasmExports['sqlite3_bind_pointer'])(a0, a1, a2, a3, a4));\n    var _sqlite3_bind_text = (Module['_sqlite3_bind_text'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_bind_text = Module['_sqlite3_bind_text'] =\n        wasmExports['sqlite3_bind_text'])(a0, a1, a2, a3, a4));\n    var _sqlite3_bind_parameter_count = (Module[\n      '_sqlite3_bind_parameter_count'\n    ] = (a0) =>\n      (_sqlite3_bind_parameter_count = Module['_sqlite3_bind_parameter_count'] =\n        wasmExports['sqlite3_bind_parameter_count'])(a0));\n    var _sqlite3_bind_parameter_name = (Module['_sqlite3_bind_parameter_name'] =\n      (a0, a1) =>\n        (_sqlite3_bind_parameter_name = Module['_sqlite3_bind_parameter_name'] =\n          wasmExports['sqlite3_bind_parameter_name'])(a0, a1));\n    var _sqlite3_bind_parameter_index = (Module[\n      '_sqlite3_bind_parameter_index'\n    ] = (a0, a1) =>\n      (_sqlite3_bind_parameter_index = Module['_sqlite3_bind_parameter_index'] =\n        wasmExports['sqlite3_bind_parameter_index'])(a0, a1));\n    var _sqlite3_db_handle = (Module['_sqlite3_db_handle'] = (a0) =>\n      (_sqlite3_db_handle = Module['_sqlite3_db_handle'] =\n        wasmExports['sqlite3_db_handle'])(a0));\n    var _sqlite3_stmt_readonly = (Module['_sqlite3_stmt_readonly'] = (a0) =>\n      (_sqlite3_stmt_readonly = Module['_sqlite3_stmt_readonly'] =\n        wasmExports['sqlite3_stmt_readonly'])(a0));\n    var _sqlite3_stmt_isexplain = (Module['_sqlite3_stmt_isexplain'] = (a0) =>\n      (_sqlite3_stmt_isexplain = Module['_sqlite3_stmt_isexplain'] =\n        wasmExports['sqlite3_stmt_isexplain'])(a0));\n    var _sqlite3_stmt_explain = (Module['_sqlite3_stmt_explain'] = (a0, a1) =>\n      (_sqlite3_stmt_explain = Module['_sqlite3_stmt_explain'] =\n        wasmExports['sqlite3_stmt_explain'])(a0, a1));\n    var _sqlite3_stmt_busy = (Module['_sqlite3_stmt_busy'] = (a0) =>\n      (_sqlite3_stmt_busy = Module['_sqlite3_stmt_busy'] =\n        wasmExports['sqlite3_stmt_busy'])(a0));\n    var _sqlite3_stmt_status = (Module['_sqlite3_stmt_status'] = (a0, a1, a2) =>\n      (_sqlite3_stmt_status = Module['_sqlite3_stmt_status'] =\n        wasmExports['sqlite3_stmt_status'])(a0, a1, a2));\n    var _sqlite3_sql = (Module['_sqlite3_sql'] = (a0) =>\n      (_sqlite3_sql = Module['_sqlite3_sql'] = wasmExports['sqlite3_sql'])(a0));\n    var _sqlite3_expanded_sql = (Module['_sqlite3_expanded_sql'] = (a0) =>\n      (_sqlite3_expanded_sql = Module['_sqlite3_expanded_sql'] =\n        wasmExports['sqlite3_expanded_sql'])(a0));\n    var _sqlite3_preupdate_old = (Module['_sqlite3_preupdate_old'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_preupdate_old = Module['_sqlite3_preupdate_old'] =\n        wasmExports['sqlite3_preupdate_old'])(a0, a1, a2));\n    var _sqlite3_preupdate_count = (Module['_sqlite3_preupdate_count'] = (a0) =>\n      (_sqlite3_preupdate_count = Module['_sqlite3_preupdate_count'] =\n        wasmExports['sqlite3_preupdate_count'])(a0));\n    var _sqlite3_preupdate_depth = (Module['_sqlite3_preupdate_depth'] = (a0) =>\n      (_sqlite3_preupdate_depth = Module['_sqlite3_preupdate_depth'] =\n        wasmExports['sqlite3_preupdate_depth'])(a0));\n    var _sqlite3_preupdate_blobwrite = (Module['_sqlite3_preupdate_blobwrite'] =\n      (a0) =>\n        (_sqlite3_preupdate_blobwrite = Module['_sqlite3_preupdate_blobwrite'] =\n          wasmExports['sqlite3_preupdate_blobwrite'])(a0));\n    var _sqlite3_preupdate_new = (Module['_sqlite3_preupdate_new'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_preupdate_new = Module['_sqlite3_preupdate_new'] =\n        wasmExports['sqlite3_preupdate_new'])(a0, a1, a2));\n    var _sqlite3_value_numeric_type = (Module['_sqlite3_value_numeric_type'] = (\n      a0,\n    ) =>\n      (_sqlite3_value_numeric_type = Module['_sqlite3_value_numeric_type'] =\n        wasmExports['sqlite3_value_numeric_type'])(a0));\n    var _sqlite3_set_authorizer = (Module['_sqlite3_set_authorizer'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_set_authorizer = Module['_sqlite3_set_authorizer'] =\n        wasmExports['sqlite3_set_authorizer'])(a0, a1, a2));\n    var _sqlite3_strglob = (Module['_sqlite3_strglob'] = (a0, a1) =>\n      (_sqlite3_strglob = Module['_sqlite3_strglob'] =\n        wasmExports['sqlite3_strglob'])(a0, a1));\n    var _sqlite3_strlike = (Module['_sqlite3_strlike'] = (a0, a1, a2) =>\n      (_sqlite3_strlike = Module['_sqlite3_strlike'] =\n        wasmExports['sqlite3_strlike'])(a0, a1, a2));\n    var _sqlite3_auto_extension = (Module['_sqlite3_auto_extension'] = (a0) =>\n      (_sqlite3_auto_extension = Module['_sqlite3_auto_extension'] =\n        wasmExports['sqlite3_auto_extension'])(a0));\n    var _sqlite3_cancel_auto_extension = (Module[\n      '_sqlite3_cancel_auto_extension'\n    ] = (a0) =>\n      (_sqlite3_cancel_auto_extension = Module[\n        '_sqlite3_cancel_auto_extension'\n      ] =\n        wasmExports['sqlite3_cancel_auto_extension'])(a0));\n    var _sqlite3_reset_auto_extension = (Module[\n      '_sqlite3_reset_auto_extension'\n    ] = () =>\n      (_sqlite3_reset_auto_extension = Module['_sqlite3_reset_auto_extension'] =\n        wasmExports['sqlite3_reset_auto_extension'])());\n    var _sqlite3_prepare_v3 = (Module['_sqlite3_prepare_v3'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3_prepare_v3 = Module['_sqlite3_prepare_v3'] =\n        wasmExports['sqlite3_prepare_v3'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3_create_module = (Module['_sqlite3_create_module'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_create_module = Module['_sqlite3_create_module'] =\n        wasmExports['sqlite3_create_module'])(a0, a1, a2, a3));\n    var _sqlite3_create_module_v2 = (Module['_sqlite3_create_module_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_create_module_v2 = Module['_sqlite3_create_module_v2'] =\n        wasmExports['sqlite3_create_module_v2'])(a0, a1, a2, a3, a4));\n    var _sqlite3_drop_modules = (Module['_sqlite3_drop_modules'] = (a0, a1) =>\n      (_sqlite3_drop_modules = Module['_sqlite3_drop_modules'] =\n        wasmExports['sqlite3_drop_modules'])(a0, a1));\n    var _sqlite3_declare_vtab = (Module['_sqlite3_declare_vtab'] = (a0, a1) =>\n      (_sqlite3_declare_vtab = Module['_sqlite3_declare_vtab'] =\n        wasmExports['sqlite3_declare_vtab'])(a0, a1));\n    var _sqlite3_vtab_on_conflict = (Module['_sqlite3_vtab_on_conflict'] = (\n      a0,\n    ) =>\n      (_sqlite3_vtab_on_conflict = Module['_sqlite3_vtab_on_conflict'] =\n        wasmExports['sqlite3_vtab_on_conflict'])(a0));\n    var _sqlite3_vtab_collation = (Module['_sqlite3_vtab_collation'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3_vtab_collation = Module['_sqlite3_vtab_collation'] =\n        wasmExports['sqlite3_vtab_collation'])(a0, a1));\n    var _sqlite3_vtab_in = (Module['_sqlite3_vtab_in'] = (a0, a1, a2) =>\n      (_sqlite3_vtab_in = Module['_sqlite3_vtab_in'] =\n        wasmExports['sqlite3_vtab_in'])(a0, a1, a2));\n    var _sqlite3_vtab_rhs_value = (Module['_sqlite3_vtab_rhs_value'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_vtab_rhs_value = Module['_sqlite3_vtab_rhs_value'] =\n        wasmExports['sqlite3_vtab_rhs_value'])(a0, a1, a2));\n    var _sqlite3_vtab_distinct = (Module['_sqlite3_vtab_distinct'] = (a0) =>\n      (_sqlite3_vtab_distinct = Module['_sqlite3_vtab_distinct'] =\n        wasmExports['sqlite3_vtab_distinct'])(a0));\n    var _sqlite3_keyword_name = (Module['_sqlite3_keyword_name'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_keyword_name = Module['_sqlite3_keyword_name'] =\n        wasmExports['sqlite3_keyword_name'])(a0, a1, a2));\n    var _sqlite3_keyword_count = (Module['_sqlite3_keyword_count'] = () =>\n      (_sqlite3_keyword_count = Module['_sqlite3_keyword_count'] =\n        wasmExports['sqlite3_keyword_count'])());\n    var _sqlite3_keyword_check = (Module['_sqlite3_keyword_check'] = (a0, a1) =>\n      (_sqlite3_keyword_check = Module['_sqlite3_keyword_check'] =\n        wasmExports['sqlite3_keyword_check'])(a0, a1));\n    var _sqlite3_complete = (Module['_sqlite3_complete'] = (a0) =>\n      (_sqlite3_complete = Module['_sqlite3_complete'] =\n        wasmExports['sqlite3_complete'])(a0));\n    var _sqlite3_libversion = (Module['_sqlite3_libversion'] = () =>\n      (_sqlite3_libversion = Module['_sqlite3_libversion'] =\n        wasmExports['sqlite3_libversion'])());\n    var _sqlite3_libversion_number = (Module['_sqlite3_libversion_number'] =\n      () =>\n        (_sqlite3_libversion_number = Module['_sqlite3_libversion_number'] =\n          wasmExports['sqlite3_libversion_number'])());\n    var _sqlite3_shutdown = (Module['_sqlite3_shutdown'] = () =>\n      (_sqlite3_shutdown = Module['_sqlite3_shutdown'] =\n        wasmExports['sqlite3_shutdown'])());\n    var _sqlite3_last_insert_rowid = (Module['_sqlite3_last_insert_rowid'] = (\n      a0,\n    ) =>\n      (_sqlite3_last_insert_rowid = Module['_sqlite3_last_insert_rowid'] =\n        wasmExports['sqlite3_last_insert_rowid'])(a0));\n    var _sqlite3_set_last_insert_rowid = (Module[\n      '_sqlite3_set_last_insert_rowid'\n    ] = (a0, a1) =>\n      (_sqlite3_set_last_insert_rowid = Module[\n        '_sqlite3_set_last_insert_rowid'\n      ] =\n        wasmExports['sqlite3_set_last_insert_rowid'])(a0, a1));\n    var _sqlite3_changes64 = (Module['_sqlite3_changes64'] = (a0) =>\n      (_sqlite3_changes64 = Module['_sqlite3_changes64'] =\n        wasmExports['sqlite3_changes64'])(a0));\n    var _sqlite3_changes = (Module['_sqlite3_changes'] = (a0) =>\n      (_sqlite3_changes = Module['_sqlite3_changes'] =\n        wasmExports['sqlite3_changes'])(a0));\n    var _sqlite3_total_changes64 = (Module['_sqlite3_total_changes64'] = (a0) =>\n      (_sqlite3_total_changes64 = Module['_sqlite3_total_changes64'] =\n        wasmExports['sqlite3_total_changes64'])(a0));\n    var _sqlite3_total_changes = (Module['_sqlite3_total_changes'] = (a0) =>\n      (_sqlite3_total_changes = Module['_sqlite3_total_changes'] =\n        wasmExports['sqlite3_total_changes'])(a0));\n    var _sqlite3_txn_state = (Module['_sqlite3_txn_state'] = (a0, a1) =>\n      (_sqlite3_txn_state = Module['_sqlite3_txn_state'] =\n        wasmExports['sqlite3_txn_state'])(a0, a1));\n    var _sqlite3_close_v2 = (Module['_sqlite3_close_v2'] = (a0) =>\n      (_sqlite3_close_v2 = Module['_sqlite3_close_v2'] =\n        wasmExports['sqlite3_close_v2'])(a0));\n    var _sqlite3_busy_handler = (Module['_sqlite3_busy_handler'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_busy_handler = Module['_sqlite3_busy_handler'] =\n        wasmExports['sqlite3_busy_handler'])(a0, a1, a2));\n    var _sqlite3_progress_handler = (Module['_sqlite3_progress_handler'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3_progress_handler = Module['_sqlite3_progress_handler'] =\n        wasmExports['sqlite3_progress_handler'])(a0, a1, a2, a3));\n    var _sqlite3_busy_timeout = (Module['_sqlite3_busy_timeout'] = (a0, a1) =>\n      (_sqlite3_busy_timeout = Module['_sqlite3_busy_timeout'] =\n        wasmExports['sqlite3_busy_timeout'])(a0, a1));\n    var _sqlite3_interrupt = (Module['_sqlite3_interrupt'] = (a0) =>\n      (_sqlite3_interrupt = Module['_sqlite3_interrupt'] =\n        wasmExports['sqlite3_interrupt'])(a0));\n    var _sqlite3_is_interrupted = (Module['_sqlite3_is_interrupted'] = (a0) =>\n      (_sqlite3_is_interrupted = Module['_sqlite3_is_interrupted'] =\n        wasmExports['sqlite3_is_interrupted'])(a0));\n    var _sqlite3_create_function = (Module['_sqlite3_create_function'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n    ) =>\n      (_sqlite3_create_function = Module['_sqlite3_create_function'] =\n        wasmExports['sqlite3_create_function'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n      ));\n    var _sqlite3_create_function_v2 = (Module['_sqlite3_create_function_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n    ) =>\n      (_sqlite3_create_function_v2 = Module['_sqlite3_create_function_v2'] =\n        wasmExports['sqlite3_create_function_v2'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3_create_window_function = (Module[\n      '_sqlite3_create_window_function'\n    ] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) =>\n      (_sqlite3_create_window_function = Module[\n        '_sqlite3_create_window_function'\n      ] =\n        wasmExports['sqlite3_create_window_function'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n        a9,\n      ));\n    var _sqlite3_overload_function = (Module['_sqlite3_overload_function'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_overload_function = Module['_sqlite3_overload_function'] =\n        wasmExports['sqlite3_overload_function'])(a0, a1, a2));\n    var _sqlite3_trace_v2 = (Module['_sqlite3_trace_v2'] = (a0, a1, a2, a3) =>\n      (_sqlite3_trace_v2 = Module['_sqlite3_trace_v2'] =\n        wasmExports['sqlite3_trace_v2'])(a0, a1, a2, a3));\n    var _sqlite3_commit_hook = (Module['_sqlite3_commit_hook'] = (a0, a1, a2) =>\n      (_sqlite3_commit_hook = Module['_sqlite3_commit_hook'] =\n        wasmExports['sqlite3_commit_hook'])(a0, a1, a2));\n    var _sqlite3_update_hook = (Module['_sqlite3_update_hook'] = (a0, a1, a2) =>\n      (_sqlite3_update_hook = Module['_sqlite3_update_hook'] =\n        wasmExports['sqlite3_update_hook'])(a0, a1, a2));\n    var _sqlite3_rollback_hook = (Module['_sqlite3_rollback_hook'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_rollback_hook = Module['_sqlite3_rollback_hook'] =\n        wasmExports['sqlite3_rollback_hook'])(a0, a1, a2));\n    var _sqlite3_preupdate_hook = (Module['_sqlite3_preupdate_hook'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_preupdate_hook = Module['_sqlite3_preupdate_hook'] =\n        wasmExports['sqlite3_preupdate_hook'])(a0, a1, a2));\n    var _sqlite3_error_offset = (Module['_sqlite3_error_offset'] = (a0) =>\n      (_sqlite3_error_offset = Module['_sqlite3_error_offset'] =\n        wasmExports['sqlite3_error_offset'])(a0));\n    var _sqlite3_errcode = (Module['_sqlite3_errcode'] = (a0) =>\n      (_sqlite3_errcode = Module['_sqlite3_errcode'] =\n        wasmExports['sqlite3_errcode'])(a0));\n    var _sqlite3_extended_errcode = (Module['_sqlite3_extended_errcode'] = (\n      a0,\n    ) =>\n      (_sqlite3_extended_errcode = Module['_sqlite3_extended_errcode'] =\n        wasmExports['sqlite3_extended_errcode'])(a0));\n    var _sqlite3_errstr = (Module['_sqlite3_errstr'] = (a0) =>\n      (_sqlite3_errstr = Module['_sqlite3_errstr'] =\n        wasmExports['sqlite3_errstr'])(a0));\n    var _sqlite3_limit = (Module['_sqlite3_limit'] = (a0, a1, a2) =>\n      (_sqlite3_limit = Module['_sqlite3_limit'] =\n        wasmExports['sqlite3_limit'])(a0, a1, a2));\n    var _sqlite3_open = (Module['_sqlite3_open'] = (a0, a1) =>\n      (_sqlite3_open = Module['_sqlite3_open'] = wasmExports['sqlite3_open'])(\n        a0,\n        a1,\n      ));\n    var _sqlite3_open_v2 = (Module['_sqlite3_open_v2'] = (a0, a1, a2, a3) =>\n      (_sqlite3_open_v2 = Module['_sqlite3_open_v2'] =\n        wasmExports['sqlite3_open_v2'])(a0, a1, a2, a3));\n    var _sqlite3_create_collation = (Module['_sqlite3_create_collation'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3_create_collation = Module['_sqlite3_create_collation'] =\n        wasmExports['sqlite3_create_collation'])(a0, a1, a2, a3, a4));\n    var _sqlite3_create_collation_v2 = (Module['_sqlite3_create_collation_v2'] =\n      (a0, a1, a2, a3, a4, a5) =>\n        (_sqlite3_create_collation_v2 = Module['_sqlite3_create_collation_v2'] =\n          wasmExports['sqlite3_create_collation_v2'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3_collation_needed = (Module['_sqlite3_collation_needed'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3_collation_needed = Module['_sqlite3_collation_needed'] =\n        wasmExports['sqlite3_collation_needed'])(a0, a1, a2));\n    var _sqlite3_get_autocommit = (Module['_sqlite3_get_autocommit'] = (a0) =>\n      (_sqlite3_get_autocommit = Module['_sqlite3_get_autocommit'] =\n        wasmExports['sqlite3_get_autocommit'])(a0));\n    var _sqlite3_table_column_metadata = (Module[\n      '_sqlite3_table_column_metadata'\n    ] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) =>\n      (_sqlite3_table_column_metadata = Module[\n        '_sqlite3_table_column_metadata'\n      ] =\n        wasmExports['sqlite3_table_column_metadata'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3_extended_result_codes = (Module[\n      '_sqlite3_extended_result_codes'\n    ] = (a0, a1) =>\n      (_sqlite3_extended_result_codes = Module[\n        '_sqlite3_extended_result_codes'\n      ] =\n        wasmExports['sqlite3_extended_result_codes'])(a0, a1));\n    var _sqlite3_uri_key = (Module['_sqlite3_uri_key'] = (a0, a1) =>\n      (_sqlite3_uri_key = Module['_sqlite3_uri_key'] =\n        wasmExports['sqlite3_uri_key'])(a0, a1));\n    var _sqlite3_uri_int64 = (Module['_sqlite3_uri_int64'] = (a0, a1, a2) =>\n      (_sqlite3_uri_int64 = Module['_sqlite3_uri_int64'] =\n        wasmExports['sqlite3_uri_int64'])(a0, a1, a2));\n    var _sqlite3_db_name = (Module['_sqlite3_db_name'] = (a0, a1) =>\n      (_sqlite3_db_name = Module['_sqlite3_db_name'] =\n        wasmExports['sqlite3_db_name'])(a0, a1));\n    var _sqlite3_db_filename = (Module['_sqlite3_db_filename'] = (a0, a1) =>\n      (_sqlite3_db_filename = Module['_sqlite3_db_filename'] =\n        wasmExports['sqlite3_db_filename'])(a0, a1));\n    var _sqlite3_db_readonly = (Module['_sqlite3_db_readonly'] = (a0, a1) =>\n      (_sqlite3_db_readonly = Module['_sqlite3_db_readonly'] =\n        wasmExports['sqlite3_db_readonly'])(a0, a1));\n    var _sqlite3_compileoption_used = (Module['_sqlite3_compileoption_used'] = (\n      a0,\n    ) =>\n      (_sqlite3_compileoption_used = Module['_sqlite3_compileoption_used'] =\n        wasmExports['sqlite3_compileoption_used'])(a0));\n    var _sqlite3_compileoption_get = (Module['_sqlite3_compileoption_get'] = (\n      a0,\n    ) =>\n      (_sqlite3_compileoption_get = Module['_sqlite3_compileoption_get'] =\n        wasmExports['sqlite3_compileoption_get'])(a0));\n    var _sqlite3session_diff = (Module['_sqlite3session_diff'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3session_diff = Module['_sqlite3session_diff'] =\n        wasmExports['sqlite3session_diff'])(a0, a1, a2, a3));\n    var _sqlite3session_attach = (Module['_sqlite3session_attach'] = (a0, a1) =>\n      (_sqlite3session_attach = Module['_sqlite3session_attach'] =\n        wasmExports['sqlite3session_attach'])(a0, a1));\n    var _sqlite3session_create = (Module['_sqlite3session_create'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3session_create = Module['_sqlite3session_create'] =\n        wasmExports['sqlite3session_create'])(a0, a1, a2));\n    var _sqlite3session_delete = (Module['_sqlite3session_delete'] = (a0) =>\n      (_sqlite3session_delete = Module['_sqlite3session_delete'] =\n        wasmExports['sqlite3session_delete'])(a0));\n    var _sqlite3session_table_filter = (Module['_sqlite3session_table_filter'] =\n      (a0, a1, a2) =>\n        (_sqlite3session_table_filter = Module['_sqlite3session_table_filter'] =\n          wasmExports['sqlite3session_table_filter'])(a0, a1, a2));\n    var _sqlite3session_changeset = (Module['_sqlite3session_changeset'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3session_changeset = Module['_sqlite3session_changeset'] =\n        wasmExports['sqlite3session_changeset'])(a0, a1, a2));\n    var _sqlite3session_changeset_strm = (Module[\n      '_sqlite3session_changeset_strm'\n    ] = (a0, a1, a2) =>\n      (_sqlite3session_changeset_strm = Module[\n        '_sqlite3session_changeset_strm'\n      ] =\n        wasmExports['sqlite3session_changeset_strm'])(a0, a1, a2));\n    var _sqlite3session_patchset_strm = (Module[\n      '_sqlite3session_patchset_strm'\n    ] = (a0, a1, a2) =>\n      (_sqlite3session_patchset_strm = Module['_sqlite3session_patchset_strm'] =\n        wasmExports['sqlite3session_patchset_strm'])(a0, a1, a2));\n    var _sqlite3session_patchset = (Module['_sqlite3session_patchset'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3session_patchset = Module['_sqlite3session_patchset'] =\n        wasmExports['sqlite3session_patchset'])(a0, a1, a2));\n    var _sqlite3session_enable = (Module['_sqlite3session_enable'] = (a0, a1) =>\n      (_sqlite3session_enable = Module['_sqlite3session_enable'] =\n        wasmExports['sqlite3session_enable'])(a0, a1));\n    var _sqlite3session_indirect = (Module['_sqlite3session_indirect'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3session_indirect = Module['_sqlite3session_indirect'] =\n        wasmExports['sqlite3session_indirect'])(a0, a1));\n    var _sqlite3session_isempty = (Module['_sqlite3session_isempty'] = (a0) =>\n      (_sqlite3session_isempty = Module['_sqlite3session_isempty'] =\n        wasmExports['sqlite3session_isempty'])(a0));\n    var _sqlite3session_memory_used = (Module['_sqlite3session_memory_used'] = (\n      a0,\n    ) =>\n      (_sqlite3session_memory_used = Module['_sqlite3session_memory_used'] =\n        wasmExports['sqlite3session_memory_used'])(a0));\n    var _sqlite3session_object_config = (Module[\n      '_sqlite3session_object_config'\n    ] = (a0, a1, a2) =>\n      (_sqlite3session_object_config = Module['_sqlite3session_object_config'] =\n        wasmExports['sqlite3session_object_config'])(a0, a1, a2));\n    var _sqlite3session_changeset_size = (Module[\n      '_sqlite3session_changeset_size'\n    ] = (a0) =>\n      (_sqlite3session_changeset_size = Module[\n        '_sqlite3session_changeset_size'\n      ] =\n        wasmExports['sqlite3session_changeset_size'])(a0));\n    var _sqlite3changeset_start = (Module['_sqlite3changeset_start'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_start = Module['_sqlite3changeset_start'] =\n        wasmExports['sqlite3changeset_start'])(a0, a1, a2));\n    var _sqlite3changeset_start_v2 = (Module['_sqlite3changeset_start_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3changeset_start_v2 = Module['_sqlite3changeset_start_v2'] =\n        wasmExports['sqlite3changeset_start_v2'])(a0, a1, a2, a3));\n    var _sqlite3changeset_start_strm = (Module['_sqlite3changeset_start_strm'] =\n      (a0, a1, a2) =>\n        (_sqlite3changeset_start_strm = Module['_sqlite3changeset_start_strm'] =\n          wasmExports['sqlite3changeset_start_strm'])(a0, a1, a2));\n    var _sqlite3changeset_start_v2_strm = (Module[\n      '_sqlite3changeset_start_v2_strm'\n    ] = (a0, a1, a2, a3) =>\n      (_sqlite3changeset_start_v2_strm = Module[\n        '_sqlite3changeset_start_v2_strm'\n      ] =\n        wasmExports['sqlite3changeset_start_v2_strm'])(a0, a1, a2, a3));\n    var _sqlite3changeset_next = (Module['_sqlite3changeset_next'] = (a0) =>\n      (_sqlite3changeset_next = Module['_sqlite3changeset_next'] =\n        wasmExports['sqlite3changeset_next'])(a0));\n    var _sqlite3changeset_op = (Module['_sqlite3changeset_op'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3changeset_op = Module['_sqlite3changeset_op'] =\n        wasmExports['sqlite3changeset_op'])(a0, a1, a2, a3, a4));\n    var _sqlite3changeset_pk = (Module['_sqlite3changeset_pk'] = (a0, a1, a2) =>\n      (_sqlite3changeset_pk = Module['_sqlite3changeset_pk'] =\n        wasmExports['sqlite3changeset_pk'])(a0, a1, a2));\n    var _sqlite3changeset_old = (Module['_sqlite3changeset_old'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_old = Module['_sqlite3changeset_old'] =\n        wasmExports['sqlite3changeset_old'])(a0, a1, a2));\n    var _sqlite3changeset_new = (Module['_sqlite3changeset_new'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_new = Module['_sqlite3changeset_new'] =\n        wasmExports['sqlite3changeset_new'])(a0, a1, a2));\n    var _sqlite3changeset_conflict = (Module['_sqlite3changeset_conflict'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changeset_conflict = Module['_sqlite3changeset_conflict'] =\n        wasmExports['sqlite3changeset_conflict'])(a0, a1, a2));\n    var _sqlite3changeset_fk_conflicts = (Module[\n      '_sqlite3changeset_fk_conflicts'\n    ] = (a0, a1) =>\n      (_sqlite3changeset_fk_conflicts = Module[\n        '_sqlite3changeset_fk_conflicts'\n      ] =\n        wasmExports['sqlite3changeset_fk_conflicts'])(a0, a1));\n    var _sqlite3changeset_finalize = (Module['_sqlite3changeset_finalize'] = (\n      a0,\n    ) =>\n      (_sqlite3changeset_finalize = Module['_sqlite3changeset_finalize'] =\n        wasmExports['sqlite3changeset_finalize'])(a0));\n    var _sqlite3changeset_invert = (Module['_sqlite3changeset_invert'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3changeset_invert = Module['_sqlite3changeset_invert'] =\n        wasmExports['sqlite3changeset_invert'])(a0, a1, a2, a3));\n    var _sqlite3changeset_invert_strm = (Module[\n      '_sqlite3changeset_invert_strm'\n    ] = (a0, a1, a2, a3) =>\n      (_sqlite3changeset_invert_strm = Module['_sqlite3changeset_invert_strm'] =\n        wasmExports['sqlite3changeset_invert_strm'])(a0, a1, a2, a3));\n    var _sqlite3changeset_apply_v2 = (Module['_sqlite3changeset_apply_v2'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n    ) =>\n      (_sqlite3changeset_apply_v2 = Module['_sqlite3changeset_apply_v2'] =\n        wasmExports['sqlite3changeset_apply_v2'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3changeset_apply = (Module['_sqlite3changeset_apply'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3changeset_apply = Module['_sqlite3changeset_apply'] =\n        wasmExports['sqlite3changeset_apply'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3changeset_apply_v2_strm = (Module[\n      '_sqlite3changeset_apply_v2_strm'\n    ] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) =>\n      (_sqlite3changeset_apply_v2_strm = Module[\n        '_sqlite3changeset_apply_v2_strm'\n      ] =\n        wasmExports['sqlite3changeset_apply_v2_strm'])(\n        a0,\n        a1,\n        a2,\n        a3,\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n      ));\n    var _sqlite3changeset_apply_strm = (Module['_sqlite3changeset_apply_strm'] =\n      (a0, a1, a2, a3, a4, a5) =>\n        (_sqlite3changeset_apply_strm = Module['_sqlite3changeset_apply_strm'] =\n          wasmExports['sqlite3changeset_apply_strm'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3changegroup_new = (Module['_sqlite3changegroup_new'] = (a0) =>\n      (_sqlite3changegroup_new = Module['_sqlite3changegroup_new'] =\n        wasmExports['sqlite3changegroup_new'])(a0));\n    var _sqlite3changegroup_add = (Module['_sqlite3changegroup_add'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changegroup_add = Module['_sqlite3changegroup_add'] =\n        wasmExports['sqlite3changegroup_add'])(a0, a1, a2));\n    var _sqlite3changegroup_output = (Module['_sqlite3changegroup_output'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3changegroup_output = Module['_sqlite3changegroup_output'] =\n        wasmExports['sqlite3changegroup_output'])(a0, a1, a2));\n    var _sqlite3changegroup_add_strm = (Module['_sqlite3changegroup_add_strm'] =\n      (a0, a1, a2) =>\n        (_sqlite3changegroup_add_strm = Module['_sqlite3changegroup_add_strm'] =\n          wasmExports['sqlite3changegroup_add_strm'])(a0, a1, a2));\n    var _sqlite3changegroup_output_strm = (Module[\n      '_sqlite3changegroup_output_strm'\n    ] = (a0, a1, a2) =>\n      (_sqlite3changegroup_output_strm = Module[\n        '_sqlite3changegroup_output_strm'\n      ] =\n        wasmExports['sqlite3changegroup_output_strm'])(a0, a1, a2));\n    var _sqlite3changegroup_delete = (Module['_sqlite3changegroup_delete'] = (\n      a0,\n    ) =>\n      (_sqlite3changegroup_delete = Module['_sqlite3changegroup_delete'] =\n        wasmExports['sqlite3changegroup_delete'])(a0));\n    var _sqlite3changeset_concat = (Module['_sqlite3changeset_concat'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n      a5,\n    ) =>\n      (_sqlite3changeset_concat = Module['_sqlite3changeset_concat'] =\n        wasmExports['sqlite3changeset_concat'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3changeset_concat_strm = (Module[\n      '_sqlite3changeset_concat_strm'\n    ] = (a0, a1, a2, a3, a4, a5) =>\n      (_sqlite3changeset_concat_strm = Module['_sqlite3changeset_concat_strm'] =\n        wasmExports['sqlite3changeset_concat_strm'])(a0, a1, a2, a3, a4, a5));\n    var _sqlite3session_config = (Module['_sqlite3session_config'] = (a0, a1) =>\n      (_sqlite3session_config = Module['_sqlite3session_config'] =\n        wasmExports['sqlite3session_config'])(a0, a1));\n    var _sqlite3_sourceid = (Module['_sqlite3_sourceid'] = () =>\n      (_sqlite3_sourceid = Module['_sqlite3_sourceid'] =\n        wasmExports['sqlite3_sourceid'])());\n    var _sqlite3__wasm_pstack_ptr = (Module['_sqlite3__wasm_pstack_ptr'] = () =>\n      (_sqlite3__wasm_pstack_ptr = Module['_sqlite3__wasm_pstack_ptr'] =\n        wasmExports['sqlite3__wasm_pstack_ptr'])());\n    var _sqlite3__wasm_pstack_restore = (Module[\n      '_sqlite3__wasm_pstack_restore'\n    ] = (a0) =>\n      (_sqlite3__wasm_pstack_restore = Module['_sqlite3__wasm_pstack_restore'] =\n        wasmExports['sqlite3__wasm_pstack_restore'])(a0));\n    var _sqlite3__wasm_pstack_alloc = (Module['_sqlite3__wasm_pstack_alloc'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_pstack_alloc = Module['_sqlite3__wasm_pstack_alloc'] =\n        wasmExports['sqlite3__wasm_pstack_alloc'])(a0));\n    var _sqlite3__wasm_pstack_remaining = (Module[\n      '_sqlite3__wasm_pstack_remaining'\n    ] = () =>\n      (_sqlite3__wasm_pstack_remaining = Module[\n        '_sqlite3__wasm_pstack_remaining'\n      ] =\n        wasmExports['sqlite3__wasm_pstack_remaining'])());\n    var _sqlite3__wasm_pstack_quota = (Module['_sqlite3__wasm_pstack_quota'] =\n      () =>\n        (_sqlite3__wasm_pstack_quota = Module['_sqlite3__wasm_pstack_quota'] =\n          wasmExports['sqlite3__wasm_pstack_quota'])());\n    var _sqlite3__wasm_db_error = (Module['_sqlite3__wasm_db_error'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_db_error = Module['_sqlite3__wasm_db_error'] =\n        wasmExports['sqlite3__wasm_db_error'])(a0, a1, a2));\n    var _sqlite3__wasm_test_struct = (Module['_sqlite3__wasm_test_struct'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_test_struct = Module['_sqlite3__wasm_test_struct'] =\n        wasmExports['sqlite3__wasm_test_struct'])(a0));\n    var _sqlite3__wasm_enum_json = (Module['_sqlite3__wasm_enum_json'] = () =>\n      (_sqlite3__wasm_enum_json = Module['_sqlite3__wasm_enum_json'] =\n        wasmExports['sqlite3__wasm_enum_json'])());\n    var _sqlite3__wasm_vfs_unlink = (Module['_sqlite3__wasm_vfs_unlink'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_vfs_unlink = Module['_sqlite3__wasm_vfs_unlink'] =\n        wasmExports['sqlite3__wasm_vfs_unlink'])(a0, a1));\n    var _sqlite3__wasm_db_vfs = (Module['_sqlite3__wasm_db_vfs'] = (a0, a1) =>\n      (_sqlite3__wasm_db_vfs = Module['_sqlite3__wasm_db_vfs'] =\n        wasmExports['sqlite3__wasm_db_vfs'])(a0, a1));\n    var _sqlite3__wasm_db_reset = (Module['_sqlite3__wasm_db_reset'] = (a0) =>\n      (_sqlite3__wasm_db_reset = Module['_sqlite3__wasm_db_reset'] =\n        wasmExports['sqlite3__wasm_db_reset'])(a0));\n    var _sqlite3__wasm_db_export_chunked = (Module[\n      '_sqlite3__wasm_db_export_chunked'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_db_export_chunked = Module[\n        '_sqlite3__wasm_db_export_chunked'\n      ] =\n        wasmExports['sqlite3__wasm_db_export_chunked'])(a0, a1));\n    var _sqlite3__wasm_db_serialize = (Module['_sqlite3__wasm_db_serialize'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n      a4,\n    ) =>\n      (_sqlite3__wasm_db_serialize = Module['_sqlite3__wasm_db_serialize'] =\n        wasmExports['sqlite3__wasm_db_serialize'])(a0, a1, a2, a3, a4));\n    var _sqlite3__wasm_vfs_create_file = (Module[\n      '_sqlite3__wasm_vfs_create_file'\n    ] = (a0, a1, a2, a3) =>\n      (_sqlite3__wasm_vfs_create_file = Module[\n        '_sqlite3__wasm_vfs_create_file'\n      ] =\n        wasmExports['sqlite3__wasm_vfs_create_file'])(a0, a1, a2, a3));\n    var _sqlite3__wasm_posix_create_file = (Module[\n      '_sqlite3__wasm_posix_create_file'\n    ] = (a0, a1, a2) =>\n      (_sqlite3__wasm_posix_create_file = Module[\n        '_sqlite3__wasm_posix_create_file'\n      ] =\n        wasmExports['sqlite3__wasm_posix_create_file'])(a0, a1, a2));\n    var _sqlite3__wasm_kvvfsMakeKeyOnPstack = (Module[\n      '_sqlite3__wasm_kvvfsMakeKeyOnPstack'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_kvvfsMakeKeyOnPstack = Module[\n        '_sqlite3__wasm_kvvfsMakeKeyOnPstack'\n      ] =\n        wasmExports['sqlite3__wasm_kvvfsMakeKeyOnPstack'])(a0, a1));\n    var _sqlite3__wasm_kvvfs_methods = (Module['_sqlite3__wasm_kvvfs_methods'] =\n      () =>\n        (_sqlite3__wasm_kvvfs_methods = Module['_sqlite3__wasm_kvvfs_methods'] =\n          wasmExports['sqlite3__wasm_kvvfs_methods'])());\n    var _sqlite3__wasm_vtab_config = (Module['_sqlite3__wasm_vtab_config'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_vtab_config = Module['_sqlite3__wasm_vtab_config'] =\n        wasmExports['sqlite3__wasm_vtab_config'])(a0, a1, a2));\n    var _sqlite3__wasm_db_config_ip = (Module['_sqlite3__wasm_db_config_ip'] = (\n      a0,\n      a1,\n      a2,\n      a3,\n    ) =>\n      (_sqlite3__wasm_db_config_ip = Module['_sqlite3__wasm_db_config_ip'] =\n        wasmExports['sqlite3__wasm_db_config_ip'])(a0, a1, a2, a3));\n    var _sqlite3__wasm_db_config_pii = (Module['_sqlite3__wasm_db_config_pii'] =\n      (a0, a1, a2, a3, a4) =>\n        (_sqlite3__wasm_db_config_pii = Module['_sqlite3__wasm_db_config_pii'] =\n          wasmExports['sqlite3__wasm_db_config_pii'])(a0, a1, a2, a3, a4));\n    var _sqlite3__wasm_db_config_s = (Module['_sqlite3__wasm_db_config_s'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_db_config_s = Module['_sqlite3__wasm_db_config_s'] =\n        wasmExports['sqlite3__wasm_db_config_s'])(a0, a1, a2));\n    var _sqlite3__wasm_config_i = (Module['_sqlite3__wasm_config_i'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_config_i = Module['_sqlite3__wasm_config_i'] =\n        wasmExports['sqlite3__wasm_config_i'])(a0, a1));\n    var _sqlite3__wasm_config_ii = (Module['_sqlite3__wasm_config_ii'] = (\n      a0,\n      a1,\n      a2,\n    ) =>\n      (_sqlite3__wasm_config_ii = Module['_sqlite3__wasm_config_ii'] =\n        wasmExports['sqlite3__wasm_config_ii'])(a0, a1, a2));\n    var _sqlite3__wasm_config_j = (Module['_sqlite3__wasm_config_j'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_config_j = Module['_sqlite3__wasm_config_j'] =\n        wasmExports['sqlite3__wasm_config_j'])(a0, a1));\n    var _sqlite3__wasm_qfmt_token = (Module['_sqlite3__wasm_qfmt_token'] = (\n      a0,\n      a1,\n    ) =>\n      (_sqlite3__wasm_qfmt_token = Module['_sqlite3__wasm_qfmt_token'] =\n        wasmExports['sqlite3__wasm_qfmt_token'])(a0, a1));\n    var _sqlite3__wasm_init_wasmfs = (Module['_sqlite3__wasm_init_wasmfs'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_init_wasmfs = Module['_sqlite3__wasm_init_wasmfs'] =\n        wasmExports['sqlite3__wasm_init_wasmfs'])(a0));\n    var _sqlite3__wasm_test_intptr = (Module['_sqlite3__wasm_test_intptr'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_test_intptr = Module['_sqlite3__wasm_test_intptr'] =\n        wasmExports['sqlite3__wasm_test_intptr'])(a0));\n    var _sqlite3__wasm_test_voidptr = (Module['_sqlite3__wasm_test_voidptr'] = (\n      a0,\n    ) =>\n      (_sqlite3__wasm_test_voidptr = Module['_sqlite3__wasm_test_voidptr'] =\n        wasmExports['sqlite3__wasm_test_voidptr'])(a0));\n    var _sqlite3__wasm_test_int64_max = (Module[\n      '_sqlite3__wasm_test_int64_max'\n    ] = () =>\n      (_sqlite3__wasm_test_int64_max = Module['_sqlite3__wasm_test_int64_max'] =\n        wasmExports['sqlite3__wasm_test_int64_max'])());\n    var _sqlite3__wasm_test_int64_min = (Module[\n      '_sqlite3__wasm_test_int64_min'\n    ] = () =>\n      (_sqlite3__wasm_test_int64_min = Module['_sqlite3__wasm_test_int64_min'] =\n        wasmExports['sqlite3__wasm_test_int64_min'])());\n    var _sqlite3__wasm_test_int64_times2 = (Module[\n      '_sqlite3__wasm_test_int64_times2'\n    ] = (a0) =>\n      (_sqlite3__wasm_test_int64_times2 = Module[\n        '_sqlite3__wasm_test_int64_times2'\n      ] =\n        wasmExports['sqlite3__wasm_test_int64_times2'])(a0));\n    var _sqlite3__wasm_test_int64_minmax = (Module[\n      '_sqlite3__wasm_test_int64_minmax'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_test_int64_minmax = Module[\n        '_sqlite3__wasm_test_int64_minmax'\n      ] =\n        wasmExports['sqlite3__wasm_test_int64_minmax'])(a0, a1));\n    var _sqlite3__wasm_test_int64ptr = (Module['_sqlite3__wasm_test_int64ptr'] =\n      (a0) =>\n        (_sqlite3__wasm_test_int64ptr = Module['_sqlite3__wasm_test_int64ptr'] =\n          wasmExports['sqlite3__wasm_test_int64ptr'])(a0));\n    var _sqlite3__wasm_test_stack_overflow = (Module[\n      '_sqlite3__wasm_test_stack_overflow'\n    ] = (a0) =>\n      (_sqlite3__wasm_test_stack_overflow = Module[\n        '_sqlite3__wasm_test_stack_overflow'\n      ] =\n        wasmExports['sqlite3__wasm_test_stack_overflow'])(a0));\n    var _sqlite3__wasm_test_str_hello = (Module[\n      '_sqlite3__wasm_test_str_hello'\n    ] = (a0) =>\n      (_sqlite3__wasm_test_str_hello = Module['_sqlite3__wasm_test_str_hello'] =\n        wasmExports['sqlite3__wasm_test_str_hello'])(a0));\n    var _sqlite3__wasm_SQLTester_strglob = (Module[\n      '_sqlite3__wasm_SQLTester_strglob'\n    ] = (a0, a1) =>\n      (_sqlite3__wasm_SQLTester_strglob = Module[\n        '_sqlite3__wasm_SQLTester_strglob'\n      ] =\n        wasmExports['sqlite3__wasm_SQLTester_strglob'])(a0, a1));\n    var _malloc = (Module['_malloc'] = (a0) =>\n      (_malloc = Module['_malloc'] = wasmExports['malloc'])(a0));\n    var _free = (Module['_free'] = (a0) =>\n      (_free = Module['_free'] = wasmExports['free'])(a0));\n    var _realloc = (Module['_realloc'] = (a0, a1) =>\n      (_realloc = Module['_realloc'] = wasmExports['realloc'])(a0, a1));\n    var _emscripten_builtin_memalign = (a0, a1) =>\n      (_emscripten_builtin_memalign =\n        wasmExports['emscripten_builtin_memalign'])(a0, a1);\n    var __emscripten_stack_restore = (a0) =>\n      (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(\n        a0,\n      );\n    var __emscripten_stack_alloc = (a0) =>\n      (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\n    var _emscripten_stack_get_current = () =>\n      (_emscripten_stack_get_current =\n        wasmExports['emscripten_stack_get_current'])();\n\n    Module['wasmMemory'] = wasmMemory;\n\n    var calledRun;\n    var calledPrerun;\n\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n\n      if (!calledPrerun) {\n        calledPrerun = 1;\n        preRun();\n\n        if (runDependencies > 0) {\n          return;\n        }\n      }\n\n      function doRun() {\n        if (calledRun) return;\n        calledRun = 1;\n        Module['calledRun'] = 1;\n\n        if (ABORT) return;\n\n        initRuntime();\n\n        readyPromiseResolve(Module);\n        Module['onRuntimeInitialized']?.();\n\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(() => {\n          setTimeout(() => Module['setStatus'](''), 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function')\n        Module['preInit'] = [Module['preInit']];\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    run();\n\n    Module.runSQLite3PostLoadInit = function (EmscriptenModule) {\n      'use strict';\n\n      'use strict';\n      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(\n        apiConfig = globalThis.sqlite3ApiConfig ||\n          sqlite3ApiBootstrap.defaultConfig,\n      ) {\n        if (sqlite3ApiBootstrap.sqlite3) {\n          (sqlite3ApiBootstrap.sqlite3.config || console).warn(\n            'sqlite3ApiBootstrap() called multiple times.',\n            'Config and external initializers are ignored on calls after the first.',\n          );\n          return sqlite3ApiBootstrap.sqlite3;\n        }\n        const config = Object.assign(\n          Object.create(null),\n          {\n            exports: undefined,\n            memory: undefined,\n            bigIntEnabled: (() => {\n              if ('undefined' !== typeof Module) {\n                if (!!Module.HEAPU64) return true;\n              }\n              return !!globalThis.BigInt64Array;\n            })(),\n            debug: console.debug.bind(console),\n            warn: console.warn.bind(console),\n            error: console.error.bind(console),\n            log: console.log.bind(console),\n            wasmfsOpfsDir: '/opfs',\n\n            useStdAlloc: false,\n          },\n          apiConfig || {},\n        );\n\n        Object.assign(\n          config,\n          {\n            allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',\n            deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',\n            reallocExportName: config.useStdAlloc\n              ? 'realloc'\n              : 'sqlite3_realloc',\n          },\n          config,\n        );\n\n        ['exports', 'memory', 'wasmfsOpfsDir'].forEach((k) => {\n          if ('function' === typeof config[k]) {\n            config[k] = config[k]();\n          }\n        });\n\n        delete globalThis.sqlite3ApiConfig;\n        delete sqlite3ApiBootstrap.defaultConfig;\n\n        const capi = Object.create(null);\n\n        const wasm = Object.create(null);\n\n        const __rcStr = (rc) => {\n          return (\n            (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc)) ||\n            'Unknown result code #' + rc\n          );\n        };\n\n        const __isInt = (n) => 'number' === typeof n && n === (n | 0);\n\n        class SQLite3Error extends Error {\n          constructor(...args) {\n            let rc;\n            if (args.length) {\n              if (__isInt(args[0])) {\n                rc = args[0];\n                if (1 === args.length) {\n                  super(__rcStr(args[0]));\n                } else {\n                  const rcStr = __rcStr(rc);\n                  if ('object' === typeof args[1]) {\n                    super(rcStr, args[1]);\n                  } else {\n                    args[0] = rcStr + ':';\n                    super(args.join(' '));\n                  }\n                }\n              } else {\n                if (2 === args.length && 'object' === typeof args[1]) {\n                  super(...args);\n                } else {\n                  super(args.join(' '));\n                }\n              }\n            }\n            this.resultCode = rc || capi.SQLITE_ERROR;\n            this.name = 'SQLite3Error';\n          }\n        }\n\n        SQLite3Error.toss = (...args) => {\n          throw new SQLite3Error(...args);\n        };\n        const toss3 = SQLite3Error.toss;\n\n        if (config.wasmfsOpfsDir && !/^\\/[^/]+$/.test(config.wasmfsOpfsDir)) {\n          toss3(\n            \"config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.\",\n          );\n        }\n\n        const isInt32 = (n) => {\n          return (\n            'bigint' !== typeof n &&\n            !!(n === (n | 0) && n <= 2147483647 && n >= -2147483648)\n          );\n        };\n\n        const bigIntFits64 = function f(b) {\n          if (!f._max) {\n            f._max = BigInt('0x7fffffffffffffff');\n            f._min = ~f._max;\n          }\n          return b >= f._min && b <= f._max;\n        };\n\n        const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;\n\n        const bigIntFitsDouble = function f(b) {\n          if (!f._min) {\n            f._min = Number.MIN_SAFE_INTEGER;\n            f._max = Number.MAX_SAFE_INTEGER;\n          }\n          return b >= f._min && b <= f._max;\n        };\n\n        const isTypedArray = (v) => {\n          return v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)\n            ? v\n            : false;\n        };\n\n        const __SAB =\n          'undefined' === typeof SharedArrayBuffer\n            ? function () {}\n            : SharedArrayBuffer;\n\n        const isSharedTypedArray = (aTypedArray) =>\n          aTypedArray.buffer instanceof __SAB;\n\n        const typedArrayPart = (aTypedArray, begin, end) => {\n          return isSharedTypedArray(aTypedArray)\n            ? aTypedArray.slice(begin, end)\n            : aTypedArray.subarray(begin, end);\n        };\n\n        const isBindableTypedArray = (v) => {\n          return (\n            v &&\n            (v instanceof Uint8Array ||\n              v instanceof Int8Array ||\n              v instanceof ArrayBuffer)\n          );\n        };\n\n        const isSQLableTypedArray = (v) => {\n          return (\n            v &&\n            (v instanceof Uint8Array ||\n              v instanceof Int8Array ||\n              v instanceof ArrayBuffer)\n          );\n        };\n\n        const affirmBindableTypedArray = (v) => {\n          return (\n            isBindableTypedArray(v) ||\n            toss3('Value is not of a supported TypedArray type.')\n          );\n        };\n\n        const utf8Decoder = new TextDecoder('utf-8');\n\n        const typedArrayToString = function (typedArray, begin, end) {\n          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));\n        };\n\n        const flexibleString = function (v) {\n          if (isSQLableTypedArray(v)) {\n            return typedArrayToString(\n              v instanceof ArrayBuffer ? new Uint8Array(v) : v,\n            );\n          } else if (Array.isArray(v)) return v.join('');\n          else if (wasm.isPtr(v)) v = wasm.cstrToJs(v);\n          return v;\n        };\n\n        class WasmAllocError extends Error {\n          constructor(...args) {\n            if (2 === args.length && 'object' === typeof args[1]) {\n              super(...args);\n            } else if (args.length) {\n              super(args.join(' '));\n            } else {\n              super('Allocation failed.');\n            }\n            this.resultCode = capi.SQLITE_NOMEM;\n            this.name = 'WasmAllocError';\n          }\n        }\n\n        WasmAllocError.toss = (...args) => {\n          throw new WasmAllocError(...args);\n        };\n\n        Object.assign(capi, {\n          sqlite3_bind_blob: undefined,\n\n          sqlite3_bind_text: undefined,\n\n          sqlite3_create_function_v2: (\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n            xDestroy,\n          ) => {},\n\n          sqlite3_create_function: (\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n          ) => {},\n\n          sqlite3_create_window_function: (\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xStep,\n            xFinal,\n            xValue,\n            xInverse,\n            xDestroy,\n          ) => {},\n\n          sqlite3_prepare_v3: (\n            dbPtr,\n            sql,\n            sqlByteLen,\n            prepFlags,\n            stmtPtrPtr,\n            strPtrPtr,\n          ) => {},\n\n          sqlite3_prepare_v2: (\n            dbPtr,\n            sql,\n            sqlByteLen,\n            stmtPtrPtr,\n            strPtrPtr,\n          ) => {},\n\n          sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg) => {},\n\n          sqlite3_randomness: (n, outPtr) => {},\n        });\n\n        const util = {\n          affirmBindableTypedArray,\n          flexibleString,\n          bigIntFits32,\n          bigIntFits64,\n          bigIntFitsDouble,\n          isBindableTypedArray,\n          isInt32,\n          isSQLableTypedArray,\n          isTypedArray,\n          typedArrayToString,\n          isUIThread: () =>\n            globalThis.window === globalThis && !!globalThis.document,\n\n          isSharedTypedArray,\n          toss: function (...args) {\n            throw new Error(args.join(' '));\n          },\n          toss3,\n          typedArrayPart,\n\n          affirmDbHeader: function (bytes) {\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            const header = 'SQLite format 3';\n            if (header.length > bytes.byteLength) {\n              toss3('Input does not contain an SQLite3 database header.');\n            }\n            for (let i = 0; i < header.length; ++i) {\n              if (header.charCodeAt(i) !== bytes[i]) {\n                toss3('Input does not contain an SQLite3 database header.');\n              }\n            }\n          },\n\n          affirmIsDb: function (bytes) {\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            const n = bytes.byteLength;\n            if (n < 512 || n % 512 !== 0) {\n              toss3('Byte array size', n, 'is invalid for an SQLite3 db.');\n            }\n            util.affirmDbHeader(bytes);\n          },\n        };\n\n        Object.assign(wasm, {\n          ptrSizeof: config.wasmPtrSizeof || 4,\n\n          ptrIR: config.wasmPtrIR || 'i32',\n\n          bigIntEnabled: !!config.bigIntEnabled,\n\n          exports:\n            config.exports ||\n            toss3('Missing API config.exports (WASM module exports).'),\n\n          memory:\n            config.memory ||\n            config.exports['memory'] ||\n            toss3(\n              'API config object requires a WebAssembly.Memory object',\n              'in either config.exports.memory (exported)',\n              'or config.memory (imported).',\n            ),\n\n          alloc: undefined,\n\n          realloc: undefined,\n\n          dealloc: undefined,\n        });\n\n        wasm.allocFromTypedArray = function (srcTypedArray) {\n          if (srcTypedArray instanceof ArrayBuffer) {\n            srcTypedArray = new Uint8Array(srcTypedArray);\n          }\n          affirmBindableTypedArray(srcTypedArray);\n          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);\n          wasm\n            .heapForSize(srcTypedArray.constructor)\n            .set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);\n          return pRet;\n        };\n\n        {\n          const keyAlloc = config.allocExportName,\n            keyDealloc = config.deallocExportName,\n            keyRealloc = config.reallocExportName;\n          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {\n            const f = wasm.exports[key];\n            if (!(f instanceof Function))\n              toss3('Missing required exports[', key, '] function.');\n          }\n\n          wasm.alloc = function f(n) {\n            return (\n              f.impl(n) ||\n              WasmAllocError.toss('Failed to allocate', n, ' bytes.')\n            );\n          };\n          wasm.alloc.impl = wasm.exports[keyAlloc];\n          wasm.realloc = function f(m, n) {\n            const m2 = f.impl(m, n);\n            return n\n              ? m2 || WasmAllocError.toss('Failed to reallocate', n, ' bytes.')\n              : 0;\n          };\n          wasm.realloc.impl = wasm.exports[keyRealloc];\n          wasm.dealloc = wasm.exports[keyDealloc];\n        }\n\n        wasm.compileOptionUsed = function f(optName) {\n          if (!arguments.length) {\n            if (f._result) return f._result;\n            else if (!f._opt) {\n              f._rx = /^([^=]+)=(.+)/;\n              f._rxInt = /^-?\\d+$/;\n              f._opt = function (opt, rv) {\n                const m = f._rx.exec(opt);\n                rv[0] = m ? m[1] : opt;\n                rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;\n              };\n            }\n            const rc = {},\n              ov = [0, 0];\n            let i = 0,\n              k;\n            while ((k = capi.sqlite3_compileoption_get(i++))) {\n              f._opt(k, ov);\n              rc[ov[0]] = ov[1];\n            }\n            return (f._result = rc);\n          } else if (Array.isArray(optName)) {\n            const rc = {};\n            optName.forEach((v) => {\n              rc[v] = capi.sqlite3_compileoption_used(v);\n            });\n            return rc;\n          } else if ('object' === typeof optName) {\n            Object.keys(optName).forEach((k) => {\n              optName[k] = capi.sqlite3_compileoption_used(k);\n            });\n            return optName;\n          }\n          return 'string' === typeof optName\n            ? !!capi.sqlite3_compileoption_used(optName)\n            : false;\n        };\n\n        wasm.pstack = Object.assign(Object.create(null), {\n          restore: wasm.exports.sqlite3__wasm_pstack_restore,\n\n          alloc: function (n) {\n            if ('string' === typeof n && !(n = wasm.sizeofIR(n))) {\n              WasmAllocError.toss(\n                'Invalid value for pstack.alloc(',\n                arguments[0],\n                ')',\n              );\n            }\n            return (\n              wasm.exports.sqlite3__wasm_pstack_alloc(n) ||\n              WasmAllocError.toss(\n                'Could not allocate',\n                n,\n                'bytes from the pstack.',\n              )\n            );\n          },\n\n          allocChunks: function (n, sz) {\n            if ('string' === typeof sz && !(sz = wasm.sizeofIR(sz))) {\n              WasmAllocError.toss(\n                'Invalid size value for allocChunks(',\n                arguments[1],\n                ')',\n              );\n            }\n            const mem = wasm.pstack.alloc(n * sz);\n            const rc = [];\n            let i = 0,\n              offset = 0;\n            for (; i < n; ++i, offset += sz) rc.push(mem + offset);\n            return rc;\n          },\n\n          allocPtr: (n = 1, safePtrSize = true) => {\n            return 1 === n\n              ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)\n              : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);\n          },\n\n          call: function (f) {\n            const stackPos = wasm.pstack.pointer;\n            try {\n              return f(sqlite3);\n            } finally {\n              wasm.pstack.restore(stackPos);\n            }\n          },\n        });\n        Object.defineProperties(wasm.pstack, {\n          pointer: {\n            configurable: false,\n            iterable: true,\n            writeable: false,\n            get: wasm.exports.sqlite3__wasm_pstack_ptr,\n          },\n\n          quota: {\n            configurable: false,\n            iterable: true,\n            writeable: false,\n            get: wasm.exports.sqlite3__wasm_pstack_quota,\n          },\n\n          remaining: {\n            configurable: false,\n            iterable: true,\n            writeable: false,\n            get: wasm.exports.sqlite3__wasm_pstack_remaining,\n          },\n        });\n\n        capi.sqlite3_randomness = (...args) => {\n          if (\n            1 === args.length &&\n            util.isTypedArray(args[0]) &&\n            1 === args[0].BYTES_PER_ELEMENT\n          ) {\n            const ta = args[0];\n            if (0 === ta.byteLength) {\n              wasm.exports.sqlite3_randomness(0, 0);\n              return ta;\n            }\n            const stack = wasm.pstack.pointer;\n            try {\n              let n = ta.byteLength,\n                offset = 0;\n              const r = wasm.exports.sqlite3_randomness;\n              const heap = wasm.heap8u();\n              const nAlloc = n < 512 ? n : 512;\n              const ptr = wasm.pstack.alloc(nAlloc);\n              do {\n                const j = n > nAlloc ? nAlloc : n;\n                r(j, ptr);\n                ta.set(typedArrayPart(heap, ptr, ptr + j), offset);\n                n -= j;\n                offset += j;\n              } while (n > 0);\n            } catch (e) {\n              console.error(\n                'Highly unexpected (and ignored!) ' +\n                  'exception in sqlite3_randomness():',\n                e,\n              );\n            } finally {\n              wasm.pstack.restore(stack);\n            }\n            return ta;\n          }\n          wasm.exports.sqlite3_randomness(...args);\n        };\n\n        let __wasmfsOpfsDir = undefined;\n\n        capi.sqlite3_wasmfs_opfs_dir = function () {\n          if (undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;\n\n          const pdir = config.wasmfsOpfsDir;\n          if (\n            !pdir ||\n            !globalThis.FileSystemHandle ||\n            !globalThis.FileSystemDirectoryHandle ||\n            !globalThis.FileSystemFileHandle\n          ) {\n            return (__wasmfsOpfsDir = '');\n          }\n          try {\n            if (\n              pdir &&\n              0 ===\n                wasm.xCallWrapped(\n                  'sqlite3__wasm_init_wasmfs',\n                  'i32',\n                  ['string'],\n                  pdir,\n                )\n            ) {\n              return (__wasmfsOpfsDir = pdir);\n            } else {\n              return (__wasmfsOpfsDir = '');\n            }\n          } catch (e) {\n            return (__wasmfsOpfsDir = '');\n          }\n        };\n\n        capi.sqlite3_wasmfs_filename_is_persistent = function (name) {\n          const p = capi.sqlite3_wasmfs_opfs_dir();\n          return p && name ? name.startsWith(p + '/') : false;\n        };\n\n        capi.sqlite3_js_db_uses_vfs = function (pDb, vfsName, dbName = 0) {\n          try {\n            const pK = capi.sqlite3_vfs_find(vfsName);\n            if (!pK) return false;\n            else if (!pDb) {\n              return pK === capi.sqlite3_vfs_find(0) ? pK : false;\n            } else {\n              return pK === capi.sqlite3_js_db_vfs(pDb, dbName) ? pK : false;\n            }\n          } catch (e) {\n            return false;\n          }\n        };\n\n        capi.sqlite3_js_vfs_list = function () {\n          const rc = [];\n          let pVfs = capi.sqlite3_vfs_find(0);\n          while (pVfs) {\n            const oVfs = new capi.sqlite3_vfs(pVfs);\n            rc.push(wasm.cstrToJs(oVfs.$zName));\n            pVfs = oVfs.$pNext;\n            oVfs.dispose();\n          }\n          return rc;\n        };\n\n        capi.sqlite3_js_db_export = function (pDb, schema = 0) {\n          pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);\n          if (!pDb) toss3('Invalid sqlite3* argument.');\n          if (!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');\n          const scope = wasm.scopedAllocPush();\n          let pOut;\n          try {\n            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);\n            const ppOut = pSize + 8;\n\n            const zSchema = schema\n              ? wasm.isPtr(schema)\n                ? schema\n                : wasm.scopedAllocCString('' + schema)\n              : 0;\n            let rc = wasm.exports.sqlite3__wasm_db_serialize(\n              pDb,\n              zSchema,\n              ppOut,\n              pSize,\n              0,\n            );\n            if (rc) {\n              toss3(\n                'Database serialization failed with code',\n                sqlite3.capi.sqlite3_js_rc_str(rc),\n              );\n            }\n            pOut = wasm.peekPtr(ppOut);\n            const nOut = wasm.peek(pSize, 'i64');\n            rc = nOut\n              ? wasm.heap8u().slice(pOut, pOut + Number(nOut))\n              : new Uint8Array();\n            return rc;\n          } finally {\n            if (pOut) wasm.exports.sqlite3_free(pOut);\n            wasm.scopedAllocPop(scope);\n          }\n        };\n\n        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) =>\n          util.sqlite3__wasm_db_vfs(dbPointer, dbName);\n\n        capi.sqlite3_js_aggregate_context = (pCtx, n) => {\n          return (\n            capi.sqlite3_aggregate_context(pCtx, n) ||\n            (n\n              ? WasmAllocError.toss(\n                  'Cannot allocate',\n                  n,\n                  'bytes for sqlite3_aggregate_context()',\n                )\n              : 0)\n          );\n        };\n\n        capi.sqlite3_js_posix_create_file = function (filename, data, dataLen) {\n          let pData;\n          if (data && wasm.isPtr(data)) {\n            pData = data;\n          } else if (\n            data instanceof ArrayBuffer ||\n            data instanceof Uint8Array\n          ) {\n            pData = wasm.allocFromTypedArray(data);\n            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {\n              dataLen = data.byteLength;\n            }\n          } else {\n            SQLite3Error.toss(\n              'Invalid 2nd argument for sqlite3_js_posix_create_file().',\n            );\n          }\n          try {\n            if (!util.isInt32(dataLen) || dataLen < 0) {\n              SQLite3Error.toss(\n                'Invalid 3rd argument for sqlite3_js_posix_create_file().',\n              );\n            }\n            const rc = util.sqlite3__wasm_posix_create_file(\n              filename,\n              pData,\n              dataLen,\n            );\n            if (rc)\n              SQLite3Error.toss(\n                'Creation of file failed with sqlite3 result code',\n                capi.sqlite3_js_rc_str(rc),\n              );\n          } finally {\n            wasm.dealloc(pData);\n          }\n        };\n\n        capi.sqlite3_js_vfs_create_file = function (\n          vfs,\n          filename,\n          data,\n          dataLen,\n        ) {\n          config.warn(\n            'sqlite3_js_vfs_create_file() is deprecated and',\n            'should be avoided because it can lead to C-level crashes.',\n            'See its documentation for alternative options.',\n          );\n          let pData;\n          if (data) {\n            if (wasm.isPtr(data)) {\n              pData = data;\n            } else if (data instanceof ArrayBuffer) {\n              data = new Uint8Array(data);\n            }\n            if (data instanceof Uint8Array) {\n              pData = wasm.allocFromTypedArray(data);\n              if (\n                arguments.length < 4 ||\n                !util.isInt32(dataLen) ||\n                dataLen < 0\n              ) {\n                dataLen = data.byteLength;\n              }\n            } else {\n              SQLite3Error.toss(\n                'Invalid 3rd argument type for sqlite3_js_vfs_create_file().',\n              );\n            }\n          } else {\n            pData = 0;\n          }\n          if (!util.isInt32(dataLen) || dataLen < 0) {\n            wasm.dealloc(pData);\n            SQLite3Error.toss(\n              'Invalid 4th argument for sqlite3_js_vfs_create_file().',\n            );\n          }\n          try {\n            const rc = util.sqlite3__wasm_vfs_create_file(\n              vfs,\n              filename,\n              pData,\n              dataLen,\n            );\n            if (rc)\n              SQLite3Error.toss(\n                'Creation of file failed with sqlite3 result code',\n                capi.sqlite3_js_rc_str(rc),\n              );\n          } finally {\n            wasm.dealloc(pData);\n          }\n        };\n\n        capi.sqlite3_js_sql_to_string = (sql) => {\n          if ('string' === typeof sql) {\n            return sql;\n          }\n          const x = flexibleString(v);\n          return x === v ? undefined : x;\n        };\n\n        if (util.isUIThread()) {\n          const __kvvfsInfo = function (which) {\n            const rc = Object.create(null);\n            rc.prefix = 'kvvfs-' + which;\n            rc.stores = [];\n            if ('session' === which || '' === which)\n              rc.stores.push(globalThis.sessionStorage);\n            if ('local' === which || '' === which)\n              rc.stores.push(globalThis.localStorage);\n            return rc;\n          };\n\n          capi.sqlite3_js_kvvfs_clear = function (which = '') {\n            let rc = 0;\n            const kvinfo = __kvvfsInfo(which);\n            kvinfo.stores.forEach((s) => {\n              const toRm = [];\n              let i;\n              for (i = 0; i < s.length; ++i) {\n                const k = s.key(i);\n                if (k.startsWith(kvinfo.prefix)) toRm.push(k);\n              }\n              toRm.forEach((kk) => s.removeItem(kk));\n              rc += toRm.length;\n            });\n            return rc;\n          };\n\n          capi.sqlite3_js_kvvfs_size = function (which = '') {\n            let sz = 0;\n            const kvinfo = __kvvfsInfo(which);\n            kvinfo.stores.forEach((s) => {\n              let i;\n              for (i = 0; i < s.length; ++i) {\n                const k = s.key(i);\n                if (k.startsWith(kvinfo.prefix)) {\n                  sz += k.length;\n                  sz += s.getItem(k).length;\n                }\n              }\n            });\n            return sz * 2;\n          };\n        }\n\n        capi.sqlite3_db_config = function (pDb, op, ...args) {\n          switch (op) {\n            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:\n            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:\n            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:\n            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:\n            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:\n            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:\n            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:\n            case capi.SQLITE_DBCONFIG_RESET_DATABASE:\n            case capi.SQLITE_DBCONFIG_DEFENSIVE:\n            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:\n            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:\n            case capi.SQLITE_DBCONFIG_DQS_DML:\n            case capi.SQLITE_DBCONFIG_DQS_DDL:\n            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:\n            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:\n            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:\n            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:\n            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:\n            case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE:\n            case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE:\n            case capi.SQLITE_DBCONFIG_ENABLE_COMMENTS:\n              if (!this.ip) {\n                this.ip = wasm.xWrap('sqlite3__wasm_db_config_ip', 'int', [\n                  'sqlite3*',\n                  'int',\n                  'int',\n                  '*',\n                ]);\n              }\n              return this.ip(pDb, op, args[0], args[1] || 0);\n            case capi.SQLITE_DBCONFIG_LOOKASIDE:\n              if (!this.pii) {\n                this.pii = wasm.xWrap('sqlite3__wasm_db_config_pii', 'int', [\n                  'sqlite3*',\n                  'int',\n                  '*',\n                  'int',\n                  'int',\n                ]);\n              }\n              return this.pii(pDb, op, args[0], args[1], args[2]);\n            case capi.SQLITE_DBCONFIG_MAINDBNAME:\n              if (!this.s) {\n                this.s = wasm.xWrap('sqlite3__wasm_db_config_s', 'int', [\n                  'sqlite3*',\n                  'int',\n                  'string:static',\n                ]);\n              }\n              return this.s(pDb, op, args[0]);\n            default:\n              return capi.SQLITE_MISUSE;\n          }\n        }.bind(Object.create(null));\n\n        capi.sqlite3_value_to_js = function (\n          pVal,\n          throwIfCannotConvert = true,\n        ) {\n          let arg;\n          const valType = capi.sqlite3_value_type(pVal);\n          switch (valType) {\n            case capi.SQLITE_INTEGER:\n              if (wasm.bigIntEnabled) {\n                arg = capi.sqlite3_value_int64(pVal);\n                if (util.bigIntFitsDouble(arg)) arg = Number(arg);\n              } else arg = capi.sqlite3_value_double(pVal);\n              break;\n            case capi.SQLITE_FLOAT:\n              arg = capi.sqlite3_value_double(pVal);\n              break;\n            case capi.SQLITE_TEXT:\n              arg = capi.sqlite3_value_text(pVal);\n              break;\n            case capi.SQLITE_BLOB: {\n              const n = capi.sqlite3_value_bytes(pVal);\n              const pBlob = capi.sqlite3_value_blob(pVal);\n              if (n && !pBlob)\n                sqlite3.WasmAllocError.toss(\n                  'Cannot allocate memory for blob argument of',\n                  n,\n                  'byte(s)',\n                );\n              arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;\n              break;\n            }\n            case capi.SQLITE_NULL:\n              arg = null;\n              break;\n            default:\n              if (throwIfCannotConvert) {\n                toss3(\n                  capi.SQLITE_MISMATCH,\n                  'Unhandled sqlite3_value_type():',\n                  valType,\n                );\n              }\n              arg = undefined;\n          }\n          return arg;\n        };\n\n        capi.sqlite3_values_to_js = function (\n          argc,\n          pArgv,\n          throwIfCannotConvert = true,\n        ) {\n          let i;\n          const tgt = [];\n          for (i = 0; i < argc; ++i) {\n            tgt.push(\n              capi.sqlite3_value_to_js(\n                wasm.peekPtr(pArgv + wasm.ptrSizeof * i),\n                throwIfCannotConvert,\n              ),\n            );\n          }\n          return tgt;\n        };\n\n        capi.sqlite3_result_error_js = function (pCtx, e) {\n          if (e instanceof WasmAllocError) {\n            capi.sqlite3_result_error_nomem(pCtx);\n          } else {\n            capi.sqlite3_result_error(pCtx, '' + e, -1);\n          }\n        };\n\n        capi.sqlite3_result_js = function (pCtx, val) {\n          if (val instanceof Error) {\n            capi.sqlite3_result_error_js(pCtx, val);\n            return;\n          }\n          try {\n            switch (typeof val) {\n              case 'undefined':\n                break;\n              case 'boolean':\n                capi.sqlite3_result_int(pCtx, val ? 1 : 0);\n                break;\n              case 'bigint':\n                if (util.bigIntFits32(val)) {\n                  capi.sqlite3_result_int(pCtx, Number(val));\n                } else if (util.bigIntFitsDouble(val)) {\n                  capi.sqlite3_result_double(pCtx, Number(val));\n                } else if (wasm.bigIntEnabled) {\n                  if (util.bigIntFits64(val))\n                    capi.sqlite3_result_int64(pCtx, val);\n                  else\n                    toss3(\n                      'BigInt value',\n                      val.toString(),\n                      'is too BigInt for int64.',\n                    );\n                } else {\n                  toss3('BigInt value', val.toString(), 'is too BigInt.');\n                }\n                break;\n              case 'number': {\n                let f;\n                if (util.isInt32(val)) {\n                  f = capi.sqlite3_result_int;\n                } else if (\n                  wasm.bigIntEnabled &&\n                  Number.isInteger(val) &&\n                  util.bigIntFits64(BigInt(val))\n                ) {\n                  f = capi.sqlite3_result_int64;\n                } else {\n                  f = capi.sqlite3_result_double;\n                }\n                f(pCtx, val);\n                break;\n              }\n              case 'string': {\n                const [p, n] = wasm.allocCString(val, true);\n                capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);\n                break;\n              }\n              case 'object':\n                if (null === val) {\n                  capi.sqlite3_result_null(pCtx);\n                  break;\n                } else if (util.isBindableTypedArray(val)) {\n                  const pBlob = wasm.allocFromTypedArray(val);\n                  capi.sqlite3_result_blob(\n                    pCtx,\n                    pBlob,\n                    val.byteLength,\n                    capi.SQLITE_WASM_DEALLOC,\n                  );\n                  break;\n                }\n\n              default:\n                toss3(\n                  \"Don't not how to handle this UDF result value:\",\n                  typeof val,\n                  val,\n                );\n            }\n          } catch (e) {\n            capi.sqlite3_result_error_js(pCtx, e);\n          }\n        };\n\n        capi.sqlite3_column_js = function (\n          pStmt,\n          iCol,\n          throwIfCannotConvert = true,\n        ) {\n          const v = capi.sqlite3_column_value(pStmt, iCol);\n          return 0 === v\n            ? undefined\n            : capi.sqlite3_value_to_js(v, throwIfCannotConvert);\n        };\n\n        const __newOldValue = function (pObj, iCol, impl) {\n          impl = capi[impl];\n          if (!this.ptr) this.ptr = wasm.allocPtr();\n          else wasm.pokePtr(this.ptr, 0);\n          const rc = impl(pObj, iCol, this.ptr);\n          if (rc)\n            return SQLite3Error.toss(\n              rc,\n              arguments[2] + '() failed with code ' + rc,\n            );\n          const pv = wasm.peekPtr(this.ptr);\n          return pv ? capi.sqlite3_value_to_js(pv, true) : undefined;\n        }.bind(Object.create(null));\n\n        capi.sqlite3_preupdate_new_js = (pDb, iCol) =>\n          __newOldValue(pDb, iCol, 'sqlite3_preupdate_new');\n\n        capi.sqlite3_preupdate_old_js = (pDb, iCol) =>\n          __newOldValue(pDb, iCol, 'sqlite3_preupdate_old');\n\n        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) =>\n          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_new');\n\n        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) =>\n          __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_old');\n\n        const sqlite3 = {\n          WasmAllocError: WasmAllocError,\n          SQLite3Error: SQLite3Error,\n          capi,\n          util,\n          wasm,\n          config,\n\n          version: Object.create(null),\n\n          client: undefined,\n\n          asyncPostInit: async function ff() {\n            if (ff.isReady instanceof Promise) return ff.isReady;\n            let lia = sqlite3ApiBootstrap.initializersAsync;\n            delete sqlite3ApiBootstrap.initializersAsync;\n            const postInit = async () => {\n              if (!sqlite3.__isUnderTest) {\n                delete sqlite3.util;\n\n                delete sqlite3.StructBinder;\n              }\n              return sqlite3;\n            };\n            const catcher = (e) => {\n              config.error('an async sqlite3 initializer failed:', e);\n              throw e;\n            };\n            if (!lia || !lia.length) {\n              return (ff.isReady = postInit().catch(catcher));\n            }\n            lia = lia.map((f) => {\n              return f instanceof Function ? async (x) => f(sqlite3) : f;\n            });\n            lia.push(postInit);\n            let p = Promise.resolve(sqlite3);\n            while (lia.length) p = p.then(lia.shift());\n            return (ff.isReady = p.catch(catcher));\n          },\n\n          scriptInfo: undefined,\n        };\n        try {\n          sqlite3ApiBootstrap.initializers.forEach((f) => {\n            f(sqlite3);\n          });\n        } catch (e) {\n          console.error('sqlite3 bootstrap initializer threw:', e);\n          throw e;\n        }\n        delete sqlite3ApiBootstrap.initializers;\n        sqlite3ApiBootstrap.sqlite3 = sqlite3;\n        return sqlite3;\n      };\n\n      globalThis.sqlite3ApiBootstrap.initializers = [];\n\n      globalThis.sqlite3ApiBootstrap.initializersAsync = [];\n\n      globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);\n\n      globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;\n\n      globalThis.WhWasmUtilInstaller = function (target) {\n        'use strict';\n        if (undefined === target.bigIntEnabled) {\n          target.bigIntEnabled = !!globalThis['BigInt64Array'];\n        }\n\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n\n        if (!target.exports) {\n          Object.defineProperty(target, 'exports', {\n            enumerable: true,\n            configurable: true,\n            get: () => target.instance && target.instance.exports,\n          });\n        }\n\n        const ptrIR = target.pointerIR || 'i32';\n        const ptrSizeof = (target.ptrSizeof =\n          'i32' === ptrIR\n            ? 4\n            : 'i64' === ptrIR\n              ? 8\n              : toss('Unhandled ptrSizeof:', ptrIR));\n\n        const cache = Object.create(null);\n\n        cache.heapSize = 0;\n\n        cache.memory = null;\n\n        cache.freeFuncIndexes = [];\n\n        cache.scopedAlloc = [];\n\n        cache.utf8Decoder = new TextDecoder();\n        cache.utf8Encoder = new TextEncoder('utf-8');\n\n        target.sizeofIR = (n) => {\n          switch (n) {\n            case 'i8':\n              return 1;\n            case 'i16':\n              return 2;\n            case 'i32':\n            case 'f32':\n            case 'float':\n              return 4;\n            case 'i64':\n            case 'f64':\n            case 'double':\n              return 8;\n            case '*':\n              return ptrSizeof;\n            default:\n              return ('' + n).endsWith('*') ? ptrSizeof : undefined;\n          }\n        };\n\n        const heapWrappers = function () {\n          if (!cache.memory) {\n            cache.memory =\n              target.memory instanceof WebAssembly.Memory\n                ? target.memory\n                : target.exports.memory;\n          } else if (cache.heapSize === cache.memory.buffer.byteLength) {\n            return cache;\n          }\n\n          const b = cache.memory.buffer;\n          cache.HEAP8 = new Int8Array(b);\n          cache.HEAP8U = new Uint8Array(b);\n          cache.HEAP16 = new Int16Array(b);\n          cache.HEAP16U = new Uint16Array(b);\n          cache.HEAP32 = new Int32Array(b);\n          cache.HEAP32U = new Uint32Array(b);\n          if (target.bigIntEnabled) {\n            cache.HEAP64 = new BigInt64Array(b);\n            cache.HEAP64U = new BigUint64Array(b);\n          }\n          cache.HEAP32F = new Float32Array(b);\n          cache.HEAP64F = new Float64Array(b);\n          cache.heapSize = b.byteLength;\n          return cache;\n        };\n\n        target.heap8 = () => heapWrappers().HEAP8;\n\n        target.heap8u = () => heapWrappers().HEAP8U;\n\n        target.heap16 = () => heapWrappers().HEAP16;\n\n        target.heap16u = () => heapWrappers().HEAP16U;\n\n        target.heap32 = () => heapWrappers().HEAP32;\n\n        target.heap32u = () => heapWrappers().HEAP32U;\n\n        target.heapForSize = function (n, unsigned = true) {\n          let ctor;\n          const c =\n            cache.memory && cache.heapSize === cache.memory.buffer.byteLength\n              ? cache\n              : heapWrappers();\n          switch (n) {\n            case Int8Array:\n              return c.HEAP8;\n            case Uint8Array:\n              return c.HEAP8U;\n            case Int16Array:\n              return c.HEAP16;\n            case Uint16Array:\n              return c.HEAP16U;\n            case Int32Array:\n              return c.HEAP32;\n            case Uint32Array:\n              return c.HEAP32U;\n            case 8:\n              return unsigned ? c.HEAP8U : c.HEAP8;\n            case 16:\n              return unsigned ? c.HEAP16U : c.HEAP16;\n            case 32:\n              return unsigned ? c.HEAP32U : c.HEAP32;\n            case 64:\n              if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;\n              break;\n            default:\n              if (target.bigIntEnabled) {\n                if (n === globalThis['BigUint64Array']) return c.HEAP64U;\n                else if (n === globalThis['BigInt64Array']) return c.HEAP64;\n                break;\n              }\n          }\n          toss(\n            'Invalid heapForSize() size: expecting 8, 16, 32,',\n            'or (if BigInt is enabled) 64.',\n          );\n        };\n\n        target.functionTable = function () {\n          return target.exports.__indirect_function_table;\n        };\n\n        target.functionEntry = function (fptr) {\n          const ft = target.functionTable();\n          return fptr < ft.length ? ft.get(fptr) : undefined;\n        };\n\n        target.jsFuncToWasm = function f(func, sig) {\n          if (!f._) {\n            f._ = {\n              sigTypes: Object.assign(Object.create(null), {\n                i: 'i32',\n                p: 'i32',\n                P: 'i32',\n                s: 'i32',\n                j: 'i64',\n                f: 'f32',\n                d: 'f64',\n              }),\n\n              typeCodes: Object.assign(Object.create(null), {\n                f64: 0x7c,\n                f32: 0x7d,\n                i64: 0x7e,\n                i32: 0x7f,\n              }),\n\n              uleb128Encode: function (tgt, method, n) {\n                if (n < 128) tgt[method](n);\n                else tgt[method](n % 128 | 128, n >> 7);\n              },\n\n              rxJSig: /^(\\w)\\((\\w*)\\)$/,\n\n              sigParams: function (sig) {\n                const m = f._.rxJSig.exec(sig);\n                return m ? m[2] : sig.substr(1);\n              },\n\n              letterType: (x) =>\n                f._.sigTypes[x] || toss('Invalid signature letter:', x),\n\n              pushSigType: (dest, letter) =>\n                dest.push(f._.typeCodes[f._.letterType(letter)]),\n            };\n          }\n          if ('string' === typeof func) {\n            const x = sig;\n            sig = func;\n            func = x;\n          }\n          const sigParams = f._.sigParams(sig);\n          const wasmCode = [0x01, 0x60];\n          f._.uleb128Encode(wasmCode, 'push', sigParams.length);\n          for (const x of sigParams) f._.pushSigType(wasmCode, x);\n          if ('v' === sig[0]) wasmCode.push(0);\n          else {\n            wasmCode.push(1);\n            f._.pushSigType(wasmCode, sig[0]);\n          }\n          f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);\n          wasmCode.unshift(\n            0x00,\n            0x61,\n            0x73,\n            0x6d,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n          );\n          wasmCode.push(\n            0x02,\n            0x07,\n\n            0x01,\n            0x01,\n            0x65,\n            0x01,\n            0x66,\n            0x00,\n            0x00,\n            0x07,\n            0x05,\n\n            0x01,\n            0x01,\n            0x66,\n            0x00,\n            0x00,\n          );\n          return new WebAssembly.Instance(\n            new WebAssembly.Module(new Uint8Array(wasmCode)),\n            {\n              e: { f: func },\n            },\n          ).exports['f'];\n        };\n\n        const __installFunction = function f(func, sig, scoped) {\n          if (scoped && !cache.scopedAlloc.length) {\n            toss('No scopedAllocPush() scope is active.');\n          }\n          if ('string' === typeof func) {\n            const x = sig;\n            sig = func;\n            func = x;\n          }\n          if ('string' !== typeof sig || !(func instanceof Function)) {\n            toss(\n              'Invalid arguments: expecting (function,signature) ' +\n                'or (signature,function).',\n            );\n          }\n          const ft = target.functionTable();\n          const oldLen = ft.length;\n          let ptr;\n          while (cache.freeFuncIndexes.length) {\n            ptr = cache.freeFuncIndexes.pop();\n            if (ft.get(ptr)) {\n              ptr = null;\n              continue;\n            } else {\n              break;\n            }\n          }\n          if (!ptr) {\n            ptr = oldLen;\n            ft.grow(1);\n          }\n          try {\n            ft.set(ptr, func);\n            if (scoped) {\n              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);\n            }\n            return ptr;\n          } catch (e) {\n            if (!(e instanceof TypeError)) {\n              if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);\n              throw e;\n            }\n          }\n\n          try {\n            const fptr = target.jsFuncToWasm(func, sig);\n            ft.set(ptr, fptr);\n            if (scoped) {\n              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);\n            }\n          } catch (e) {\n            if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);\n            throw e;\n          }\n          return ptr;\n        };\n\n        target.installFunction = (func, sig) =>\n          __installFunction(func, sig, false);\n\n        target.scopedInstallFunction = (func, sig) =>\n          __installFunction(func, sig, true);\n\n        target.uninstallFunction = function (ptr) {\n          if (!ptr && 0 !== ptr) return undefined;\n          const fi = cache.freeFuncIndexes;\n          const ft = target.functionTable();\n          fi.push(ptr);\n          const rc = ft.get(ptr);\n          ft.set(ptr, null);\n          return rc;\n        };\n\n        target.peek = function f(ptr, type = 'i8') {\n          if (type.endsWith('*')) type = ptrIR;\n          const c =\n            cache.memory && cache.heapSize === cache.memory.buffer.byteLength\n              ? cache\n              : heapWrappers();\n          const list = Array.isArray(ptr) ? [] : undefined;\n          let rc;\n          do {\n            if (list) ptr = arguments[0].shift();\n            switch (type) {\n              case 'i1':\n              case 'i8':\n                rc = c.HEAP8[ptr >> 0];\n                break;\n              case 'i16':\n                rc = c.HEAP16[ptr >> 1];\n                break;\n              case 'i32':\n                rc = c.HEAP32[ptr >> 2];\n                break;\n              case 'float':\n              case 'f32':\n                rc = c.HEAP32F[ptr >> 2];\n                break;\n              case 'double':\n              case 'f64':\n                rc = Number(c.HEAP64F[ptr >> 3]);\n                break;\n              case 'i64':\n                if (target.bigIntEnabled) {\n                  rc = BigInt(c.HEAP64[ptr >> 3]);\n                  break;\n                }\n\n              default:\n                toss('Invalid type for peek():', type);\n            }\n            if (list) list.push(rc);\n          } while (list && arguments[0].length);\n          return list || rc;\n        };\n\n        target.poke = function (ptr, value, type = 'i8') {\n          if (type.endsWith('*')) type = ptrIR;\n          const c =\n            cache.memory && cache.heapSize === cache.memory.buffer.byteLength\n              ? cache\n              : heapWrappers();\n          for (const p of Array.isArray(ptr) ? ptr : [ptr]) {\n            switch (type) {\n              case 'i1':\n              case 'i8':\n                c.HEAP8[p >> 0] = value;\n                continue;\n              case 'i16':\n                c.HEAP16[p >> 1] = value;\n                continue;\n              case 'i32':\n                c.HEAP32[p >> 2] = value;\n                continue;\n              case 'float':\n              case 'f32':\n                c.HEAP32F[p >> 2] = value;\n                continue;\n              case 'double':\n              case 'f64':\n                c.HEAP64F[p >> 3] = value;\n                continue;\n              case 'i64':\n                if (c.HEAP64) {\n                  c.HEAP64[p >> 3] = BigInt(value);\n                  continue;\n                }\n\n              default:\n                toss('Invalid type for poke(): ' + type);\n            }\n          }\n          return this;\n        };\n\n        target.peekPtr = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);\n\n        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);\n\n        target.peek8 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i8');\n\n        target.poke8 = (ptr, value) => target.poke(ptr, value, 'i8');\n\n        target.peek16 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i16');\n\n        target.poke16 = (ptr, value) => target.poke(ptr, value, 'i16');\n\n        target.peek32 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i32');\n\n        target.poke32 = (ptr, value) => target.poke(ptr, value, 'i32');\n\n        target.peek64 = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'i64');\n\n        target.poke64 = (ptr, value) => target.poke(ptr, value, 'i64');\n\n        target.peek32f = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f32');\n\n        target.poke32f = (ptr, value) => target.poke(ptr, value, 'f32');\n\n        target.peek64f = (...ptr) =>\n          target.peek(1 === ptr.length ? ptr[0] : ptr, 'f64');\n\n        target.poke64f = (ptr, value) => target.poke(ptr, value, 'f64');\n\n        target.getMemValue = target.peek;\n\n        target.getPtrValue = target.peekPtr;\n\n        target.setMemValue = target.poke;\n\n        target.setPtrValue = target.pokePtr;\n\n        target.isPtr32 = (ptr) =>\n          'number' === typeof ptr && ptr === (ptr | 0) && ptr >= 0;\n\n        target.isPtr = target.isPtr32;\n\n        target.cstrlen = function (ptr) {\n          if (!ptr || !target.isPtr(ptr)) return null;\n          const h = heapWrappers().HEAP8U;\n          let pos = ptr;\n          for (; h[pos] !== 0; ++pos) {}\n          return pos - ptr;\n        };\n\n        const __SAB =\n          'undefined' === typeof SharedArrayBuffer\n            ? function () {}\n            : SharedArrayBuffer;\n        const __utf8Decode = function (arrayBuffer, begin, end) {\n          return cache.utf8Decoder.decode(\n            arrayBuffer.buffer instanceof __SAB\n              ? arrayBuffer.slice(begin, end)\n              : arrayBuffer.subarray(begin, end),\n          );\n        };\n\n        target.cstrToJs = function (ptr) {\n          const n = target.cstrlen(ptr);\n          return n\n            ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n)\n            : null === n\n              ? n\n              : '';\n        };\n\n        target.jstrlen = function (str) {\n          if ('string' !== typeof str) return null;\n          const n = str.length;\n          let len = 0;\n          for (let i = 0; i < n; ++i) {\n            let u = str.charCodeAt(i);\n            if (u >= 0xd800 && u <= 0xdfff) {\n              u =\n                (0x10000 + ((u & 0x3ff) << 10)) | (str.charCodeAt(++i) & 0x3ff);\n            }\n            if (u <= 0x7f) ++len;\n            else if (u <= 0x7ff) len += 2;\n            else if (u <= 0xffff) len += 3;\n            else len += 4;\n          }\n          return len;\n        };\n\n        target.jstrcpy = function (\n          jstr,\n          tgt,\n          offset = 0,\n          maxBytes = -1,\n          addNul = true,\n        ) {\n          if (\n            !tgt ||\n            (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))\n          ) {\n            toss('jstrcpy() target must be an Int8Array or Uint8Array.');\n          }\n          if (maxBytes < 0) maxBytes = tgt.length - offset;\n          if (!(maxBytes > 0) || !(offset >= 0)) return 0;\n          let i = 0,\n            max = jstr.length;\n          const begin = offset,\n            end = offset + maxBytes - (addNul ? 1 : 0);\n          for (; i < max && offset < end; ++i) {\n            let u = jstr.charCodeAt(i);\n            if (u >= 0xd800 && u <= 0xdfff) {\n              u =\n                (0x10000 + ((u & 0x3ff) << 10)) |\n                (jstr.charCodeAt(++i) & 0x3ff);\n            }\n            if (u <= 0x7f) {\n              if (offset >= end) break;\n              tgt[offset++] = u;\n            } else if (u <= 0x7ff) {\n              if (offset + 1 >= end) break;\n              tgt[offset++] = 0xc0 | (u >> 6);\n              tgt[offset++] = 0x80 | (u & 0x3f);\n            } else if (u <= 0xffff) {\n              if (offset + 2 >= end) break;\n              tgt[offset++] = 0xe0 | (u >> 12);\n              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);\n              tgt[offset++] = 0x80 | (u & 0x3f);\n            } else {\n              if (offset + 3 >= end) break;\n              tgt[offset++] = 0xf0 | (u >> 18);\n              tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);\n              tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);\n              tgt[offset++] = 0x80 | (u & 0x3f);\n            }\n          }\n          if (addNul) tgt[offset++] = 0;\n          return offset - begin;\n        };\n\n        target.cstrncpy = function (tgtPtr, srcPtr, n) {\n          if (!tgtPtr || !srcPtr)\n            toss('cstrncpy() does not accept NULL strings.');\n          if (n < 0) n = target.cstrlen(strPtr) + 1;\n          else if (!(n > 0)) return 0;\n          const heap = target.heap8u();\n          let i = 0,\n            ch;\n          for (; i < n && (ch = heap[srcPtr + i]); ++i) {\n            heap[tgtPtr + i] = ch;\n          }\n          if (i < n) heap[tgtPtr + i++] = 0;\n          return i;\n        };\n\n        target.jstrToUintArray = (str, addNul = false) => {\n          return cache.utf8Encoder.encode(addNul ? str + '\\0' : str);\n        };\n\n        const __affirmAlloc = (obj, funcName) => {\n          if (\n            !(obj.alloc instanceof Function) ||\n            !(obj.dealloc instanceof Function)\n          ) {\n            toss(\n              'Object is missing alloc() and/or dealloc() function(s)',\n              'required by',\n              funcName + '().',\n            );\n          }\n        };\n\n        const __allocCStr = function (\n          jstr,\n          returnWithLength,\n          allocator,\n          funcName,\n        ) {\n          __affirmAlloc(target, funcName);\n          if ('string' !== typeof jstr) return null;\n          if (false) {} else {\n            const u = cache.utf8Encoder.encode(jstr),\n              ptr = allocator(u.length + 1),\n              heap = heapWrappers().HEAP8U;\n            heap.set(u, ptr);\n            heap[ptr + u.length] = 0;\n            return returnWithLength ? [ptr, u.length] : ptr;\n          }\n        };\n\n        target.allocCString = (jstr, returnWithLength = false) =>\n          __allocCStr(jstr, returnWithLength, target.alloc, 'allocCString()');\n\n        target.scopedAllocPush = function () {\n          __affirmAlloc(target, 'scopedAllocPush');\n          const a = [];\n          cache.scopedAlloc.push(a);\n          return a;\n        };\n\n        target.scopedAllocPop = function (state) {\n          __affirmAlloc(target, 'scopedAllocPop');\n          const n = arguments.length\n            ? cache.scopedAlloc.indexOf(state)\n            : cache.scopedAlloc.length - 1;\n          if (n < 0) toss('Invalid state object for scopedAllocPop().');\n          if (0 === arguments.length) state = cache.scopedAlloc[n];\n          cache.scopedAlloc.splice(n, 1);\n          for (let p; (p = state.pop()); ) {\n            if (target.functionEntry(p)) {\n              target.uninstallFunction(p);\n            } else target.dealloc(p);\n          }\n        };\n\n        target.scopedAlloc = function (n) {\n          if (!cache.scopedAlloc.length) {\n            toss('No scopedAllocPush() scope is active.');\n          }\n          const p = target.alloc(n);\n          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);\n          return p;\n        };\n\n        Object.defineProperty(target.scopedAlloc, 'level', {\n          configurable: false,\n          enumerable: false,\n          get: () => cache.scopedAlloc.length,\n          set: () => toss(\"The 'active' property is read-only.\"),\n        });\n\n        target.scopedAllocCString = (jstr, returnWithLength = false) =>\n          __allocCStr(\n            jstr,\n            returnWithLength,\n            target.scopedAlloc,\n            'scopedAllocCString()',\n          );\n\n        const __allocMainArgv = function (isScoped, list) {\n          const pList = target[isScoped ? 'scopedAlloc' : 'alloc'](\n            (list.length + 1) * target.ptrSizeof,\n          );\n          let i = 0;\n          list.forEach((e) => {\n            target.pokePtr(\n              pList + target.ptrSizeof * i++,\n              target[isScoped ? 'scopedAllocCString' : 'allocCString']('' + e),\n            );\n          });\n          target.pokePtr(pList + target.ptrSizeof * i, 0);\n          return pList;\n        };\n\n        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);\n\n        target.allocMainArgv = (list) => __allocMainArgv(false, list);\n\n        target.cArgvToJs = (argc, pArgv) => {\n          const list = [];\n          for (let i = 0; i < argc; ++i) {\n            const arg = target.peekPtr(pArgv + target.ptrSizeof * i);\n            list.push(arg ? target.cstrToJs(arg) : null);\n          }\n          return list;\n        };\n\n        target.scopedAllocCall = function (func) {\n          target.scopedAllocPush();\n          try {\n            return func();\n          } finally {\n            target.scopedAllocPop();\n          }\n        };\n\n        const __allocPtr = function (howMany, safePtrSize, method) {\n          __affirmAlloc(target, method);\n          const pIr = safePtrSize ? 'i64' : ptrIR;\n          let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));\n          target.poke(m, 0, pIr);\n          if (1 === howMany) {\n            return m;\n          }\n          const a = [m];\n          for (let i = 1; i < howMany; ++i) {\n            m += safePtrSize ? 8 : ptrSizeof;\n            a[i] = m;\n            target.poke(m, 0, pIr);\n          }\n          return a;\n        };\n\n        target.allocPtr = (howMany = 1, safePtrSize = true) =>\n          __allocPtr(howMany, safePtrSize, 'alloc');\n\n        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) =>\n          __allocPtr(howMany, safePtrSize, 'scopedAlloc');\n\n        target.xGet = function (name) {\n          return (\n            target.exports[name] || toss('Cannot find exported symbol:', name)\n          );\n        };\n\n        const __argcMismatch = (f, n) =>\n          toss(f + '() requires', n, 'argument(s).');\n\n        target.xCall = function (fname, ...args) {\n          const f = fname instanceof Function ? fname : target.xGet(fname);\n          if (!(f instanceof Function))\n            toss('Exported symbol', fname, 'is not a function.');\n          if (f.length !== args.length)\n            __argcMismatch(f === fname ? f.name : fname, f.length);\n          return 2 === arguments.length && Array.isArray(arguments[1])\n            ? f.apply(null, arguments[1])\n            : f.apply(null, args);\n        };\n\n        cache.xWrap = Object.create(null);\n        cache.xWrap.convert = Object.create(null);\n\n        cache.xWrap.convert.arg = new Map();\n\n        cache.xWrap.convert.result = new Map();\n        const xArg = cache.xWrap.convert.arg,\n          xResult = cache.xWrap.convert.result;\n\n        if (target.bigIntEnabled) {\n          xArg.set('i64', (i) => BigInt(i));\n        }\n        const __xArgPtr =\n          'i32' === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);\n        xArg\n          .set('i32', __xArgPtr)\n          .set('i16', (i) => (i | 0) & 0xffff)\n          .set('i8', (i) => (i | 0) & 0xff)\n          .set('f32', (i) => Number(i).valueOf())\n          .set('float', xArg.get('f32'))\n          .set('f64', xArg.get('f32'))\n          .set('double', xArg.get('f64'))\n          .set('int', xArg.get('i32'))\n          .set('null', (i) => i)\n          .set(null, xArg.get('null'))\n          .set('**', __xArgPtr)\n          .set('*', __xArgPtr);\n        xResult\n          .set('*', __xArgPtr)\n          .set('pointer', __xArgPtr)\n          .set('number', (v) => Number(v))\n          .set('void', (v) => undefined)\n          .set('null', (v) => v)\n          .set(null, xResult.get('null'));\n\n        {\n          const copyToResult = [\n            'i8',\n            'i16',\n            'i32',\n            'int',\n            'f32',\n            'float',\n            'f64',\n            'double',\n          ];\n          if (target.bigIntEnabled) copyToResult.push('i64');\n          const adaptPtr = xArg.get(ptrIR);\n          for (const t of copyToResult) {\n            xArg.set(t + '*', adaptPtr);\n            xResult.set(t + '*', adaptPtr);\n            xResult.set(t, xArg.get(t) || toss('Missing arg converter:', t));\n          }\n        }\n\n        const __xArgString = function (v) {\n          if ('string' === typeof v) return target.scopedAllocCString(v);\n          return v ? __xArgPtr(v) : null;\n        };\n        xArg\n          .set('string', __xArgString)\n          .set('utf8', __xArgString)\n          .set('pointer', __xArgString);\n\n        xResult\n          .set('string', (i) => target.cstrToJs(i))\n          .set('utf8', xResult.get('string'))\n          .set('string:dealloc', (i) => {\n            try {\n              return i ? target.cstrToJs(i) : null;\n            } finally {\n              target.dealloc(i);\n            }\n          })\n          .set('utf8:dealloc', xResult.get('string:dealloc'))\n          .set('json', (i) => JSON.parse(target.cstrToJs(i)))\n          .set('json:dealloc', (i) => {\n            try {\n              return i ? JSON.parse(target.cstrToJs(i)) : null;\n            } finally {\n              target.dealloc(i);\n            }\n          });\n\n        const AbstractArgAdapter = class {\n          constructor(opt) {\n            this.name = opt.name || 'unnamed adapter';\n          }\n\n          convertArg(v, argv, argIndex) {\n            toss('AbstractArgAdapter must be subclassed.');\n          }\n        };\n\n        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {\n          constructor(opt) {\n            super(opt);\n            if (xArg.FuncPtrAdapter.warnOnUse) {\n              console.warn(\n                'xArg.FuncPtrAdapter is an internal-only API',\n                'and is not intended to be invoked from',\n                'client-level code. Invoked with:',\n                opt,\n              );\n            }\n            this.name = opt.name || 'unnamed';\n            this.signature = opt.signature;\n            if (opt.contextKey instanceof Function) {\n              this.contextKey = opt.contextKey;\n              if (!opt.bindScope) opt.bindScope = 'context';\n            }\n            this.bindScope =\n              opt.bindScope ||\n              toss(\n                'FuncPtrAdapter options requires a bindScope (explicit or implied).',\n              );\n            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {\n              toss(\n                'Invalid options.bindScope (' +\n                  opt.bindMod +\n                  ') for FuncPtrAdapter. ' +\n                  'Expecting one of: (' +\n                  FuncPtrAdapter.bindScopes.join(', ') +\n                  ')',\n              );\n            }\n            this.isTransient = 'transient' === this.bindScope;\n            this.isContext = 'context' === this.bindScope;\n            this.isPermanent = 'permanent' === this.bindScope;\n            this.singleton = 'singleton' === this.bindScope ? [] : undefined;\n\n            this.callProxy =\n              opt.callProxy instanceof Function ? opt.callProxy : undefined;\n          }\n\n          contextKey(argv, argIndex) {\n            return this;\n          }\n\n          contextMap(key) {\n            const cm = this.__cmap || (this.__cmap = new Map());\n            let rc = cm.get(key);\n            if (undefined === rc) cm.set(key, (rc = []));\n            return rc;\n          }\n\n          convertArg(v, argv, argIndex) {\n            let pair = this.singleton;\n            if (!pair && this.isContext) {\n              pair = this.contextMap(this.contextKey(argv, argIndex));\n            }\n            if (pair && pair[0] === v) return pair[1];\n            if (v instanceof Function) {\n              if (this.callProxy) v = this.callProxy(v);\n              const fp = __installFunction(v, this.signature, this.isTransient);\n              if (FuncPtrAdapter.debugFuncInstall) {\n                FuncPtrAdapter.debugOut(\n                  'FuncPtrAdapter installed',\n                  this,\n                  this.contextKey(argv, argIndex),\n                  '@' + fp,\n                  v,\n                );\n              }\n              if (pair) {\n                if (pair[1]) {\n                  if (FuncPtrAdapter.debugFuncInstall) {\n                    FuncPtrAdapter.debugOut(\n                      'FuncPtrAdapter uninstalling',\n                      this,\n                      this.contextKey(argv, argIndex),\n                      '@' + pair[1],\n                      v,\n                    );\n                  }\n                  try {\n                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(\n                      pair[1],\n                    );\n                  } catch (e) {}\n                }\n                pair[0] = v;\n                pair[1] = fp;\n              }\n              return fp;\n            } else if (target.isPtr(v) || null === v || undefined === v) {\n              if (pair && pair[1] && pair[1] !== v) {\n                if (FuncPtrAdapter.debugFuncInstall) {\n                  FuncPtrAdapter.debugOut(\n                    'FuncPtrAdapter uninstalling',\n                    this,\n                    this.contextKey(argv, argIndex),\n                    '@' + pair[1],\n                    v,\n                  );\n                }\n                try {\n                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);\n                } catch (e) {}\n                pair[0] = pair[1] = v | 0;\n              }\n              return v || 0;\n            } else {\n              throw new TypeError(\n                'Invalid FuncPtrAdapter argument type. ' +\n                  'Expecting a function pointer or a ' +\n                  (this.name ? this.name + ' ' : '') +\n                  'function matching signature ' +\n                  this.signature +\n                  '.',\n              );\n            }\n          }\n        };\n\n        xArg.FuncPtrAdapter.warnOnUse = false;\n\n        xArg.FuncPtrAdapter.debugFuncInstall = false;\n\n        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);\n\n        xArg.FuncPtrAdapter.bindScopes = [\n          'transient',\n          'context',\n          'singleton',\n          'permanent',\n        ];\n\n        const __xArgAdapterCheck = (t) =>\n          xArg.get(t) || toss('Argument adapter not found:', t);\n\n        const __xResultAdapterCheck = (t) =>\n          xResult.get(t) || toss('Result adapter not found:', t);\n\n        cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);\n\n        cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);\n\n        cache.xWrap.convertResult = (t, v) =>\n          null === t ? v : t ? __xResultAdapterCheck(t)(v) : undefined;\n\n        cache.xWrap.convertResultNoCheck = (t, v) =>\n          null === t ? v : t ? xResult.get(t)(v) : undefined;\n\n        target.xWrap = function (fArg, resultType, ...argTypes) {\n          if (3 === arguments.length && Array.isArray(arguments[2])) {\n            argTypes = arguments[2];\n          }\n          if (target.isPtr(fArg)) {\n            fArg =\n              target.functionEntry(fArg) ||\n              toss('Function pointer not found in WASM function table.');\n          }\n          const fIsFunc = fArg instanceof Function;\n          const xf = fIsFunc ? fArg : target.xGet(fArg);\n          if (fIsFunc) fArg = xf.name || 'unnamed function';\n          if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);\n          if (null === resultType && 0 === xf.length) {\n            return xf;\n          }\n          if (undefined !== resultType && null !== resultType)\n            __xResultAdapterCheck(resultType);\n          for (const t of argTypes) {\n            if (t instanceof AbstractArgAdapter)\n              xArg.set(t, (...args) => t.convertArg(...args));\n            else __xArgAdapterCheck(t);\n          }\n          const cxw = cache.xWrap;\n          if (0 === xf.length) {\n            return (...args) =>\n              args.length\n                ? __argcMismatch(fArg, xf.length)\n                : cxw.convertResult(resultType, xf.call(null));\n          }\n          return function (...args) {\n            if (args.length !== xf.length) __argcMismatch(fArg, xf.length);\n            const scope = target.scopedAllocPush();\n            try {\n              let i = 0;\n              for (; i < args.length; ++i)\n                args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);\n              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));\n            } finally {\n              target.scopedAllocPop(scope);\n            }\n          };\n        };\n\n        const __xAdapter = function (\n          func,\n          argc,\n          typeName,\n          adapter,\n          modeName,\n          xcvPart,\n        ) {\n          if ('string' === typeof typeName) {\n            if (1 === argc) return xcvPart.get(typeName);\n            else if (2 === argc) {\n              if (!adapter) {\n                xcvPart.delete(typeName);\n                return func;\n              } else if (!(adapter instanceof Function)) {\n                toss(modeName, 'requires a function argument.');\n              }\n              xcvPart.set(typeName, adapter);\n              return func;\n            }\n          }\n          toss('Invalid arguments to', modeName);\n        };\n\n        target.xWrap.resultAdapter = function f(typeName, adapter) {\n          return __xAdapter(\n            f,\n            arguments.length,\n            typeName,\n            adapter,\n            'resultAdapter()',\n            xResult,\n          );\n        };\n\n        target.xWrap.argAdapter = function f(typeName, adapter) {\n          return __xAdapter(\n            f,\n            arguments.length,\n            typeName,\n            adapter,\n            'argAdapter()',\n            xArg,\n          );\n        };\n\n        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;\n\n        target.xCallWrapped = function (fArg, resultType, argTypes, ...args) {\n          if (Array.isArray(arguments[3])) args = arguments[3];\n          return target\n            .xWrap(fArg, resultType, argTypes || [])\n            .apply(null, args || []);\n        };\n\n        target.xWrap.testConvertArg = cache.xWrap.convertArg;\n\n        target.xWrap.testConvertResult = cache.xWrap.convertResult;\n\n        return target;\n      };\n\n      globalThis.WhWasmUtilInstaller.yawl = function (config) {\n        const wfetch = () => fetch(config.uri, { credentials: 'same-origin' });\n        const wui = this;\n        const finalThen = function (arg) {\n          if (config.wasmUtilTarget) {\n            const toss = (...args) => {\n              throw new Error(args.join(' '));\n            };\n            const tgt = config.wasmUtilTarget;\n            tgt.module = arg.module;\n            tgt.instance = arg.instance;\n\n            if (!tgt.instance.exports.memory) {\n              tgt.memory =\n                (config.imports &&\n                  config.imports.env &&\n                  config.imports.env.memory) ||\n                toss(\"Missing 'memory' object!\");\n            }\n            if (!tgt.alloc && arg.instance.exports.malloc) {\n              const exports = arg.instance.exports;\n              tgt.alloc = function (n) {\n                return (\n                  exports.malloc(n) || toss('Allocation of', n, 'bytes failed.')\n                );\n              };\n              tgt.dealloc = function (m) {\n                exports.free(m);\n              };\n            }\n            wui(tgt);\n          }\n          if (config.onload) config.onload(arg, config);\n          return arg;\n        };\n        const loadWasm = WebAssembly.instantiateStreaming\n          ? function loadWasmStreaming() {\n              return WebAssembly.instantiateStreaming(\n                wfetch(),\n                config.imports || {},\n              ).then(finalThen);\n            }\n          : function loadWasmOldSchool() {\n              return wfetch()\n                .then((response) => response.arrayBuffer())\n                .then((bytes) =>\n                  WebAssembly.instantiate(bytes, config.imports || {}),\n                )\n                .then(finalThen);\n            };\n        return loadWasm;\n      }.bind(globalThis.WhWasmUtilInstaller);\n\n      ('use strict');\n      globalThis.Jaccwabyt = function StructBinderFactory(config) {\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n\n        if (\n          !(config.heap instanceof WebAssembly.Memory) &&\n          !(config.heap instanceof Function)\n        ) {\n          toss(\n            'config.heap must be WebAssembly.Memory instance or a function.',\n          );\n        }\n        ['alloc', 'dealloc'].forEach(function (k) {\n          config[k] instanceof Function ||\n            toss(\"Config option '\" + k + \"' must be a function.\");\n        });\n        const SBF = StructBinderFactory;\n        const heap =\n            config.heap instanceof Function\n              ? config.heap\n              : () => new Uint8Array(config.heap.buffer),\n          alloc = config.alloc,\n          dealloc = config.dealloc,\n          log = config.log || console.log.bind(console),\n          memberPrefix = config.memberPrefix || '',\n          memberSuffix = config.memberSuffix || '',\n          bigIntEnabled =\n            undefined === config.bigIntEnabled\n              ? !!globalThis['BigInt64Array']\n              : !!config.bigIntEnabled,\n          BigInt = globalThis['BigInt'],\n          BigInt64Array = globalThis['BigInt64Array'],\n          ptrSizeof = config.ptrSizeof || 4,\n          ptrIR = config.ptrIR || 'i32';\n        if (!SBF.debugFlags) {\n          SBF.__makeDebugFlags = function (deriveFrom = null) {\n            if (deriveFrom && deriveFrom.__flags)\n              deriveFrom = deriveFrom.__flags;\n            const f = function f(flags) {\n              if (0 === arguments.length) {\n                return f.__flags;\n              }\n              if (flags < 0) {\n                delete f.__flags.getter;\n                delete f.__flags.setter;\n                delete f.__flags.alloc;\n                delete f.__flags.dealloc;\n              } else {\n                f.__flags.getter = 0 !== (0x01 & flags);\n                f.__flags.setter = 0 !== (0x02 & flags);\n                f.__flags.alloc = 0 !== (0x04 & flags);\n                f.__flags.dealloc = 0 !== (0x08 & flags);\n              }\n              return f._flags;\n            };\n            Object.defineProperty(f, '__flags', {\n              iterable: false,\n              writable: false,\n              value: Object.create(deriveFrom),\n            });\n            if (!deriveFrom) f(0);\n            return f;\n          };\n          SBF.debugFlags = SBF.__makeDebugFlags();\n        }\n\n        const isLittleEndian = (function () {\n          const buffer = new ArrayBuffer(2);\n          new DataView(buffer).setInt16(0, 256, true);\n\n          return new Int16Array(buffer)[0] === 256;\n        })();\n\n        const isFuncSig = (s) => '(' === s[1];\n\n        const isPtrSig = (s) => 'p' === s || 'P' === s;\n        const isAutoPtrSig = (s) => 'P' === s;\n        const sigLetter = (s) => (isFuncSig(s) ? 'p' : s[0]);\n\n        const sigIR = function (s) {\n          switch (sigLetter(s)) {\n            case 'c':\n            case 'C':\n              return 'i8';\n            case 'i':\n              return 'i32';\n            case 'p':\n            case 'P':\n            case 's':\n              return ptrIR;\n            case 'j':\n              return 'i64';\n            case 'f':\n              return 'float';\n            case 'd':\n              return 'double';\n          }\n          toss('Unhandled signature IR:', s);\n        };\n\n        const affirmBigIntArray = BigInt64Array\n          ? () => true\n          : () => toss('BigInt64Array is not available.');\n\n        const sigDVGetter = function (s) {\n          switch (sigLetter(s)) {\n            case 'p':\n            case 'P':\n            case 's': {\n              switch (ptrSizeof) {\n                case 4:\n                  return 'getInt32';\n                case 8:\n                  return affirmBigIntArray() && 'getBigInt64';\n              }\n              break;\n            }\n            case 'i':\n              return 'getInt32';\n            case 'c':\n              return 'getInt8';\n            case 'C':\n              return 'getUint8';\n            case 'j':\n              return affirmBigIntArray() && 'getBigInt64';\n            case 'f':\n              return 'getFloat32';\n            case 'd':\n              return 'getFloat64';\n          }\n          toss('Unhandled DataView getter for signature:', s);\n        };\n\n        const sigDVSetter = function (s) {\n          switch (sigLetter(s)) {\n            case 'p':\n            case 'P':\n            case 's': {\n              switch (ptrSizeof) {\n                case 4:\n                  return 'setInt32';\n                case 8:\n                  return affirmBigIntArray() && 'setBigInt64';\n              }\n              break;\n            }\n            case 'i':\n              return 'setInt32';\n            case 'c':\n              return 'setInt8';\n            case 'C':\n              return 'setUint8';\n            case 'j':\n              return affirmBigIntArray() && 'setBigInt64';\n            case 'f':\n              return 'setFloat32';\n            case 'd':\n              return 'setFloat64';\n          }\n          toss('Unhandled DataView setter for signature:', s);\n        };\n\n        const sigDVSetWrapper = function (s) {\n          switch (sigLetter(s)) {\n            case 'i':\n            case 'f':\n            case 'c':\n            case 'C':\n            case 'd':\n              return Number;\n            case 'j':\n              return affirmBigIntArray() && BigInt;\n            case 'p':\n            case 'P':\n            case 's':\n              switch (ptrSizeof) {\n                case 4:\n                  return Number;\n                case 8:\n                  return affirmBigIntArray() && BigInt;\n              }\n              break;\n          }\n          toss('Unhandled DataView set wrapper for signature:', s);\n        };\n\n        const sPropName = (s, k) => s + '::' + k;\n\n        const __propThrowOnSet = function (structName, propName) {\n          return () => toss(sPropName(structName, propName), 'is read-only.');\n        };\n\n        const __instancePointerMap = new WeakMap();\n\n        const xPtrPropName = '(pointer-is-external)';\n\n        const __freeStruct = function (ctor, obj, m) {\n          if (!m) m = __instancePointerMap.get(obj);\n          if (m) {\n            __instancePointerMap.delete(obj);\n            if (Array.isArray(obj.ondispose)) {\n              let x;\n              while ((x = obj.ondispose.shift())) {\n                try {\n                  if (x instanceof Function) x.call(obj);\n                  else if (x instanceof StructType) x.dispose();\n                  else if ('number' === typeof x) dealloc(x);\n                } catch (e) {\n                  console.warn(\n                    'ondispose() for',\n                    ctor.structName,\n                    '@',\n                    m,\n                    'threw. NOT propagating it.',\n                    e,\n                  );\n                }\n              }\n            } else if (obj.ondispose instanceof Function) {\n              try {\n                obj.ondispose();\n              } catch (e) {\n                console.warn(\n                  'ondispose() for',\n                  ctor.structName,\n                  '@',\n                  m,\n                  'threw. NOT propagating it.',\n                  e,\n                );\n              }\n            }\n            delete obj.ondispose;\n            if (ctor.debugFlags.__flags.dealloc) {\n              log(\n                'debug.dealloc:',\n                obj[xPtrPropName] ? 'EXTERNAL' : '',\n                ctor.structName,\n                'instance:',\n                ctor.structInfo.sizeof,\n                'bytes @' + m,\n              );\n            }\n            if (!obj[xPtrPropName]) dealloc(m);\n          }\n        };\n\n        const rop = (v) => {\n          return {\n            configurable: false,\n            writable: false,\n            iterable: false,\n            value: v,\n          };\n        };\n\n        const __allocStruct = function (ctor, obj, m) {\n          let fill = !m;\n          if (m) Object.defineProperty(obj, xPtrPropName, rop(m));\n          else {\n            m = alloc(ctor.structInfo.sizeof);\n            if (!m) toss('Allocation of', ctor.structName, 'structure failed.');\n          }\n          try {\n            if (ctor.debugFlags.__flags.alloc) {\n              log(\n                'debug.alloc:',\n                fill ? '' : 'EXTERNAL',\n                ctor.structName,\n                'instance:',\n                ctor.structInfo.sizeof,\n                'bytes @' + m,\n              );\n            }\n            if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);\n            __instancePointerMap.set(obj, m);\n          } catch (e) {\n            __freeStruct(ctor, obj, m);\n            throw e;\n          }\n        };\n\n        const __memoryDump = function () {\n          const p = this.pointer;\n          return p\n            ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof))\n            : null;\n        };\n\n        const __memberKey = (k) => memberPrefix + k + memberSuffix;\n        const __memberKeyProp = rop(__memberKey);\n\n        const __lookupMember = function (\n          structInfo,\n          memberName,\n          tossIfNotFound = true,\n        ) {\n          let m = structInfo.members[memberName];\n          if (!m && (memberPrefix || memberSuffix)) {\n            for (const v of Object.values(structInfo.members)) {\n              if (v.key === memberName) {\n                m = v;\n                break;\n              }\n            }\n            if (!m && tossIfNotFound) {\n              toss(\n                sPropName(structInfo.name, memberName),\n                'is not a mapped struct member.',\n              );\n            }\n          }\n          return m;\n        };\n\n        const __memberSignature = function f(\n          obj,\n          memberName,\n          emscriptenFormat = false,\n        ) {\n          if (!f._)\n            f._ = (x) =>\n              x.replace(/[^vipPsjrdcC]/g, '').replace(/[pPscC]/g, 'i');\n          const m = __lookupMember(obj.structInfo, memberName, true);\n          return emscriptenFormat ? f._(m.signature) : m.signature;\n        };\n\n        const __ptrPropDescriptor = {\n          configurable: false,\n          enumerable: false,\n          get: function () {\n            return __instancePointerMap.get(this);\n          },\n          set: () => toss(\"Cannot assign the 'pointer' property of a struct.\"),\n        };\n\n        const __structMemberKeys = rop(function () {\n          const a = [];\n          for (const k of Object.keys(this.structInfo.members)) {\n            a.push(this.memberKey(k));\n          }\n          return a;\n        });\n\n        const __utf8Decoder = new TextDecoder('utf-8');\n        const __utf8Encoder = new TextEncoder();\n\n        const __SAB =\n          'undefined' === typeof SharedArrayBuffer\n            ? function () {}\n            : SharedArrayBuffer;\n        const __utf8Decode = function (arrayBuffer, begin, end) {\n          return __utf8Decoder.decode(\n            arrayBuffer.buffer instanceof __SAB\n              ? arrayBuffer.slice(begin, end)\n              : arrayBuffer.subarray(begin, end),\n          );\n        };\n\n        const __memberIsString = function (\n          obj,\n          memberName,\n          tossIfNotFound = false,\n        ) {\n          const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);\n          return m && 1 === m.signature.length && 's' === m.signature[0]\n            ? m\n            : false;\n        };\n\n        const __affirmCStringSignature = function (member) {\n          if ('s' === member.signature) return;\n          toss(\n            'Invalid member type signature for C-string value:',\n            JSON.stringify(member),\n          );\n        };\n\n        const __memberToJsString = function f(obj, memberName) {\n          const m = __lookupMember(obj.structInfo, memberName, true);\n          __affirmCStringSignature(m);\n          const addr = obj[m.key];\n\n          if (!addr) return null;\n          let pos = addr;\n          const mem = heap();\n          for (; mem[pos] !== 0; ++pos) {}\n\n          return addr === pos ? '' : __utf8Decode(mem, addr, pos);\n        };\n\n        const __addOnDispose = function (obj, ...v) {\n          if (obj.ondispose) {\n            if (!Array.isArray(obj.ondispose)) {\n              obj.ondispose = [obj.ondispose];\n            }\n          } else {\n            obj.ondispose = [];\n          }\n          obj.ondispose.push(...v);\n        };\n\n        const __allocCString = function (str) {\n          const u = __utf8Encoder.encode(str);\n          const mem = alloc(u.length + 1);\n          if (!mem) toss('Allocation error while duplicating string:', str);\n          const h = heap();\n\n          h.set(u, mem);\n          h[mem + u.length] = 0;\n\n          return mem;\n        };\n\n        const __setMemberCString = function (obj, memberName, str) {\n          const m = __lookupMember(obj.structInfo, memberName, true);\n          __affirmCStringSignature(m);\n\n          const mem = __allocCString(str);\n          obj[m.key] = mem;\n          __addOnDispose(obj, mem);\n          return obj;\n        };\n\n        const StructType = function ctor(structName, structInfo) {\n          if (arguments[2] !== rop) {\n            toss(\n              'Do not call the StructType constructor',\n              'from client-level code.',\n            );\n          }\n          Object.defineProperties(this, {\n            structName: rop(structName),\n            structInfo: rop(structInfo),\n          });\n        };\n\n        StructType.prototype = Object.create(null, {\n          dispose: rop(function () {\n            __freeStruct(this.constructor, this);\n          }),\n          lookupMember: rop(function (memberName, tossIfNotFound = true) {\n            return __lookupMember(this.structInfo, memberName, tossIfNotFound);\n          }),\n          memberToJsString: rop(function (memberName) {\n            return __memberToJsString(this, memberName);\n          }),\n          memberIsString: rop(function (memberName, tossIfNotFound = true) {\n            return __memberIsString(this, memberName, tossIfNotFound);\n          }),\n          memberKey: __memberKeyProp,\n          memberKeys: __structMemberKeys,\n          memberSignature: rop(function (memberName, emscriptenFormat = false) {\n            return __memberSignature(this, memberName, emscriptenFormat);\n          }),\n          memoryDump: rop(__memoryDump),\n          pointer: __ptrPropDescriptor,\n          setMemberCString: rop(function (memberName, str) {\n            return __setMemberCString(this, memberName, str);\n          }),\n        });\n\n        Object.assign(StructType.prototype, {\n          addOnDispose: function (...v) {\n            __addOnDispose(this, ...v);\n            return this;\n          },\n        });\n\n        Object.defineProperties(StructType, {\n          allocCString: rop(__allocCString),\n          isA: rop((v) => v instanceof StructType),\n          hasExternalPointer: rop(\n            (v) => v instanceof StructType && !!v[xPtrPropName],\n          ),\n          memberKey: __memberKeyProp,\n        });\n\n        const isNumericValue = (v) =>\n          Number.isFinite(v) || v instanceof (BigInt || Number);\n\n        const makeMemberWrapper = function f(ctor, name, descr) {\n          if (!f._) {\n            f._ = { getters: {}, setters: {}, sw: {} };\n            const a = ['i', 'c', 'C', 'p', 'P', 's', 'f', 'd', 'v()'];\n            if (bigIntEnabled) a.push('j');\n            a.forEach(function (v) {\n              f._.getters[v] = sigDVGetter(v);\n              f._.setters[v] = sigDVSetter(v);\n              f._.sw[v] = sigDVSetWrapper(v);\n            });\n            const rxSig1 = /^[ipPsjfdcC]$/,\n              rxSig2 = /^[vipPsjfdcC]\\([ipPsjfdcC]*\\)$/;\n            f.sigCheck = function (obj, name, key, sig) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                toss(obj.structName, 'already has a property named', key + '.');\n              }\n              rxSig1.test(sig) ||\n                rxSig2.test(sig) ||\n                toss(\n                  'Malformed signature for',\n                  sPropName(obj.structName, name) + ':',\n                  sig,\n                );\n            };\n          }\n          const key = ctor.memberKey(name);\n          f.sigCheck(ctor.prototype, name, key, descr.signature);\n          descr.key = key;\n          descr.name = name;\n          const sigGlyph = sigLetter(descr.signature);\n          const xPropName = sPropName(ctor.prototype.structName, key);\n          const dbg = ctor.prototype.debugFlags.__flags;\n\n          const prop = Object.create(null);\n          prop.configurable = false;\n          prop.enumerable = false;\n          prop.get = function () {\n            if (dbg.getter) {\n              log(\n                'debug.getter:',\n                f._.getters[sigGlyph],\n                'for',\n                sigIR(sigGlyph),\n                xPropName,\n                '@',\n                this.pointer,\n                '+',\n                descr.offset,\n                'sz',\n                descr.sizeof,\n              );\n            }\n            let rc = new DataView(\n              heap().buffer,\n              this.pointer + descr.offset,\n              descr.sizeof,\n            )[f._.getters[sigGlyph]](0, isLittleEndian);\n            if (dbg.getter) log('debug.getter:', xPropName, 'result =', rc);\n            return rc;\n          };\n          if (descr.readOnly) {\n            prop.set = __propThrowOnSet(ctor.prototype.structName, key);\n          } else {\n            prop.set = function (v) {\n              if (dbg.setter) {\n                log(\n                  'debug.setter:',\n                  f._.setters[sigGlyph],\n                  'for',\n                  sigIR(sigGlyph),\n                  xPropName,\n                  '@',\n                  this.pointer,\n                  '+',\n                  descr.offset,\n                  'sz',\n                  descr.sizeof,\n                  v,\n                );\n              }\n              if (!this.pointer) {\n                toss('Cannot set struct property on disposed instance.');\n              }\n              if (null === v) v = 0;\n              else\n                while (!isNumericValue(v)) {\n                  if (\n                    isAutoPtrSig(descr.signature) &&\n                    v instanceof StructType\n                  ) {\n                    v = v.pointer || 0;\n                    if (dbg.setter)\n                      log('debug.setter:', xPropName, 'resolved to', v);\n                    break;\n                  }\n                  toss('Invalid value for pointer-type', xPropName + '.');\n                }\n              new DataView(\n                heap().buffer,\n                this.pointer + descr.offset,\n                descr.sizeof,\n              )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);\n            };\n          }\n          Object.defineProperty(ctor.prototype, key, prop);\n        };\n\n        const StructBinder = function StructBinder(structName, structInfo) {\n          if (1 === arguments.length) {\n            structInfo = structName;\n            structName = structInfo.name;\n          } else if (!structInfo.name) {\n            structInfo.name = structName;\n          }\n          if (!structName) toss('Struct name is required.');\n          let lastMember = false;\n          Object.keys(structInfo.members).forEach((k) => {\n            const m = structInfo.members[k];\n            if (!m.sizeof) toss(structName, 'member', k, 'is missing sizeof.');\n            else if (m.sizeof === 1) {\n              m.signature === 'c' ||\n                m.signature === 'C' ||\n                toss(\n                  'Unexpected sizeof==1 member',\n                  sPropName(structInfo.name, k),\n                  'with signature',\n                  m.signature,\n                );\n            } else {\n              if (0 !== m.sizeof % 4) {\n                console.warn(\n                  'Invalid struct member description =',\n                  m,\n                  'from',\n                  structInfo,\n                );\n                toss(\n                  structName,\n                  'member',\n                  k,\n                  'sizeof is not aligned. sizeof=' + m.sizeof,\n                );\n              }\n              if (0 !== m.offset % 4) {\n                console.warn(\n                  'Invalid struct member description =',\n                  m,\n                  'from',\n                  structInfo,\n                );\n                toss(\n                  structName,\n                  'member',\n                  k,\n                  'offset is not aligned. offset=' + m.offset,\n                );\n              }\n            }\n            if (!lastMember || lastMember.offset < m.offset) lastMember = m;\n          });\n          if (!lastMember) toss('No member property descriptions found.');\n          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {\n            toss(\n              'Invalid struct config:',\n              structName,\n              'max member offset (' + lastMember.offset + ') ',\n              'extends past end of struct (sizeof=' + structInfo.sizeof + ').',\n            );\n          }\n          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));\n\n          const StructCtor = function StructCtor(externalMemory) {\n            if (!(this instanceof StructCtor)) {\n              toss(\n                'The',\n                structName,\n                \"constructor may only be called via 'new'.\",\n              );\n            } else if (arguments.length) {\n              if (\n                externalMemory !== (externalMemory | 0) ||\n                externalMemory <= 0\n              ) {\n                toss('Invalid pointer value for', structName, 'constructor.');\n              }\n              __allocStruct(StructCtor, this, externalMemory);\n            } else {\n              __allocStruct(StructCtor, this);\n            }\n          };\n          Object.defineProperties(StructCtor, {\n            debugFlags: debugFlags,\n            isA: rop((v) => v instanceof StructCtor),\n            memberKey: __memberKeyProp,\n            memberKeys: __structMemberKeys,\n            methodInfoForKey: rop(function (mKey) {}),\n            structInfo: rop(structInfo),\n            structName: rop(structName),\n          });\n          StructCtor.prototype = new StructType(structName, structInfo, rop);\n          Object.defineProperties(StructCtor.prototype, {\n            debugFlags: debugFlags,\n            constructor: rop(StructCtor),\n          });\n          Object.keys(structInfo.members).forEach((name) =>\n            makeMemberWrapper(StructCtor, name, structInfo.members[name]),\n          );\n          return StructCtor;\n        };\n        StructBinder.StructType = StructType;\n        StructBinder.config = config;\n        StructBinder.allocCString = __allocCString;\n        if (!StructBinder.debugFlags) {\n          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);\n        }\n        return StructBinder;\n      };\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        'use strict';\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n        const toss3 = sqlite3.SQLite3Error.toss;\n        const capi = sqlite3.capi,\n          wasm = sqlite3.wasm,\n          util = sqlite3.util;\n        globalThis.WhWasmUtilInstaller(wasm);\n        delete globalThis.WhWasmUtilInstaller;\n\n        if (false) {}\n\n        wasm.bindingSignatures = [\n          ['sqlite3_aggregate_context', 'void*', 'sqlite3_context*', 'int'],\n\n          ['sqlite3_bind_double', 'int', 'sqlite3_stmt*', 'int', 'f64'],\n          ['sqlite3_bind_int', 'int', 'sqlite3_stmt*', 'int', 'int'],\n          ['sqlite3_bind_null', undefined, 'sqlite3_stmt*', 'int'],\n          ['sqlite3_bind_parameter_count', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_bind_parameter_index', 'int', 'sqlite3_stmt*', 'string'],\n          ['sqlite3_bind_parameter_name', 'string', 'sqlite3_stmt*', 'int'],\n          [\n            'sqlite3_bind_pointer',\n            'int',\n            'sqlite3_stmt*',\n            'int',\n            '*',\n            'string:static',\n            '*',\n          ],\n          [\n            'sqlite3_busy_handler',\n            'int',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                signature: 'i(pi)',\n                contextKey: (argv, argIndex) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_busy_timeout', 'int', 'sqlite3*', 'int'],\n\n          ['sqlite3_changes', 'int', 'sqlite3*'],\n          ['sqlite3_clear_bindings', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_collation_needed', 'int', 'sqlite3*', '*', '*'],\n          ['sqlite3_column_blob', '*', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_bytes', 'int', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_count', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_column_decltype', 'string', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_double', 'f64', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_int', 'int', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_name', 'string', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_text', 'string', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_type', 'int', 'sqlite3_stmt*', 'int'],\n          ['sqlite3_column_value', 'sqlite3_value*', 'sqlite3_stmt*', 'int'],\n          [\n            'sqlite3_commit_hook',\n            'void*',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_commit_hook',\n                signature: 'i(p)',\n                contextKey: (argv) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_compileoption_get', 'string', 'int'],\n          ['sqlite3_compileoption_used', 'int', 'string'],\n          ['sqlite3_complete', 'int', 'string:flexible'],\n          ['sqlite3_context_db_handle', 'sqlite3*', 'sqlite3_context*'],\n\n          ['sqlite3_data_count', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_db_filename', 'string', 'sqlite3*', 'string'],\n          ['sqlite3_db_handle', 'sqlite3*', 'sqlite3_stmt*'],\n          ['sqlite3_db_name', 'string', 'sqlite3*', 'int'],\n          ['sqlite3_db_readonly', 'int', 'sqlite3*', 'string'],\n          ['sqlite3_db_status', 'int', 'sqlite3*', 'int', '*', '*', 'int'],\n          ['sqlite3_errcode', 'int', 'sqlite3*'],\n          ['sqlite3_errmsg', 'string', 'sqlite3*'],\n          ['sqlite3_error_offset', 'int', 'sqlite3*'],\n          ['sqlite3_errstr', 'string', 'int'],\n          [\n            'sqlite3_exec',\n            'int',\n            [\n              'sqlite3*',\n              'string:flexible',\n              new wasm.xWrap.FuncPtrAdapter({\n                signature: 'i(pipp)',\n                bindScope: 'transient',\n                callProxy: (callback) => {\n                  let aNames;\n                  return (pVoid, nCols, pColVals, pColNames) => {\n                    try {\n                      const aVals = wasm.cArgvToJs(nCols, pColVals);\n                      if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);\n                      return callback(aVals, aNames) | 0;\n                    } catch (e) {\n                      return e.resultCode || capi.SQLITE_ERROR;\n                    }\n                  };\n                },\n              }),\n              '*',\n              '**',\n            ],\n          ],\n          ['sqlite3_expanded_sql', 'string', 'sqlite3_stmt*'],\n          ['sqlite3_extended_errcode', 'int', 'sqlite3*'],\n          ['sqlite3_extended_result_codes', 'int', 'sqlite3*', 'int'],\n          ['sqlite3_file_control', 'int', 'sqlite3*', 'string', 'int', '*'],\n          ['sqlite3_finalize', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_free', undefined, '*'],\n          ['sqlite3_get_autocommit', 'int', 'sqlite3*'],\n          ['sqlite3_get_auxdata', '*', 'sqlite3_context*', 'int'],\n          ['sqlite3_initialize', undefined],\n          ['sqlite3_interrupt', undefined, 'sqlite3*'],\n          ['sqlite3_is_interrupted', 'int', 'sqlite3*'],\n          ['sqlite3_keyword_count', 'int'],\n          ['sqlite3_keyword_name', 'int', ['int', '**', '*']],\n          ['sqlite3_keyword_check', 'int', ['string', 'int']],\n          ['sqlite3_libversion', 'string'],\n          ['sqlite3_libversion_number', 'int'],\n          ['sqlite3_limit', 'int', ['sqlite3*', 'int', 'int']],\n          ['sqlite3_malloc', '*', 'int'],\n          ['sqlite3_open', 'int', 'string', '*'],\n          ['sqlite3_open_v2', 'int', 'string', '*', 'int', 'string'],\n\n          ['sqlite3_realloc', '*', '*', 'int'],\n          ['sqlite3_reset', 'int', 'sqlite3_stmt*'],\n\n          [\n            'sqlite3_result_blob',\n            undefined,\n            'sqlite3_context*',\n            '*',\n            'int',\n            '*',\n          ],\n          ['sqlite3_result_double', undefined, 'sqlite3_context*', 'f64'],\n          [\n            'sqlite3_result_error',\n            undefined,\n            'sqlite3_context*',\n            'string',\n            'int',\n          ],\n          ['sqlite3_result_error_code', undefined, 'sqlite3_context*', 'int'],\n          ['sqlite3_result_error_nomem', undefined, 'sqlite3_context*'],\n          ['sqlite3_result_error_toobig', undefined, 'sqlite3_context*'],\n          ['sqlite3_result_int', undefined, 'sqlite3_context*', 'int'],\n          ['sqlite3_result_null', undefined, 'sqlite3_context*'],\n          [\n            'sqlite3_result_pointer',\n            undefined,\n            'sqlite3_context*',\n            '*',\n            'string:static',\n            '*',\n          ],\n          ['sqlite3_result_subtype', undefined, 'sqlite3_value*', 'int'],\n          [\n            'sqlite3_result_text',\n            undefined,\n            'sqlite3_context*',\n            'string',\n            'int',\n            '*',\n          ],\n          ['sqlite3_result_zeroblob', undefined, 'sqlite3_context*', 'int'],\n          [\n            'sqlite3_rollback_hook',\n            'void*',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_rollback_hook',\n                signature: 'v(p)',\n                contextKey: (argv) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n\n          [\n            'sqlite3_set_auxdata',\n            undefined,\n            [\n              'sqlite3_context*',\n              'int',\n              '*',\n               true\n                ? '*'\n                : 0,\n            ],\n          ],\n          ['sqlite3_shutdown', undefined],\n          ['sqlite3_sourceid', 'string'],\n          ['sqlite3_sql', 'string', 'sqlite3_stmt*'],\n          ['sqlite3_status', 'int', 'int', '*', '*', 'int'],\n          ['sqlite3_step', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_stmt_busy', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_stmt_readonly', 'int', 'sqlite3_stmt*'],\n          ['sqlite3_stmt_status', 'int', 'sqlite3_stmt*', 'int', 'int'],\n          ['sqlite3_strglob', 'int', 'string', 'string'],\n          ['sqlite3_stricmp', 'int', 'string', 'string'],\n          ['sqlite3_strlike', 'int', 'string', 'string', 'int'],\n          ['sqlite3_strnicmp', 'int', 'string', 'string', 'int'],\n          [\n            'sqlite3_table_column_metadata',\n            'int',\n            'sqlite3*',\n            'string',\n            'string',\n            'string',\n            '**',\n            '**',\n            '*',\n            '*',\n            '*',\n          ],\n          ['sqlite3_total_changes', 'int', 'sqlite3*'],\n          [\n            'sqlite3_trace_v2',\n            'int',\n            [\n              'sqlite3*',\n              'int',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_trace_v2::callback',\n                signature: 'i(ippp)',\n                contextKey: (argv, argIndex) => argv[0],\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_txn_state', 'int', ['sqlite3*', 'string']],\n\n          ['sqlite3_uri_boolean', 'int', 'sqlite3_filename', 'string', 'int'],\n          ['sqlite3_uri_key', 'string', 'sqlite3_filename', 'int'],\n          ['sqlite3_uri_parameter', 'string', 'sqlite3_filename', 'string'],\n          ['sqlite3_user_data', 'void*', 'sqlite3_context*'],\n          ['sqlite3_value_blob', '*', 'sqlite3_value*'],\n          ['sqlite3_value_bytes', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_double', 'f64', 'sqlite3_value*'],\n          ['sqlite3_value_dup', 'sqlite3_value*', 'sqlite3_value*'],\n          ['sqlite3_value_free', undefined, 'sqlite3_value*'],\n          ['sqlite3_value_frombind', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_int', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_nochange', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_numeric_type', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_pointer', '*', 'sqlite3_value*', 'string:static'],\n          ['sqlite3_value_subtype', 'int', 'sqlite3_value*'],\n          ['sqlite3_value_text', 'string', 'sqlite3_value*'],\n          ['sqlite3_value_type', 'int', 'sqlite3_value*'],\n          ['sqlite3_vfs_find', '*', 'string'],\n          ['sqlite3_vfs_register', 'int', 'sqlite3_vfs*', 'int'],\n          ['sqlite3_vfs_unregister', 'int', 'sqlite3_vfs*'],\n        ];\n\n        if (!!wasm.exports.sqlite3_progress_handler) {\n          wasm.bindingSignatures.push([\n            'sqlite3_progress_handler',\n            undefined,\n            [\n              'sqlite3*',\n              'int',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xProgressHandler',\n                signature: 'i(p)',\n                bindScope: 'context',\n                contextKey: (argv, argIndex) => argv[0],\n              }),\n              '*',\n            ],\n          ]);\n        }\n\n        if (!!wasm.exports.sqlite3_stmt_explain) {\n          wasm.bindingSignatures.push(\n            ['sqlite3_stmt_explain', 'int', 'sqlite3_stmt*', 'int'],\n            ['sqlite3_stmt_isexplain', 'int', 'sqlite3_stmt*'],\n          );\n        }\n\n        if (!!wasm.exports.sqlite3_set_authorizer) {\n          wasm.bindingSignatures.push([\n            'sqlite3_set_authorizer',\n            'int',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_set_authorizer::xAuth',\n                signature: 'i(pi' + 'ssss)',\n                contextKey: (argv, argIndex) => argv[0],\n                callProxy: (callback) => {\n                  return (pV, iCode, s0, s1, s2, s3) => {\n                    try {\n                      s0 = s0 && wasm.cstrToJs(s0);\n                      s1 = s1 && wasm.cstrToJs(s1);\n                      s2 = s2 && wasm.cstrToJs(s2);\n                      s3 = s3 && wasm.cstrToJs(s3);\n                      return callback(pV, iCode, s0, s1, s2, s3) || 0;\n                    } catch (e) {\n                      return e.resultCode || capi.SQLITE_ERROR;\n                    }\n                  };\n                },\n              }),\n              '*',\n            ],\n          ]);\n        }\n\n        if (false) {}\n\n        wasm.bindingSignatures.int64 = [\n          ['sqlite3_bind_int64', 'int', ['sqlite3_stmt*', 'int', 'i64']],\n          ['sqlite3_changes64', 'i64', ['sqlite3*']],\n          ['sqlite3_column_int64', 'i64', ['sqlite3_stmt*', 'int']],\n          [\n            'sqlite3_deserialize',\n            'int',\n            'sqlite3*',\n            'string',\n            '*',\n            'i64',\n            'i64',\n            'int',\n          ],\n          ['sqlite3_last_insert_rowid', 'i64', ['sqlite3*']],\n          ['sqlite3_malloc64', '*', 'i64'],\n          ['sqlite3_msize', 'i64', '*'],\n          ['sqlite3_overload_function', 'int', ['sqlite3*', 'string', 'int']],\n          ['sqlite3_realloc64', '*', '*', 'i64'],\n          ['sqlite3_result_int64', undefined, '*', 'i64'],\n          ['sqlite3_result_zeroblob64', 'int', '*', 'i64'],\n          ['sqlite3_serialize', '*', 'sqlite3*', 'string', '*', 'int'],\n          ['sqlite3_set_last_insert_rowid', undefined, ['sqlite3*', 'i64']],\n          ['sqlite3_status64', 'int', 'int', '*', '*', 'int'],\n          ['sqlite3_total_changes64', 'i64', ['sqlite3*']],\n          [\n            'sqlite3_update_hook',\n            '*',\n            [\n              'sqlite3*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'sqlite3_update_hook',\n                signature: 'v(iippj)',\n                contextKey: (argv) => argv[0],\n                callProxy: (callback) => {\n                  return (p, op, z0, z1, rowid) => {\n                    callback(\n                      p,\n                      op,\n                      wasm.cstrToJs(z0),\n                      wasm.cstrToJs(z1),\n                      rowid,\n                    );\n                  };\n                },\n              }),\n              '*',\n            ],\n          ],\n          ['sqlite3_uri_int64', 'i64', ['sqlite3_filename', 'string', 'i64']],\n          ['sqlite3_value_int64', 'i64', 'sqlite3_value*'],\n        ];\n\n        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_declare_vtab) {\n          wasm.bindingSignatures.int64.push(\n            [\n              'sqlite3_create_module',\n              'int',\n              ['sqlite3*', 'string', 'sqlite3_module*', '*'],\n            ],\n            [\n              'sqlite3_create_module_v2',\n              'int',\n              ['sqlite3*', 'string', 'sqlite3_module*', '*', '*'],\n            ],\n            ['sqlite3_declare_vtab', 'int', ['sqlite3*', 'string:flexible']],\n            ['sqlite3_drop_modules', 'int', ['sqlite3*', '**']],\n            ['sqlite3_vtab_collation', 'string', 'sqlite3_index_info*', 'int'],\n            ['sqlite3_vtab_distinct', 'int', 'sqlite3_index_info*'],\n            ['sqlite3_vtab_in', 'int', 'sqlite3_index_info*', 'int', 'int'],\n            ['sqlite3_vtab_in_first', 'int', 'sqlite3_value*', '**'],\n            ['sqlite3_vtab_in_next', 'int', 'sqlite3_value*', '**'],\n\n            ['sqlite3_vtab_nochange', 'int', 'sqlite3_context*'],\n            ['sqlite3_vtab_on_conflict', 'int', 'sqlite3*'],\n            [\n              'sqlite3_vtab_rhs_value',\n              'int',\n              'sqlite3_index_info*',\n              'int',\n              '**',\n            ],\n          );\n        }\n\n        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_preupdate_hook) {\n          wasm.bindingSignatures.int64.push(\n            ['sqlite3_preupdate_blobwrite', 'int', 'sqlite3*'],\n            ['sqlite3_preupdate_count', 'int', 'sqlite3*'],\n            ['sqlite3_preupdate_depth', 'int', 'sqlite3*'],\n            [\n              'sqlite3_preupdate_hook',\n              '*',\n              [\n                'sqlite3*',\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'sqlite3_preupdate_hook',\n                  signature: 'v(ppippjj)',\n                  contextKey: (argv) => argv[0],\n                  callProxy: (callback) => {\n                    return (p, db, op, zDb, zTbl, iKey1, iKey2) => {\n                      callback(\n                        p,\n                        db,\n                        op,\n                        wasm.cstrToJs(zDb),\n                        wasm.cstrToJs(zTbl),\n                        iKey1,\n                        iKey2,\n                      );\n                    };\n                  },\n                }),\n                '*',\n              ],\n            ],\n            ['sqlite3_preupdate_new', 'int', ['sqlite3*', 'int', '**']],\n            ['sqlite3_preupdate_old', 'int', ['sqlite3*', 'int', '**']],\n          );\n        }\n\n        if (\n          wasm.bigIntEnabled &&\n          !!wasm.exports.sqlite3changegroup_add &&\n          !!wasm.exports.sqlite3session_create &&\n          !!wasm.exports.sqlite3_preupdate_hook\n        ) {\n          const __ipsProxy = {\n            signature: 'i(ps)',\n            callProxy: (callback) => {\n              return (p, s) => {\n                try {\n                  return callback(p, wasm.cstrToJs(s)) | 0;\n                } catch (e) {\n                  return e.resultCode || capi.SQLITE_ERROR;\n                }\n              };\n            },\n          };\n\n          wasm.bindingSignatures.int64.push(\n            ...[\n              [\n                'sqlite3changegroup_add',\n                'int',\n                ['sqlite3_changegroup*', 'int', 'void*'],\n              ],\n              [\n                'sqlite3changegroup_add_strm',\n                'int',\n                [\n                  'sqlite3_changegroup*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changegroup_delete',\n                undefined,\n                ['sqlite3_changegroup*'],\n              ],\n              ['sqlite3changegroup_new', 'int', ['**']],\n              [\n                'sqlite3changegroup_output',\n                'int',\n                ['sqlite3_changegroup*', 'int*', '**'],\n              ],\n              [\n                'sqlite3changegroup_output_strm',\n                'int',\n                [\n                  'sqlite3_changegroup*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppi)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply',\n                'int',\n                [\n                  'sqlite3*',\n                  'int',\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply_strm',\n                'int',\n                [\n                  'sqlite3*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply_v2',\n                'int',\n                [\n                  'sqlite3*',\n                  'int',\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  '**',\n                  'int*',\n                  'int',\n                ],\n              ],\n              [\n                'sqlite3changeset_apply_v2_strm',\n                'int',\n                [\n                  'sqlite3*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    bindScope: 'transient',\n                    ...__ipsProxy,\n                  }),\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xConflict',\n                    signature: 'i(pip)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  '**',\n                  'int*',\n                  'int',\n                ],\n              ],\n              [\n                'sqlite3changeset_concat',\n                'int',\n                ['int', 'void*', 'int', 'void*', 'int*', '**'],\n              ],\n              [\n                'sqlite3changeset_concat_strm',\n                'int',\n                [\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInputA',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInputB',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppi)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_conflict',\n                'int',\n                ['sqlite3_changeset_iter*', 'int', '**'],\n              ],\n              ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],\n              [\n                'sqlite3changeset_fk_conflicts',\n                'int',\n                ['sqlite3_changeset_iter*', 'int*'],\n              ],\n              [\n                'sqlite3changeset_invert',\n                'int',\n                ['int', 'void*', 'int*', '**'],\n              ],\n              [\n                'sqlite3changeset_invert_strm',\n                'int',\n                [\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppi)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3changeset_new',\n                'int',\n                ['sqlite3_changeset_iter*', 'int', '**'],\n              ],\n              ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],\n              [\n                'sqlite3changeset_old',\n                'int',\n                ['sqlite3_changeset_iter*', 'int', '**'],\n              ],\n              [\n                'sqlite3changeset_op',\n                'int',\n                ['sqlite3_changeset_iter*', '**', 'int*', 'int*', 'int*'],\n              ],\n              [\n                'sqlite3changeset_pk',\n                'int',\n                ['sqlite3_changeset_iter*', '**', 'int*'],\n              ],\n              ['sqlite3changeset_start', 'int', ['**', 'int', '*']],\n              [\n                'sqlite3changeset_start_strm',\n                'int',\n                [\n                  '**',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],\n              [\n                'sqlite3changeset_start_v2_strm',\n                'int',\n                [\n                  '**',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xInput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                  'int',\n                ],\n              ],\n              ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],\n              [\n                'sqlite3session_changeset',\n                'int',\n                ['sqlite3_session*', 'int*', '**'],\n              ],\n              ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],\n              [\n                'sqlite3session_changeset_strm',\n                'int',\n                [\n                  'sqlite3_session*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              ['sqlite3session_config', 'int', ['int', 'void*']],\n              ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],\n\n              [\n                'sqlite3session_diff',\n                'int',\n                ['sqlite3_session*', 'string', 'string', '**'],\n              ],\n              ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],\n              ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],\n              ['sqlite3session_isempty', 'int', ['sqlite3_session*']],\n              ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],\n              [\n                'sqlite3session_object_config',\n                'int',\n                ['sqlite3_session*', 'int', 'void*'],\n              ],\n              [\n                'sqlite3session_patchset',\n                'int',\n                ['sqlite3_session*', '*', '**'],\n              ],\n              [\n                'sqlite3session_patchset_strm',\n                'int',\n                [\n                  'sqlite3_session*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xOutput',\n                    signature: 'i(ppp)',\n                    bindScope: 'transient',\n                  }),\n                  'void*',\n                ],\n              ],\n              [\n                'sqlite3session_table_filter',\n                undefined,\n                [\n                  'sqlite3_session*',\n                  new wasm.xWrap.FuncPtrAdapter({\n                    name: 'xFilter',\n                    ...__ipsProxy,\n                    contextKey: (argv, argIndex) => argv[0],\n                  }),\n                  '*',\n                ],\n              ],\n            ],\n          );\n        }\n\n        wasm.bindingSignatures.wasmInternal = [\n          ['sqlite3__wasm_db_reset', 'int', 'sqlite3*'],\n          ['sqlite3__wasm_db_vfs', 'sqlite3_vfs*', 'sqlite3*', 'string'],\n          [\n            'sqlite3__wasm_vfs_create_file',\n            'int',\n            'sqlite3_vfs*',\n            'string',\n            '*',\n            'int',\n          ],\n          ['sqlite3__wasm_posix_create_file', 'int', 'string', '*', 'int'],\n          ['sqlite3__wasm_vfs_unlink', 'int', 'sqlite3_vfs*', 'string'],\n          ['sqlite3__wasm_qfmt_token', 'string:dealloc', 'string', 'int'],\n        ];\n\n        sqlite3.StructBinder = globalThis.Jaccwabyt({\n          heap:  false ? 0 : wasm.heap8u,\n          alloc: wasm.alloc,\n          dealloc: wasm.dealloc,\n          bigIntEnabled: wasm.bigIntEnabled,\n          memberPrefix: '$',\n        });\n        delete globalThis.Jaccwabyt;\n\n        {\n          const __xString = wasm.xWrap.argAdapter('string');\n          wasm.xWrap.argAdapter('string:flexible', (v) =>\n            __xString(util.flexibleString(v)),\n          );\n\n          wasm.xWrap.argAdapter(\n            'string:static',\n            function (v) {\n              if (wasm.isPtr(v)) return v;\n              v = '' + v;\n              let rc = this[v];\n              return rc || (this[v] = wasm.allocCString(v));\n            }.bind(Object.create(null)),\n          );\n\n          const __xArgPtr = wasm.xWrap.argAdapter('*');\n          const nilType = function () {};\n          wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)(\n            'sqlite3_context*',\n            __xArgPtr,\n          )('sqlite3_value*', __xArgPtr)('void*', __xArgPtr)(\n            'sqlite3_changegroup*',\n            __xArgPtr,\n          )('sqlite3_changeset_iter*', __xArgPtr)(\n            'sqlite3_session*',\n            __xArgPtr,\n          )('sqlite3_stmt*', (v) =>\n            __xArgPtr(\n              v instanceof (sqlite3?.oo1?.Stmt || nilType) ? v.pointer : v,\n            ),\n          )('sqlite3*', (v) =>\n            __xArgPtr(\n              v instanceof (sqlite3?.oo1?.DB || nilType) ? v.pointer : v,\n            ),\n          )('sqlite3_vfs*', (v) => {\n            if ('string' === typeof v) {\n              return (\n                capi.sqlite3_vfs_find(v) ||\n                sqlite3.SQLite3Error.toss(\n                  capi.SQLITE_NOTFOUND,\n                  'Unknown sqlite3_vfs name:',\n                  v,\n                )\n              );\n            }\n            return __xArgPtr(\n              v instanceof (capi.sqlite3_vfs || nilType) ? v.pointer : v,\n            );\n          });\n          if (wasm.exports.sqlite3_declare_vtab) {\n            wasm.xWrap.argAdapter('sqlite3_index_info*', (v) =>\n              __xArgPtr(\n                v instanceof (capi.sqlite3_index_info || nilType)\n                  ? v.pointer\n                  : v,\n              ),\n            )('sqlite3_module*', (v) =>\n              __xArgPtr(\n                v instanceof (capi.sqlite3_module || nilType) ? v.pointer : v,\n              ),\n            );\n          }\n\n          const __xRcPtr = wasm.xWrap.resultAdapter('*');\n          wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)(\n            'sqlite3_context*',\n            __xRcPtr,\n          )('sqlite3_stmt*', __xRcPtr)('sqlite3_value*', __xRcPtr)(\n            'sqlite3_vfs*',\n            __xRcPtr,\n          )('void*', __xRcPtr);\n\n          if (0 === wasm.exports.sqlite3_step.length) {\n            wasm.xWrap.doArgcCheck = false;\n            sqlite3.config.warn(\n              'Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks.',\n            );\n          }\n          for (const e of wasm.bindingSignatures) {\n            capi[e[0]] = wasm.xWrap.apply(null, e);\n          }\n          for (const e of wasm.bindingSignatures.wasmInternal) {\n            util[e[0]] = wasm.xWrap.apply(null, e);\n          }\n\n          const fI64Disabled = function (fname) {\n            return () =>\n              toss(\n                fname + '() is unavailable due to lack',\n                'of BigInt support in this build.',\n              );\n          };\n          for (const e of wasm.bindingSignatures.int64) {\n            capi[e[0]] = wasm.bigIntEnabled\n              ? wasm.xWrap.apply(null, e)\n              : fI64Disabled(e[0]);\n          }\n\n          delete wasm.bindingSignatures;\n\n          if (wasm.exports.sqlite3__wasm_db_error) {\n            const __db_err = wasm.xWrap(\n              'sqlite3__wasm_db_error',\n              'int',\n              'sqlite3*',\n              'int',\n              'string',\n            );\n\n            util.sqlite3__wasm_db_error = function (pDb, resultCode, message) {\n              if (resultCode instanceof sqlite3.WasmAllocError) {\n                resultCode = capi.SQLITE_NOMEM;\n                message = 0;\n              } else if (resultCode instanceof Error) {\n                message = message || '' + resultCode;\n                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;\n              }\n              return pDb ? __db_err(pDb, resultCode, message) : resultCode;\n            };\n          } else {\n            util.sqlite3__wasm_db_error = function (pDb, errCode, msg) {\n              console.warn(\n                'sqlite3__wasm_db_error() is not exported.',\n                arguments,\n              );\n              return errCode;\n            };\n          }\n        }\n\n        {\n          const cJson = wasm.xCall('sqlite3__wasm_enum_json');\n          if (!cJson) {\n            toss(\n              \"Maintenance required: increase sqlite3__wasm_enum_json()'s\",\n              'static buffer size!',\n            );\n          }\n\n          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));\n\n          const defineGroups = [\n            'access',\n            'authorizer',\n            'blobFinalizers',\n            'changeset',\n            'config',\n            'dataTypes',\n            'dbConfig',\n            'dbStatus',\n            'encodings',\n            'fcntl',\n            'flock',\n            'ioCap',\n            'limits',\n            'openFlags',\n            'prepareFlags',\n            'resultCodes',\n            'sqlite3Status',\n            'stmtStatus',\n            'syncFlags',\n            'trace',\n            'txnState',\n            'udfFlags',\n            'version',\n          ];\n          if (wasm.bigIntEnabled) {\n            defineGroups.push('serialize', 'session', 'vtab');\n          }\n          for (const t of defineGroups) {\n            for (const e of Object.entries(wasm.ctype[t])) {\n              capi[e[0]] = e[1];\n            }\n          }\n          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {\n            toss(\n              'Internal error: cannot resolve exported function',\n              'entry SQLITE_WASM_DEALLOC (==' + capi.SQLITE_WASM_DEALLOC + ').',\n            );\n          }\n          const __rcMap = Object.create(null);\n          for (const t of ['resultCodes']) {\n            for (const e of Object.entries(wasm.ctype[t])) {\n              __rcMap[e[1]] = e[0];\n            }\n          }\n\n          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];\n\n          const notThese = Object.assign(Object.create(null), {\n            WasmTestStruct: true,\n\n            sqlite3_kvvfs_methods: !util.isUIThread(),\n\n            sqlite3_index_info: !wasm.bigIntEnabled,\n            sqlite3_index_constraint: !wasm.bigIntEnabled,\n            sqlite3_index_orderby: !wasm.bigIntEnabled,\n            sqlite3_index_constraint_usage: !wasm.bigIntEnabled,\n          });\n          for (const s of wasm.ctype.structs) {\n            if (!notThese[s.name]) {\n              capi[s.name] = sqlite3.StructBinder(s);\n            }\n          }\n          if (capi.sqlite3_index_info) {\n            for (const k of [\n              'sqlite3_index_constraint',\n              'sqlite3_index_orderby',\n              'sqlite3_index_constraint_usage',\n            ]) {\n              capi.sqlite3_index_info[k] = capi[k];\n              delete capi[k];\n            }\n            capi.sqlite3_vtab_config = wasm.xWrap(\n              'sqlite3__wasm_vtab_config',\n              'int',\n              ['sqlite3*', 'int', 'int'],\n            );\n          }\n        }\n\n        const __dbArgcMismatch = (pDb, f, n) => {\n          return util.sqlite3__wasm_db_error(\n            pDb,\n            capi.SQLITE_MISUSE,\n            f + '() requires ' + n + ' argument' + (1 === n ? '' : 's') + '.',\n          );\n        };\n\n        const __errEncoding = (pDb) => {\n          return util.sqlite3__wasm_db_error(\n            pDb,\n            capi.SQLITE_FORMAT,\n            'SQLITE_UTF8 is the only supported encoding.',\n          );\n        };\n\n        const __argPDb = (pDb) => wasm.xWrap.argAdapter('sqlite3*')(pDb);\n        const __argStr = (str) => (wasm.isPtr(str) ? wasm.cstrToJs(str) : str);\n        const __dbCleanupMap = function (pDb, mode) {\n          pDb = __argPDb(pDb);\n          let m = this.dbMap.get(pDb);\n          if (!mode) {\n            this.dbMap.delete(pDb);\n            return m;\n          } else if (!m && mode > 0) {\n            this.dbMap.set(pDb, (m = Object.create(null)));\n          }\n          return m;\n        }.bind(\n          Object.assign(Object.create(null), {\n            dbMap: new Map(),\n          }),\n        );\n\n        __dbCleanupMap.addCollation = function (pDb, name) {\n          const m = __dbCleanupMap(pDb, 1);\n          if (!m.collation) m.collation = new Set();\n          m.collation.add(__argStr(name).toLowerCase());\n        };\n\n        __dbCleanupMap._addUDF = function (pDb, name, arity, map) {\n          name = __argStr(name).toLowerCase();\n          let u = map.get(name);\n          if (!u) map.set(name, (u = new Set()));\n          u.add(arity < 0 ? -1 : arity);\n        };\n\n        __dbCleanupMap.addFunction = function (pDb, name, arity) {\n          const m = __dbCleanupMap(pDb, 1);\n          if (!m.udf) m.udf = new Map();\n          this._addUDF(pDb, name, arity, m.udf);\n        };\n\n        if (wasm.exports.sqlite3_create_window_function) {\n          __dbCleanupMap.addWindowFunc = function (pDb, name, arity) {\n            const m = __dbCleanupMap(pDb, 1);\n            if (!m.wudf) m.wudf = new Map();\n            this._addUDF(pDb, name, arity, m.wudf);\n          };\n        }\n\n        __dbCleanupMap.cleanup = function (pDb) {\n          pDb = __argPDb(pDb);\n\n          const closeArgs = [pDb];\n          for (const name of [\n            'sqlite3_busy_handler',\n            'sqlite3_commit_hook',\n            'sqlite3_preupdate_hook',\n            'sqlite3_progress_handler',\n            'sqlite3_rollback_hook',\n            'sqlite3_set_authorizer',\n            'sqlite3_trace_v2',\n            'sqlite3_update_hook',\n          ]) {\n            const x = wasm.exports[name];\n            if (!x) {\n              continue;\n            }\n            closeArgs.length = x.length;\n            try {\n              capi[name](...closeArgs);\n            } catch (e) {\n              sqlite3.config.warn(\n                'close-time call of',\n                name + '(',\n                closeArgs,\n                ') threw:',\n                e,\n              );\n            }\n          }\n          const m = __dbCleanupMap(pDb, 0);\n          if (!m) return;\n          if (m.collation) {\n            for (const name of m.collation) {\n              try {\n                capi.sqlite3_create_collation_v2(\n                  pDb,\n                  name,\n                  capi.SQLITE_UTF8,\n                  0,\n                  0,\n                  0,\n                );\n              } catch (e) {}\n            }\n            delete m.collation;\n          }\n          let i;\n          for (i = 0; i < 2; ++i) {\n            const fmap = i ? m.wudf : m.udf;\n            if (!fmap) continue;\n            const func = i\n              ? capi.sqlite3_create_window_function\n              : capi.sqlite3_create_function_v2;\n            for (const e of fmap) {\n              const name = e[0],\n                arities = e[1];\n              const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];\n              if (i) fargs.push(0);\n              for (const arity of arities) {\n                try {\n                  fargs[2] = arity;\n                  func.apply(null, fargs);\n                } catch (e) {}\n              }\n              arities.clear();\n            }\n            fmap.clear();\n          }\n          delete m.udf;\n          delete m.wudf;\n        };\n\n        {\n          const __sqlite3CloseV2 = wasm.xWrap(\n            'sqlite3_close_v2',\n            'int',\n            'sqlite3*',\n          );\n          capi.sqlite3_close_v2 = function (pDb) {\n            if (1 !== arguments.length)\n              return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);\n            if (pDb) {\n              try {\n                __dbCleanupMap.cleanup(pDb);\n              } catch (e) {}\n            }\n            return __sqlite3CloseV2(pDb);\n          };\n        }\n\n        if (capi.sqlite3session_create) {\n          const __sqlite3SessionDelete = wasm.xWrap(\n            'sqlite3session_delete',\n            undefined,\n            ['sqlite3_session*'],\n          );\n          capi.sqlite3session_delete = function (pSession) {\n            if (1 !== arguments.length) {\n              return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);\n            } else if (pSession) {\n              capi.sqlite3session_table_filter(pSession, 0, 0);\n            }\n            __sqlite3SessionDelete(pSession);\n          };\n        }\n\n        {\n          const contextKey = (argv, argIndex) => {\n            return (\n              'argv[' +\n              argIndex +\n              ']:' +\n              argv[0] +\n              ':' +\n              wasm.cstrToJs(argv[1]).toLowerCase()\n            );\n          };\n          const __sqlite3CreateCollationV2 = wasm.xWrap(\n            'sqlite3_create_collation_v2',\n            'int',\n            [\n              'sqlite3*',\n              'string',\n              'int',\n              '*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xCompare',\n                signature: 'i(pipip)',\n                contextKey,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xDestroy',\n                signature: 'v(p)',\n                contextKey,\n              }),\n            ],\n          );\n\n          capi.sqlite3_create_collation_v2 = function (\n            pDb,\n            zName,\n            eTextRep,\n            pArg,\n            xCompare,\n            xDestroy,\n          ) {\n            if (6 !== arguments.length)\n              return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);\n            else if (0 === (eTextRep & 0xf)) {\n              eTextRep |= capi.SQLITE_UTF8;\n            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {\n              return __errEncoding(pDb);\n            }\n            try {\n              const rc = __sqlite3CreateCollationV2(\n                pDb,\n                zName,\n                eTextRep,\n                pArg,\n                xCompare,\n                xDestroy,\n              );\n              if (0 === rc && xCompare instanceof Function) {\n                __dbCleanupMap.addCollation(pDb, zName);\n              }\n              return rc;\n            } catch (e) {\n              return util.sqlite3__wasm_db_error(pDb, e);\n            }\n          };\n\n          capi.sqlite3_create_collation = (\n            pDb,\n            zName,\n            eTextRep,\n            pArg,\n            xCompare,\n          ) => {\n            return 5 === arguments.length\n              ? capi.sqlite3_create_collation_v2(\n                  pDb,\n                  zName,\n                  eTextRep,\n                  pArg,\n                  xCompare,\n                  0,\n                )\n              : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);\n          };\n        }\n\n        {\n          const contextKey = function (argv, argIndex) {\n            return (\n              argv[0] +\n              ':' +\n              (argv[2] < 0 ? -1 : argv[2]) +\n              ':' +\n              argIndex +\n              ':' +\n              wasm.cstrToJs(argv[1]).toLowerCase()\n            );\n          };\n\n          const __cfProxy = Object.assign(Object.create(null), {\n            xInverseAndStep: {\n              signature: 'v(pip)',\n              contextKey,\n              callProxy: (callback) => {\n                return (pCtx, argc, pArgv) => {\n                  try {\n                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));\n                  } catch (e) {\n                    capi.sqlite3_result_error_js(pCtx, e);\n                  }\n                };\n              },\n            },\n            xFinalAndValue: {\n              signature: 'v(p)',\n              contextKey,\n              callProxy: (callback) => {\n                return (pCtx) => {\n                  try {\n                    capi.sqlite3_result_js(pCtx, callback(pCtx));\n                  } catch (e) {\n                    capi.sqlite3_result_error_js(pCtx, e);\n                  }\n                };\n              },\n            },\n            xFunc: {\n              signature: 'v(pip)',\n              contextKey,\n              callProxy: (callback) => {\n                return (pCtx, argc, pArgv) => {\n                  try {\n                    capi.sqlite3_result_js(\n                      pCtx,\n                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)),\n                    );\n                  } catch (e) {\n                    capi.sqlite3_result_error_js(pCtx, e);\n                  }\n                };\n              },\n            },\n            xDestroy: {\n              signature: 'v(p)',\n              contextKey,\n\n              callProxy: (callback) => {\n                return (pVoid) => {\n                  try {\n                    callback(pVoid);\n                  } catch (e) {\n                    console.error('UDF xDestroy method threw:', e);\n                  }\n                };\n              },\n            },\n          });\n\n          const __sqlite3CreateFunction = wasm.xWrap(\n            'sqlite3_create_function_v2',\n            'int',\n            [\n              'sqlite3*',\n              'string',\n              'int',\n              'int',\n              '*',\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xFunc',\n                ...__cfProxy.xFunc,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xStep',\n                ...__cfProxy.xInverseAndStep,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xFinal',\n                ...__cfProxy.xFinalAndValue,\n              }),\n              new wasm.xWrap.FuncPtrAdapter({\n                name: 'xDestroy',\n                ...__cfProxy.xDestroy,\n              }),\n            ],\n          );\n\n          const __sqlite3CreateWindowFunction = wasm.exports\n            .sqlite3_create_window_function\n            ? wasm.xWrap('sqlite3_create_window_function', 'int', [\n                'sqlite3*',\n                'string',\n                'int',\n                'int',\n                '*',\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xStep',\n                  ...__cfProxy.xInverseAndStep,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xFinal',\n                  ...__cfProxy.xFinalAndValue,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xValue',\n                  ...__cfProxy.xFinalAndValue,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xInverse',\n                  ...__cfProxy.xInverseAndStep,\n                }),\n                new wasm.xWrap.FuncPtrAdapter({\n                  name: 'xDestroy',\n                  ...__cfProxy.xDestroy,\n                }),\n              ])\n            : undefined;\n\n          capi.sqlite3_create_function_v2 = function f(\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n            xDestroy,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                pDb,\n                'sqlite3_create_function_v2',\n                f.length,\n              );\n            } else if (0 === (eTextRep & 0xf)) {\n              eTextRep |= capi.SQLITE_UTF8;\n            } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {\n              return __errEncoding(pDb);\n            }\n            try {\n              const rc = __sqlite3CreateFunction(\n                pDb,\n                funcName,\n                nArg,\n                eTextRep,\n                pApp,\n                xFunc,\n                xStep,\n                xFinal,\n                xDestroy,\n              );\n              if (\n                0 === rc &&\n                (xFunc instanceof Function ||\n                  xStep instanceof Function ||\n                  xFinal instanceof Function ||\n                  xDestroy instanceof Function)\n              ) {\n                __dbCleanupMap.addFunction(pDb, funcName, nArg);\n              }\n              return rc;\n            } catch (e) {\n              console.error('sqlite3_create_function_v2() setup threw:', e);\n              return util.sqlite3__wasm_db_error(\n                pDb,\n                e,\n                'Creation of UDF threw: ' + e,\n              );\n            }\n          };\n\n          capi.sqlite3_create_function = function f(\n            pDb,\n            funcName,\n            nArg,\n            eTextRep,\n            pApp,\n            xFunc,\n            xStep,\n            xFinal,\n          ) {\n            return f.length === arguments.length\n              ? capi.sqlite3_create_function_v2(\n                  pDb,\n                  funcName,\n                  nArg,\n                  eTextRep,\n                  pApp,\n                  xFunc,\n                  xStep,\n                  xFinal,\n                  0,\n                )\n              : __dbArgcMismatch(pDb, 'sqlite3_create_function', f.length);\n          };\n\n          if (__sqlite3CreateWindowFunction) {\n            capi.sqlite3_create_window_function = function f(\n              pDb,\n              funcName,\n              nArg,\n              eTextRep,\n              pApp,\n              xStep,\n              xFinal,\n              xValue,\n              xInverse,\n              xDestroy,\n            ) {\n              if (f.length !== arguments.length) {\n                return __dbArgcMismatch(\n                  pDb,\n                  'sqlite3_create_window_function',\n                  f.length,\n                );\n              } else if (0 === (eTextRep & 0xf)) {\n                eTextRep |= capi.SQLITE_UTF8;\n              } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {\n                return __errEncoding(pDb);\n              }\n              try {\n                const rc = __sqlite3CreateWindowFunction(\n                  pDb,\n                  funcName,\n                  nArg,\n                  eTextRep,\n                  pApp,\n                  xStep,\n                  xFinal,\n                  xValue,\n                  xInverse,\n                  xDestroy,\n                );\n                if (\n                  0 === rc &&\n                  (xStep instanceof Function ||\n                    xFinal instanceof Function ||\n                    xValue instanceof Function ||\n                    xInverse instanceof Function ||\n                    xDestroy instanceof Function)\n                ) {\n                  __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);\n                }\n                return rc;\n              } catch (e) {\n                console.error(\n                  'sqlite3_create_window_function() setup threw:',\n                  e,\n                );\n                return util.sqlite3__wasm_db_error(\n                  pDb,\n                  e,\n                  'Creation of UDF threw: ' + e,\n                );\n              }\n            };\n          } else {\n            delete capi.sqlite3_create_window_function;\n          }\n\n          capi.sqlite3_create_function_v2.udfSetResult =\n            capi.sqlite3_create_function.udfSetResult = capi.sqlite3_result_js;\n          if (capi.sqlite3_create_window_function) {\n            capi.sqlite3_create_window_function.udfSetResult =\n              capi.sqlite3_result_js;\n          }\n\n          capi.sqlite3_create_function_v2.udfConvertArgs =\n            capi.sqlite3_create_function.udfConvertArgs =\n              capi.sqlite3_values_to_js;\n          if (capi.sqlite3_create_window_function) {\n            capi.sqlite3_create_window_function.udfConvertArgs =\n              capi.sqlite3_values_to_js;\n          }\n\n          capi.sqlite3_create_function_v2.udfSetError =\n            capi.sqlite3_create_function.udfSetError =\n              capi.sqlite3_result_error_js;\n          if (capi.sqlite3_create_window_function) {\n            capi.sqlite3_create_window_function.udfSetError =\n              capi.sqlite3_result_error_js;\n          }\n        }\n\n        {\n          const __flexiString = (v, n) => {\n            if ('string' === typeof v) {\n              n = -1;\n            } else if (util.isSQLableTypedArray(v)) {\n              n = v.byteLength;\n              v = util.typedArrayToString(\n                v instanceof ArrayBuffer ? new Uint8Array(v) : v,\n              );\n            } else if (Array.isArray(v)) {\n              v = v.join('');\n              n = -1;\n            }\n            return [v, n];\n          };\n\n          const __prepare = {\n            basic: wasm.xWrap('sqlite3_prepare_v3', 'int', [\n              'sqlite3*',\n              'string',\n              'int',\n              'int',\n              '**',\n              '**',\n            ]),\n\n            full: wasm.xWrap('sqlite3_prepare_v3', 'int', [\n              'sqlite3*',\n              '*',\n              'int',\n              'int',\n              '**',\n              '**',\n            ]),\n          };\n\n          capi.sqlite3_prepare_v3 = function f(\n            pDb,\n            sql,\n            sqlLen,\n            prepFlags,\n            ppStmt,\n            pzTail,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(pDb, 'sqlite3_prepare_v3', f.length);\n            }\n            const [xSql, xSqlLen] = __flexiString(sql, sqlLen);\n            switch (typeof xSql) {\n              case 'string':\n                return __prepare.basic(\n                  pDb,\n                  xSql,\n                  xSqlLen,\n                  prepFlags,\n                  ppStmt,\n                  null,\n                );\n              case 'number':\n                return __prepare.full(\n                  pDb,\n                  xSql,\n                  xSqlLen,\n                  prepFlags,\n                  ppStmt,\n                  pzTail,\n                );\n              default:\n                return util.sqlite3__wasm_db_error(\n                  pDb,\n                  capi.SQLITE_MISUSE,\n                  'Invalid SQL argument type for sqlite3_prepare_v2/v3().',\n                );\n            }\n          };\n\n          capi.sqlite3_prepare_v2 = function f(\n            pDb,\n            sql,\n            sqlLen,\n            ppStmt,\n            pzTail,\n          ) {\n            return f.length === arguments.length\n              ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)\n              : __dbArgcMismatch(pDb, 'sqlite3_prepare_v2', f.length);\n          };\n        }\n\n        {\n          const __bindText = wasm.xWrap('sqlite3_bind_text', 'int', [\n            'sqlite3_stmt*',\n            'int',\n            'string',\n            'int',\n            '*',\n          ]);\n          const __bindBlob = wasm.xWrap('sqlite3_bind_blob', 'int', [\n            'sqlite3_stmt*',\n            'int',\n            '*',\n            'int',\n            '*',\n          ]);\n\n          capi.sqlite3_bind_text = function f(\n            pStmt,\n            iCol,\n            text,\n            nText,\n            xDestroy,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                capi.sqlite3_db_handle(pStmt),\n                'sqlite3_bind_text',\n                f.length,\n              );\n            } else if (wasm.isPtr(text) || null === text) {\n              return __bindText(pStmt, iCol, text, nText, xDestroy);\n            } else if (text instanceof ArrayBuffer) {\n              text = new Uint8Array(text);\n            } else if (Array.isArray(pMem)) {\n              text = pMem.join('');\n            }\n            let p, n;\n            try {\n              if (util.isSQLableTypedArray(text)) {\n                p = wasm.allocFromTypedArray(text);\n                n = text.byteLength;\n              } else if ('string' === typeof text) {\n                [p, n] = wasm.allocCString(text);\n              } else {\n                return util.sqlite3__wasm_db_error(\n                  capi.sqlite3_db_handle(pStmt),\n                  capi.SQLITE_MISUSE,\n                  'Invalid 3rd argument type for sqlite3_bind_text().',\n                );\n              }\n              return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);\n            } catch (e) {\n              wasm.dealloc(p);\n              return util.sqlite3__wasm_db_error(\n                capi.sqlite3_db_handle(pStmt),\n                e,\n              );\n            }\n          };\n\n          capi.sqlite3_bind_blob = function f(\n            pStmt,\n            iCol,\n            pMem,\n            nMem,\n            xDestroy,\n          ) {\n            if (f.length !== arguments.length) {\n              return __dbArgcMismatch(\n                capi.sqlite3_db_handle(pStmt),\n                'sqlite3_bind_blob',\n                f.length,\n              );\n            } else if (wasm.isPtr(pMem) || null === pMem) {\n              return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);\n            } else if (pMem instanceof ArrayBuffer) {\n              pMem = new Uint8Array(pMem);\n            } else if (Array.isArray(pMem)) {\n              pMem = pMem.join('');\n            }\n            let p, n;\n            try {\n              if (util.isBindableTypedArray(pMem)) {\n                p = wasm.allocFromTypedArray(pMem);\n                n = nMem >= 0 ? nMem : pMem.byteLength;\n              } else if ('string' === typeof pMem) {\n                [p, n] = wasm.allocCString(pMem);\n              } else {\n                return util.sqlite3__wasm_db_error(\n                  capi.sqlite3_db_handle(pStmt),\n                  capi.SQLITE_MISUSE,\n                  'Invalid 3rd argument type for sqlite3_bind_blob().',\n                );\n              }\n              return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);\n            } catch (e) {\n              wasm.dealloc(p);\n              return util.sqlite3__wasm_db_error(\n                capi.sqlite3_db_handle(pStmt),\n                e,\n              );\n            }\n          };\n        }\n\n        {\n          capi.sqlite3_config = function (op, ...args) {\n            if (arguments.length < 2) return capi.SQLITE_MISUSE;\n            switch (op) {\n              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:\n              case capi.SQLITE_CONFIG_MEMSTATUS:\n              case capi.SQLITE_CONFIG_SMALL_MALLOC:\n              case capi.SQLITE_CONFIG_SORTERREF_SIZE:\n              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:\n              case capi.SQLITE_CONFIG_URI:\n                return wasm.exports.sqlite3__wasm_config_i(op, args[0]);\n              case capi.SQLITE_CONFIG_LOOKASIDE:\n                return wasm.exports.sqlite3__wasm_config_ii(\n                  op,\n                  args[0],\n                  args[1],\n                );\n              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:\n                return wasm.exports.sqlite3__wasm_config_j(op, args[0]);\n              case capi.SQLITE_CONFIG_GETMALLOC:\n              case capi.SQLITE_CONFIG_GETMUTEX:\n              case capi.SQLITE_CONFIG_GETPCACHE2:\n              case capi.SQLITE_CONFIG_GETPCACHE:\n              case capi.SQLITE_CONFIG_HEAP:\n              case capi.SQLITE_CONFIG_LOG:\n              case capi.SQLITE_CONFIG_MALLOC:\n              case capi.SQLITE_CONFIG_MMAP_SIZE:\n              case capi.SQLITE_CONFIG_MULTITHREAD:\n              case capi.SQLITE_CONFIG_MUTEX:\n              case capi.SQLITE_CONFIG_PAGECACHE:\n              case capi.SQLITE_CONFIG_PCACHE2:\n              case capi.SQLITE_CONFIG_PCACHE:\n              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:\n              case capi.SQLITE_CONFIG_PMASZ:\n              case capi.SQLITE_CONFIG_SERIALIZED:\n              case capi.SQLITE_CONFIG_SINGLETHREAD:\n              case capi.SQLITE_CONFIG_SQLLOG:\n              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:\n              default:\n                return capi.SQLITE_NOTFOUND;\n            }\n          };\n        }\n\n        {\n          const __autoExtFptr = new Set();\n\n          capi.sqlite3_auto_extension = function (fPtr) {\n            if (fPtr instanceof Function) {\n              fPtr = wasm.installFunction('i(ppp)', fPtr);\n            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {\n              return capi.SQLITE_MISUSE;\n            }\n            const rc = wasm.exports.sqlite3_auto_extension(fPtr);\n            if (fPtr !== arguments[0]) {\n              if (0 === rc) __autoExtFptr.add(fPtr);\n              else wasm.uninstallFunction(fPtr);\n            }\n            return rc;\n          };\n\n          capi.sqlite3_cancel_auto_extension = function (fPtr) {\n            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;\n            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);\n          };\n\n          capi.sqlite3_reset_auto_extension = function () {\n            wasm.exports.sqlite3_reset_auto_extension();\n            for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);\n            __autoExtFptr.clear();\n          };\n        }\n\n        const pKvvfs = capi.sqlite3_vfs_find('kvvfs');\n        if (pKvvfs) {\n          if (util.isUIThread()) {\n            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(\n              wasm.exports.sqlite3__wasm_kvvfs_methods(),\n            );\n            delete capi.sqlite3_kvvfs_methods;\n\n            const kvvfsMakeKey =\n                wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack,\n              pstack = wasm.pstack;\n\n            const kvvfsStorage = (zClass) =>\n              115 === wasm.peek(zClass) ? sessionStorage : localStorage;\n\n            const kvvfsImpls = {\n              xRead: (zClass, zKey, zBuf, nBuf) => {\n                const stack = pstack.pointer,\n                  astack = wasm.scopedAllocPush();\n                try {\n                  const zXKey = kvvfsMakeKey(zClass, zKey);\n                  if (!zXKey) return -3;\n                  const jKey = wasm.cstrToJs(zXKey);\n                  const jV = kvvfsStorage(zClass).getItem(jKey);\n                  if (!jV) return -1;\n                  const nV = jV.length;\n                  if (nBuf <= 0) return nV;\n                  else if (1 === nBuf) {\n                    wasm.poke(zBuf, 0);\n                    return nV;\n                  }\n                  const zV = wasm.scopedAllocCString(jV);\n                  if (nBuf > nV + 1) nBuf = nV + 1;\n                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);\n                  wasm.poke(zBuf + nBuf - 1, 0);\n                  return nBuf - 1;\n                } catch (e) {\n                  console.error('kvstorageRead()', e);\n                  return -2;\n                } finally {\n                  pstack.restore(stack);\n                  wasm.scopedAllocPop(astack);\n                }\n              },\n              xWrite: (zClass, zKey, zData) => {\n                const stack = pstack.pointer;\n                try {\n                  const zXKey = kvvfsMakeKey(zClass, zKey);\n                  if (!zXKey) return 1;\n                  const jKey = wasm.cstrToJs(zXKey);\n                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));\n                  return 0;\n                } catch (e) {\n                  console.error('kvstorageWrite()', e);\n                  return capi.SQLITE_IOERR;\n                } finally {\n                  pstack.restore(stack);\n                }\n              },\n              xDelete: (zClass, zKey) => {\n                const stack = pstack.pointer;\n                try {\n                  const zXKey = kvvfsMakeKey(zClass, zKey);\n                  if (!zXKey) return 1;\n                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));\n                  return 0;\n                } catch (e) {\n                  console.error('kvstorageDelete()', e);\n                  return capi.SQLITE_IOERR;\n                } finally {\n                  pstack.restore(stack);\n                }\n              },\n            };\n            for (const k of Object.keys(kvvfsImpls)) {\n              kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(\n                kvvfsMethods.memberSignature(k),\n                kvvfsImpls[k],\n              );\n            }\n          } else {\n            capi.sqlite3_vfs_unregister(pKvvfs);\n          }\n        }\n\n        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;\n\n        const StructBinder = sqlite3.StructBinder;\n        const installMethod = function callee(\n          tgt,\n          name,\n          func,\n          applyArgcCheck = callee.installMethodArgcCheck,\n        ) {\n          if (!(tgt instanceof StructBinder.StructType)) {\n            toss('Usage error: target object is-not-a StructType.');\n          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {\n            toss('Usage error: expecting a Function or WASM pointer to one.');\n          }\n          if (1 === arguments.length) {\n            return (n, f) => callee(tgt, n, f, applyArgcCheck);\n          }\n          if (!callee.argcProxy) {\n            callee.argcProxy = function (tgt, funcName, func, sig) {\n              return function (...args) {\n                if (func.length !== arguments.length) {\n                  toss(\n                    'Argument mismatch for',\n                    tgt.structInfo.name +\n                      '::' +\n                      funcName +\n                      ': Native signature is:',\n                    sig,\n                  );\n                }\n                return func.apply(this, args);\n              };\n            };\n\n            callee.removeFuncList = function () {\n              if (this.ondispose.__removeFuncList) {\n                this.ondispose.__removeFuncList.forEach((v, ndx) => {\n                  if ('number' === typeof v) {\n                    try {\n                      wasm.uninstallFunction(v);\n                    } catch (e) {}\n                  }\n                });\n                delete this.ondispose.__removeFuncList;\n              }\n            };\n          }\n          const sigN = tgt.memberSignature(name);\n          if (sigN.length < 2) {\n            toss(\n              'Member',\n              name,\n              'does not have a function pointer signature:',\n              sigN,\n            );\n          }\n          const memKey = tgt.memberKey(name);\n          const fProxy =\n            applyArgcCheck && !wasm.isPtr(func)\n              ? callee.argcProxy(tgt, memKey, func, sigN)\n              : func;\n          if (wasm.isPtr(fProxy)) {\n            if (fProxy && !wasm.functionEntry(fProxy)) {\n              toss('Pointer', fProxy, 'is not a WASM function table entry.');\n            }\n            tgt[memKey] = fProxy;\n          } else {\n            const pFunc = wasm.installFunction(\n              fProxy,\n              tgt.memberSignature(name, true),\n            );\n            tgt[memKey] = pFunc;\n            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {\n              tgt.addOnDispose(\n                'ondispose.__removeFuncList handler',\n                callee.removeFuncList,\n              );\n              tgt.ondispose.__removeFuncList = [];\n            }\n            tgt.ondispose.__removeFuncList.push(memKey, pFunc);\n          }\n          return (n, f) => callee(tgt, n, f, applyArgcCheck);\n        };\n        installMethod.installMethodArgcCheck = false;\n\n        const installMethods = function (\n          structInstance,\n          methods,\n          applyArgcCheck = installMethod.installMethodArgcCheck,\n        ) {\n          const seen = new Map();\n          for (const k of Object.keys(methods)) {\n            const m = methods[k];\n            const prior = seen.get(m);\n            if (prior) {\n              const mkey = structInstance.memberKey(k);\n              structInstance[mkey] =\n                structInstance[structInstance.memberKey(prior)];\n            } else {\n              installMethod(structInstance, k, m, applyArgcCheck);\n              seen.set(m, k);\n            }\n          }\n          return structInstance;\n        };\n\n        StructBinder.StructType.prototype.installMethod = function callee(\n          name,\n          func,\n          applyArgcCheck = installMethod.installMethodArgcCheck,\n        ) {\n          return arguments.length < 3 && name && 'object' === typeof name\n            ? installMethods(this, ...arguments)\n            : installMethod(this, ...arguments);\n        };\n\n        StructBinder.StructType.prototype.installMethods = function (\n          methods,\n          applyArgcCheck = installMethod.installMethodArgcCheck,\n        ) {\n          return installMethods(this, methods, applyArgcCheck);\n        };\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        sqlite3.version = {\n          libVersion: '3.50.4',\n          libVersionNumber: 3050004,\n          sourceId:\n            '2025-07-30 19:33:53 4d8adfb30e03f9cf27f800a2c1ba3c48fb4ca1b08b0f5ed59a4d5ecbf45e20a3',\n          downloadVersion: 3500400,\n        };\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const toss = (...args) => {\n          throw new Error(args.join(' '));\n        };\n        const toss3 = (...args) => {\n          throw new sqlite3.SQLite3Error(...args);\n        };\n\n        const capi = sqlite3.capi,\n          wasm = sqlite3.wasm,\n          util = sqlite3.util;\n\n        const __ptrMap = new WeakMap();\n\n        const __stmtMap = new WeakMap();\n\n        const getOwnOption = (opts, p, dflt) => {\n          const d = Object.getOwnPropertyDescriptor(opts, p);\n          return d ? d.value : dflt;\n        };\n\n        const checkSqlite3Rc = function (dbPtr, sqliteResultCode) {\n          if (sqliteResultCode) {\n            if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;\n            toss3(\n              sqliteResultCode,\n              'sqlite3 result code',\n              sqliteResultCode + ':',\n              dbPtr\n                ? capi.sqlite3_errmsg(dbPtr)\n                : capi.sqlite3_errstr(sqliteResultCode),\n            );\n          }\n          return arguments[0];\n        };\n\n        const __dbTraceToConsole = wasm.installFunction(\n          'i(ippp)',\n          function (t, c, p, x) {\n            if (capi.SQLITE_TRACE_STMT === t) {\n              console.log(\n                'SQL TRACE #' + ++this.counter + ' via sqlite3@' + c + ':',\n                wasm.cstrToJs(x),\n              );\n            }\n          }.bind({ counter: 0 }),\n        );\n\n        const __vfsPostOpenCallback = Object.create(null);\n\n        const dbCtorHelper = function ctor(...args) {\n          if (!ctor._name2vfs) {\n            ctor._name2vfs = Object.create(null);\n            const isWorkerThread =\n              'function' === typeof importScripts\n                ? (n) =>\n                    toss3(\n                      'The VFS for',\n                      n,\n                      'is only available in the main window thread.',\n                    )\n                : false;\n            ctor._name2vfs[':localStorage:'] = {\n              vfs: 'kvvfs',\n              filename: isWorkerThread || (() => 'local'),\n            };\n            ctor._name2vfs[':sessionStorage:'] = {\n              vfs: 'kvvfs',\n              filename: isWorkerThread || (() => 'session'),\n            };\n          }\n          const opt = ctor.normalizeArgs(...args);\n          let fn = opt.filename,\n            vfsName = opt.vfs,\n            flagsStr = opt.flags;\n          if (\n            ('string' !== typeof fn && 'number' !== typeof fn) ||\n            'string' !== typeof flagsStr ||\n            (vfsName &&\n              'string' !== typeof vfsName &&\n              'number' !== typeof vfsName)\n          ) {\n            sqlite3.config.error('Invalid DB ctor args', opt, arguments);\n            toss3('Invalid arguments for DB constructor.');\n          }\n          let fnJs = 'number' === typeof fn ? wasm.cstrToJs(fn) : fn;\n          const vfsCheck = ctor._name2vfs[fnJs];\n          if (vfsCheck) {\n            vfsName = vfsCheck.vfs;\n            fn = fnJs = vfsCheck.filename(fnJs);\n          }\n          let pDb,\n            oflags = 0;\n          if (flagsStr.indexOf('c') >= 0) {\n            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;\n          }\n          if (flagsStr.indexOf('w') >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;\n          if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;\n          oflags |= capi.SQLITE_OPEN_EXRESCODE;\n          const stack = wasm.pstack.pointer;\n          try {\n            const pPtr = wasm.pstack.allocPtr();\n            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);\n            pDb = wasm.peekPtr(pPtr);\n            checkSqlite3Rc(pDb, rc);\n            capi.sqlite3_extended_result_codes(pDb, 1);\n            if (flagsStr.indexOf('t') >= 0) {\n              capi.sqlite3_trace_v2(\n                pDb,\n                capi.SQLITE_TRACE_STMT,\n                __dbTraceToConsole,\n                pDb,\n              );\n            }\n          } catch (e) {\n            if (pDb) capi.sqlite3_close_v2(pDb);\n            throw e;\n          } finally {\n            wasm.pstack.restore(stack);\n          }\n          this.filename = fnJs;\n          __ptrMap.set(this, pDb);\n          __stmtMap.set(this, Object.create(null));\n          try {\n            const pVfs =\n              capi.sqlite3_js_db_vfs(pDb) ||\n              toss3('Internal error: cannot get VFS for new db handle.');\n            const postInitSql = __vfsPostOpenCallback[pVfs];\n            if (postInitSql) {\n              if (postInitSql instanceof Function) {\n                postInitSql(this, sqlite3);\n              } else {\n                checkSqlite3Rc(\n                  pDb,\n                  capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0),\n                );\n              }\n            }\n          } catch (e) {\n            this.close();\n            throw e;\n          }\n        };\n\n        dbCtorHelper.setVfsPostOpenCallback = function (pVfs, callback) {\n          if (!(callback instanceof Function)) {\n            toss3(\n              'dbCtorHelper.setVfsPostOpenCallback() should not be used with ' +\n                'a non-function argument.',\n              arguments,\n            );\n          }\n          __vfsPostOpenCallback[pVfs] = callback;\n        };\n\n        dbCtorHelper.normalizeArgs = function (\n          filename = ':memory:',\n          flags = 'c',\n          vfs = null,\n        ) {\n          const arg = {};\n          if (\n            1 === arguments.length &&\n            arguments[0] &&\n            'object' === typeof arguments[0]\n          ) {\n            Object.assign(arg, arguments[0]);\n            if (undefined === arg.flags) arg.flags = 'c';\n            if (undefined === arg.vfs) arg.vfs = null;\n            if (undefined === arg.filename) arg.filename = ':memory:';\n          } else {\n            arg.filename = filename;\n            arg.flags = flags;\n            arg.vfs = vfs;\n          }\n          return arg;\n        };\n\n        const DB = function (...args) {\n          dbCtorHelper.apply(this, args);\n        };\n        DB.dbCtorHelper = dbCtorHelper;\n\n        const BindTypes = {\n          null: 1,\n          number: 2,\n          string: 3,\n          boolean: 4,\n          blob: 5,\n        };\n        BindTypes['undefined'] == BindTypes.null;\n        if (wasm.bigIntEnabled) {\n          BindTypes.bigint = BindTypes.number;\n        }\n\n        const Stmt = function () {\n          if (BindTypes !== arguments[2]) {\n            toss3(\n              capi.SQLITE_MISUSE,\n              'Do not call the Stmt constructor directly. Use DB.prepare().',\n            );\n          }\n          this.db = arguments[0];\n          __ptrMap.set(this, arguments[1]);\n          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);\n        };\n\n        const affirmDbOpen = function (db) {\n          if (!db.pointer) toss3('DB has been closed.');\n          return db;\n        };\n\n        const affirmColIndex = function (stmt, ndx) {\n          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {\n            toss3('Column index', ndx, 'is out of range.');\n          }\n          return stmt;\n        };\n\n        const parseExecArgs = function (db, args) {\n          const out = Object.create(null);\n          out.opt = Object.create(null);\n          switch (args.length) {\n            case 1:\n              if (\n                'string' === typeof args[0] ||\n                util.isSQLableTypedArray(args[0])\n              ) {\n                out.sql = args[0];\n              } else if (Array.isArray(args[0])) {\n                out.sql = args[0];\n              } else if (args[0] && 'object' === typeof args[0]) {\n                out.opt = args[0];\n                out.sql = out.opt.sql;\n              }\n              break;\n            case 2:\n              out.sql = args[0];\n              out.opt = args[1];\n              break;\n            default:\n              toss3('Invalid argument count for exec().');\n          }\n          out.sql = util.flexibleString(out.sql);\n          if ('string' !== typeof out.sql) {\n            toss3('Missing SQL argument or unsupported SQL value type.');\n          }\n          const opt = out.opt;\n          switch (opt.returnValue) {\n            case 'resultRows':\n              if (!opt.resultRows) opt.resultRows = [];\n              out.returnVal = () => opt.resultRows;\n              break;\n            case 'saveSql':\n              if (!opt.saveSql) opt.saveSql = [];\n              out.returnVal = () => opt.saveSql;\n              break;\n            case undefined:\n            case 'this':\n              out.returnVal = () => db;\n              break;\n            default:\n              toss3('Invalid returnValue value:', opt.returnValue);\n          }\n          if (!opt.callback && !opt.returnValue && undefined !== opt.rowMode) {\n            if (!opt.resultRows) opt.resultRows = [];\n            out.returnVal = () => opt.resultRows;\n          }\n          if (opt.callback || opt.resultRows) {\n            switch (undefined === opt.rowMode ? 'array' : opt.rowMode) {\n              case 'object':\n                out.cbArg = (stmt, cache) => {\n                  if (!cache.columnNames)\n                    cache.columnNames = stmt.getColumnNames([]);\n\n                  const row = stmt.get([]);\n                  const rv = Object.create(null);\n                  for (const i in cache.columnNames)\n                    rv[cache.columnNames[i]] = row[i];\n                  return rv;\n                };\n                break;\n              case 'array':\n                out.cbArg = (stmt) => stmt.get([]);\n                break;\n              case 'stmt':\n                if (Array.isArray(opt.resultRows)) {\n                  toss3(\n                    'exec(): invalid rowMode for a resultRows array: must',\n                    \"be one of 'array', 'object',\",\n                    'a result column number, or column name reference.',\n                  );\n                }\n                out.cbArg = (stmt) => stmt;\n                break;\n              default:\n                if (util.isInt32(opt.rowMode)) {\n                  out.cbArg = (stmt) => stmt.get(opt.rowMode);\n                  break;\n                } else if (\n                  'string' === typeof opt.rowMode &&\n                  opt.rowMode.length > 1 &&\n                  '$' === opt.rowMode[0]\n                ) {\n                  const $colName = opt.rowMode.substr(1);\n                  out.cbArg = (stmt) => {\n                    const rc = stmt.get(Object.create(null))[$colName];\n                    return undefined === rc\n                      ? toss3(\n                          capi.SQLITE_NOTFOUND,\n                          'exec(): unknown result column:',\n                          $colName,\n                        )\n                      : rc;\n                  };\n                  break;\n                }\n                toss3('Invalid rowMode:', opt.rowMode);\n            }\n          }\n          return out;\n        };\n\n        const __selectFirstRow = (db, sql, bind, ...getArgs) => {\n          const stmt = db.prepare(sql);\n          try {\n            const rc = stmt.bind(bind).step()\n              ? stmt.get(...getArgs)\n              : undefined;\n            stmt.reset();\n            return rc;\n          } finally {\n            stmt.finalize();\n          }\n        };\n\n        const __selectAll = (db, sql, bind, rowMode) =>\n          db.exec({\n            sql,\n            bind,\n            rowMode,\n            returnValue: 'resultRows',\n          });\n\n        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);\n\n        DB.prototype = {\n          isOpen: function () {\n            return !!this.pointer;\n          },\n\n          affirmOpen: function () {\n            return affirmDbOpen(this);\n          },\n\n          close: function () {\n            if (this.pointer) {\n              if (this.onclose && this.onclose.before instanceof Function) {\n                try {\n                  this.onclose.before(this);\n                } catch (e) {}\n              }\n              const pDb = this.pointer;\n              Object.keys(__stmtMap.get(this)).forEach((k, s) => {\n                if (s && s.pointer) {\n                  try {\n                    s.finalize();\n                  } catch (e) {}\n                }\n              });\n              __ptrMap.delete(this);\n              __stmtMap.delete(this);\n              capi.sqlite3_close_v2(pDb);\n              if (this.onclose && this.onclose.after instanceof Function) {\n                try {\n                  this.onclose.after(this);\n                } catch (e) {}\n              }\n              delete this.filename;\n            }\n          },\n\n          changes: function (total = false, sixtyFour = false) {\n            const p = affirmDbOpen(this).pointer;\n            if (total) {\n              return sixtyFour\n                ? capi.sqlite3_total_changes64(p)\n                : capi.sqlite3_total_changes(p);\n            } else {\n              return sixtyFour\n                ? capi.sqlite3_changes64(p)\n                : capi.sqlite3_changes(p);\n            }\n          },\n\n          dbFilename: function (dbName = 'main') {\n            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);\n          },\n\n          dbName: function (dbNumber = 0) {\n            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);\n          },\n\n          dbVfsName: function (dbName = 0) {\n            let rc;\n            const pVfs = capi.sqlite3_js_db_vfs(\n              affirmDbOpen(this).pointer,\n              dbName,\n            );\n            if (pVfs) {\n              const v = new capi.sqlite3_vfs(pVfs);\n              try {\n                rc = wasm.cstrToJs(v.$zName);\n              } finally {\n                v.dispose();\n              }\n            }\n            return rc;\n          },\n\n          prepare: function (sql) {\n            affirmDbOpen(this);\n            const stack = wasm.pstack.pointer;\n            let ppStmt, pStmt;\n            try {\n              ppStmt = wasm.pstack.alloc(8);\n              DB.checkRc(\n                this,\n                capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null),\n              );\n              pStmt = wasm.peekPtr(ppStmt);\n            } finally {\n              wasm.pstack.restore(stack);\n            }\n            if (!pStmt) toss3('Cannot prepare empty SQL.');\n            const stmt = new Stmt(this, pStmt, BindTypes);\n            __stmtMap.get(this)[pStmt] = stmt;\n            return stmt;\n          },\n\n          exec: function () {\n            affirmDbOpen(this);\n            const arg = parseExecArgs(this, arguments);\n            if (!arg.sql) {\n              return toss3('exec() requires an SQL string.');\n            }\n            const opt = arg.opt;\n            const callback = opt.callback;\n            const resultRows = Array.isArray(opt.resultRows)\n              ? opt.resultRows\n              : undefined;\n            let stmt;\n            let bind = opt.bind;\n            let evalFirstResult = !!(\n              arg.cbArg ||\n              opt.columnNames ||\n              resultRows\n            );\n            const stack = wasm.scopedAllocPush();\n            const saveSql = Array.isArray(opt.saveSql)\n              ? opt.saveSql\n              : undefined;\n            try {\n              const isTA = util.isSQLableTypedArray(arg.sql);\n              let sqlByteLen = isTA\n                ? arg.sql.byteLength\n                : wasm.jstrlen(arg.sql);\n              const ppStmt = wasm.scopedAlloc(\n                2 * wasm.ptrSizeof + (sqlByteLen + 1),\n              );\n              const pzTail = ppStmt + wasm.ptrSizeof;\n              let pSql = pzTail + wasm.ptrSizeof;\n              const pSqlEnd = pSql + sqlByteLen;\n              if (isTA) wasm.heap8().set(arg.sql, pSql);\n              else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);\n              wasm.poke(pSql + sqlByteLen, 0);\n              while (pSql && wasm.peek(pSql, 'i8')) {\n                wasm.pokePtr([ppStmt, pzTail], 0);\n                DB.checkRc(\n                  this,\n                  capi.sqlite3_prepare_v3(\n                    this.pointer,\n                    pSql,\n                    sqlByteLen,\n                    0,\n                    ppStmt,\n                    pzTail,\n                  ),\n                );\n                const pStmt = wasm.peekPtr(ppStmt);\n                pSql = wasm.peekPtr(pzTail);\n                sqlByteLen = pSqlEnd - pSql;\n                if (!pStmt) continue;\n                if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());\n                stmt = new Stmt(this, pStmt, BindTypes);\n                if (bind && stmt.parameterCount) {\n                  stmt.bind(bind);\n                  bind = null;\n                }\n                if (evalFirstResult && stmt.columnCount) {\n                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;\n                  evalFirstResult = false;\n                  if (arg.cbArg || resultRows) {\n                    const cbArgCache = Object.create(null);\n                    for (; stmt.step(); stmt._lockedByExec = false) {\n                      if (0 === gotColNames++) {\n                        stmt.getColumnNames(\n                          (cbArgCache.columnNames = opt.columnNames || []),\n                        );\n                      }\n                      stmt._lockedByExec = true;\n                      const row = arg.cbArg(stmt, cbArgCache);\n                      if (resultRows) resultRows.push(row);\n                      if (callback && false === callback.call(opt, row, stmt)) {\n                        break;\n                      }\n                    }\n                    stmt._lockedByExec = false;\n                  }\n                  if (0 === gotColNames) {\n                    stmt.getColumnNames(opt.columnNames);\n                  }\n                } else {\n                  stmt.step();\n                }\n                stmt.reset().finalize();\n                stmt = null;\n              }\n            } finally {\n              wasm.scopedAllocPop(stack);\n              if (stmt) {\n                delete stmt._lockedByExec;\n                stmt.finalize();\n              }\n            }\n            return arg.returnVal();\n          },\n\n          createFunction: function f(name, xFunc, opt) {\n            const isFunc = (f) => f instanceof Function;\n            switch (arguments.length) {\n              case 1:\n                opt = name;\n                name = opt.name;\n                xFunc = opt.xFunc || 0;\n                break;\n              case 2:\n                if (!isFunc(xFunc)) {\n                  opt = xFunc;\n                  xFunc = opt.xFunc || 0;\n                }\n                break;\n              case 3:\n                break;\n              default:\n                break;\n            }\n            if (!opt) opt = {};\n            if ('string' !== typeof name) {\n              toss3('Invalid arguments: missing function name.');\n            }\n            let xStep = opt.xStep || 0;\n            let xFinal = opt.xFinal || 0;\n            const xValue = opt.xValue || 0;\n            const xInverse = opt.xInverse || 0;\n            let isWindow = undefined;\n            if (isFunc(xFunc)) {\n              isWindow = false;\n              if (isFunc(xStep) || isFunc(xFinal)) {\n                toss3('Ambiguous arguments: scalar or aggregate?');\n              }\n              xStep = xFinal = null;\n            } else if (isFunc(xStep)) {\n              if (!isFunc(xFinal)) {\n                toss3('Missing xFinal() callback for aggregate or window UDF.');\n              }\n              xFunc = null;\n            } else if (isFunc(xFinal)) {\n              toss3('Missing xStep() callback for aggregate or window UDF.');\n            } else {\n              toss3('Missing function-type properties.');\n            }\n            if (false === isWindow) {\n              if (isFunc(xValue) || isFunc(xInverse)) {\n                toss3(\n                  'xValue and xInverse are not permitted for non-window UDFs.',\n                );\n              }\n            } else if (isFunc(xValue)) {\n              if (!isFunc(xInverse)) {\n                toss3('xInverse must be provided if xValue is.');\n              }\n              isWindow = true;\n            } else if (isFunc(xInverse)) {\n              toss3('xValue must be provided if xInverse is.');\n            }\n            const pApp = opt.pApp;\n            if (\n              undefined !== pApp &&\n              null !== pApp &&\n              ('number' !== typeof pApp || !util.isInt32(pApp))\n            ) {\n              toss3(\n                'Invalid value for pApp property. Must be a legal WASM pointer value.',\n              );\n            }\n            const xDestroy = opt.xDestroy || 0;\n            if (xDestroy && !isFunc(xDestroy)) {\n              toss3('xDestroy property must be a function.');\n            }\n            let fFlags = 0;\n            if (getOwnOption(opt, 'deterministic'))\n              fFlags |= capi.SQLITE_DETERMINISTIC;\n            if (getOwnOption(opt, 'directOnly'))\n              fFlags |= capi.SQLITE_DIRECTONLY;\n            if (getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;\n            name = name.toLowerCase();\n            const xArity = xFunc || xStep;\n            const arity = getOwnOption(opt, 'arity');\n            const arityArg =\n              'number' === typeof arity\n                ? arity\n                : xArity.length\n                  ? xArity.length - 1\n                  : 0;\n            let rc;\n            if (isWindow) {\n              rc = capi.sqlite3_create_window_function(\n                this.pointer,\n                name,\n                arityArg,\n                capi.SQLITE_UTF8 | fFlags,\n                pApp || 0,\n                xStep,\n                xFinal,\n                xValue,\n                xInverse,\n                xDestroy,\n              );\n            } else {\n              rc = capi.sqlite3_create_function_v2(\n                this.pointer,\n                name,\n                arityArg,\n                capi.SQLITE_UTF8 | fFlags,\n                pApp || 0,\n                xFunc,\n                xStep,\n                xFinal,\n                xDestroy,\n              );\n            }\n            DB.checkRc(this, rc);\n            return this;\n          },\n\n          selectValue: function (sql, bind, asType) {\n            return __selectFirstRow(this, sql, bind, 0, asType);\n          },\n\n          selectValues: function (sql, bind, asType) {\n            const stmt = this.prepare(sql),\n              rc = [];\n            try {\n              stmt.bind(bind);\n              while (stmt.step()) rc.push(stmt.get(0, asType));\n              stmt.reset();\n            } finally {\n              stmt.finalize();\n            }\n            return rc;\n          },\n\n          selectArray: function (sql, bind) {\n            return __selectFirstRow(this, sql, bind, []);\n          },\n\n          selectObject: function (sql, bind) {\n            return __selectFirstRow(this, sql, bind, {});\n          },\n\n          selectArrays: function (sql, bind) {\n            return __selectAll(this, sql, bind, 'array');\n          },\n\n          selectObjects: function (sql, bind) {\n            return __selectAll(this, sql, bind, 'object');\n          },\n\n          openStatementCount: function () {\n            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;\n          },\n\n          transaction: function (callback) {\n            let opener = 'BEGIN';\n            if (arguments.length > 1) {\n              if (/[^a-zA-Z]/.test(arguments[0])) {\n                toss3(\n                  capi.SQLITE_MISUSE,\n                  'Invalid argument for BEGIN qualifier.',\n                );\n              }\n              opener += ' ' + arguments[0];\n              callback = arguments[1];\n            }\n            affirmDbOpen(this).exec(opener);\n            try {\n              const rc = callback(this);\n              this.exec('COMMIT');\n              return rc;\n            } catch (e) {\n              this.exec('ROLLBACK');\n              throw e;\n            }\n          },\n\n          savepoint: function (callback) {\n            affirmDbOpen(this).exec('SAVEPOINT oo1');\n            try {\n              const rc = callback(this);\n              this.exec('RELEASE oo1');\n              return rc;\n            } catch (e) {\n              this.exec('ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1');\n              throw e;\n            }\n          },\n\n          checkRc: function (resultCode) {\n            return checkSqlite3Rc(this, resultCode);\n          },\n        };\n\n        const affirmStmtOpen = function (stmt) {\n          if (!stmt.pointer) toss3('Stmt has been closed.');\n          return stmt;\n        };\n\n        const isSupportedBindType = function (v) {\n          let t = BindTypes[null === v || undefined === v ? 'null' : typeof v];\n          switch (t) {\n            case BindTypes.boolean:\n            case BindTypes.null:\n            case BindTypes.number:\n            case BindTypes.string:\n              return t;\n            case BindTypes.bigint:\n              if (wasm.bigIntEnabled) return t;\n\n            default:\n              return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;\n          }\n        };\n\n        const affirmSupportedBindType = function (v) {\n          return (\n            isSupportedBindType(v) ||\n            toss3('Unsupported bind() argument type:', typeof v)\n          );\n        };\n\n        const affirmParamIndex = function (stmt, key) {\n          const n =\n            'number' === typeof key\n              ? key\n              : capi.sqlite3_bind_parameter_index(stmt.pointer, key);\n          if (0 === n || !util.isInt32(n)) {\n            toss3('Invalid bind() parameter name: ' + key);\n          } else if (n < 1 || n > stmt.parameterCount)\n            toss3('Bind index', key, 'is out of range.');\n          return n;\n        };\n\n        const affirmNotLockedByExec = function (stmt, currentOpName) {\n          if (stmt._lockedByExec) {\n            toss3(\n              'Operation is illegal when statement is locked:',\n              currentOpName,\n            );\n          }\n          return stmt;\n        };\n\n        const bindOne = function f(stmt, ndx, bindType, val) {\n          affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');\n          if (!f._) {\n            f._tooBigInt = (v) =>\n              toss3(\n                'BigInt value is too big to store without precision loss:',\n                v,\n              );\n            f._ = {\n              string: function (stmt, ndx, val, asBlob) {\n                const [pStr, n] = wasm.allocCString(val, true);\n                const f = asBlob\n                  ? capi.sqlite3_bind_blob\n                  : capi.sqlite3_bind_text;\n                return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);\n              },\n            };\n          }\n          affirmSupportedBindType(val);\n          ndx = affirmParamIndex(stmt, ndx);\n          let rc = 0;\n          switch (\n            null === val || undefined === val ? BindTypes.null : bindType\n          ) {\n            case BindTypes.null:\n              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);\n              break;\n            case BindTypes.string:\n              rc = f._.string(stmt, ndx, val, false);\n              break;\n            case BindTypes.number: {\n              let m;\n              if (util.isInt32(val)) m = capi.sqlite3_bind_int;\n              else if ('bigint' === typeof val) {\n                if (!util.bigIntFits64(val)) {\n                  f._tooBigInt(val);\n                } else if (wasm.bigIntEnabled) {\n                  m = capi.sqlite3_bind_int64;\n                } else if (util.bigIntFitsDouble(val)) {\n                  val = Number(val);\n                  m = capi.sqlite3_bind_double;\n                } else {\n                  f._tooBigInt(val);\n                }\n              } else {\n                val = Number(val);\n                if (wasm.bigIntEnabled && Number.isInteger(val)) {\n                  m = capi.sqlite3_bind_int64;\n                } else {\n                  m = capi.sqlite3_bind_double;\n                }\n              }\n              rc = m(stmt.pointer, ndx, val);\n              break;\n            }\n            case BindTypes.boolean:\n              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);\n              break;\n            case BindTypes.blob: {\n              if ('string' === typeof val) {\n                rc = f._.string(stmt, ndx, val, true);\n                break;\n              } else if (val instanceof ArrayBuffer) {\n                val = new Uint8Array(val);\n              } else if (!util.isBindableTypedArray(val)) {\n                toss3(\n                  'Binding a value as a blob requires',\n                  'that it be a string, Uint8Array, Int8Array, or ArrayBuffer.',\n                );\n              }\n              const pBlob = wasm.alloc(val.byteLength || 1);\n              wasm.heap8().set(val.byteLength ? val : [0], pBlob);\n              rc = capi.sqlite3_bind_blob(\n                stmt.pointer,\n                ndx,\n                pBlob,\n                val.byteLength,\n                capi.SQLITE_WASM_DEALLOC,\n              );\n              break;\n            }\n            default:\n              sqlite3.config.warn('Unsupported bind() argument type:', val);\n              toss3('Unsupported bind() argument type: ' + typeof val);\n          }\n          if (rc) DB.checkRc(stmt.db.pointer, rc);\n          stmt._mayGet = false;\n          return stmt;\n        };\n\n        Stmt.prototype = {\n          finalize: function () {\n            if (this.pointer) {\n              affirmNotLockedByExec(this, 'finalize()');\n              const rc = capi.sqlite3_finalize(this.pointer);\n              delete __stmtMap.get(this.db)[this.pointer];\n              __ptrMap.delete(this);\n              delete this._mayGet;\n              delete this.parameterCount;\n              delete this._lockedByExec;\n              delete this.db;\n              return rc;\n            }\n          },\n\n          clearBindings: function () {\n            affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()');\n            capi.sqlite3_clear_bindings(this.pointer);\n            this._mayGet = false;\n            return this;\n          },\n\n          reset: function (alsoClearBinds) {\n            affirmNotLockedByExec(this, 'reset()');\n            if (alsoClearBinds) this.clearBindings();\n            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);\n            this._mayGet = false;\n            checkSqlite3Rc(this.db, rc);\n            return this;\n          },\n\n          bind: function () {\n            affirmStmtOpen(this);\n            let ndx, arg;\n            switch (arguments.length) {\n              case 1:\n                ndx = 1;\n                arg = arguments[0];\n                break;\n              case 2:\n                ndx = arguments[0];\n                arg = arguments[1];\n                break;\n              default:\n                toss3('Invalid bind() arguments.');\n            }\n            if (undefined === arg) {\n              return this;\n            } else if (!this.parameterCount) {\n              toss3('This statement has no bindable parameters.');\n            }\n            this._mayGet = false;\n            if (null === arg) {\n              return bindOne(this, ndx, BindTypes.null, arg);\n            } else if (Array.isArray(arg)) {\n              if (1 !== arguments.length) {\n                toss3(\n                  'When binding an array, an index argument is not permitted.',\n                );\n              }\n              arg.forEach((v, i) =>\n                bindOne(this, i + 1, affirmSupportedBindType(v), v),\n              );\n              return this;\n            } else if (arg instanceof ArrayBuffer) {\n              arg = new Uint8Array(arg);\n            }\n            if ('object' === typeof arg && !util.isBindableTypedArray(arg)) {\n              if (1 !== arguments.length) {\n                toss3(\n                  'When binding an object, an index argument is not permitted.',\n                );\n              }\n              Object.keys(arg).forEach((k) =>\n                bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k]),\n              );\n              return this;\n            } else {\n              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);\n            }\n            toss3('Should not reach this point.');\n          },\n\n          bindAsBlob: function (ndx, arg) {\n            affirmStmtOpen(this);\n            if (1 === arguments.length) {\n              arg = ndx;\n              ndx = 1;\n            }\n            const t = affirmSupportedBindType(arg);\n            if (\n              BindTypes.string !== t &&\n              BindTypes.blob !== t &&\n              BindTypes.null !== t\n            ) {\n              toss3('Invalid value type for bindAsBlob()');\n            }\n            return bindOne(this, ndx, BindTypes.blob, arg);\n          },\n\n          step: function () {\n            affirmNotLockedByExec(this, 'step()');\n            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);\n            switch (rc) {\n              case capi.SQLITE_DONE:\n                return (this._mayGet = false);\n              case capi.SQLITE_ROW:\n                return (this._mayGet = true);\n              default:\n                this._mayGet = false;\n                sqlite3.config.warn(\n                  'sqlite3_step() rc=',\n                  rc,\n                  capi.sqlite3_js_rc_str(rc),\n                  'SQL =',\n                  capi.sqlite3_sql(this.pointer),\n                );\n                DB.checkRc(this.db.pointer, rc);\n            }\n          },\n\n          stepReset: function () {\n            this.step();\n            return this.reset();\n          },\n\n          stepFinalize: function () {\n            try {\n              const rc = this.step();\n              this.reset();\n              return rc;\n            } finally {\n              try {\n                this.finalize();\n              } catch (e) {}\n            }\n          },\n\n          get: function (ndx, asType) {\n            if (!affirmStmtOpen(this)._mayGet) {\n              toss3('Stmt.step() has not (recently) returned true.');\n            }\n            if (Array.isArray(ndx)) {\n              let i = 0;\n              const n = this.columnCount;\n              while (i < n) {\n                ndx[i] = this.get(i++);\n              }\n              return ndx;\n            } else if (ndx && 'object' === typeof ndx) {\n              let i = 0;\n              const n = this.columnCount;\n              while (i < n) {\n                ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);\n              }\n              return ndx;\n            }\n            affirmColIndex(this, ndx);\n            switch (\n              undefined === asType\n                ? capi.sqlite3_column_type(this.pointer, ndx)\n                : asType\n            ) {\n              case capi.SQLITE_NULL:\n                return null;\n              case capi.SQLITE_INTEGER: {\n                if (wasm.bigIntEnabled) {\n                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);\n                  if (\n                    rc >= Number.MIN_SAFE_INTEGER &&\n                    rc <= Number.MAX_SAFE_INTEGER\n                  ) {\n                    return Number(rc).valueOf();\n                  }\n                  return rc;\n                } else {\n                  const rc = capi.sqlite3_column_double(this.pointer, ndx);\n                  if (\n                    rc > Number.MAX_SAFE_INTEGER ||\n                    rc < Number.MIN_SAFE_INTEGER\n                  ) {\n                    toss3(\n                      'Integer is out of range for JS integer range: ' + rc,\n                    );\n                  }\n\n                  return util.isInt32(rc) ? rc | 0 : rc;\n                }\n              }\n              case capi.SQLITE_FLOAT:\n                return capi.sqlite3_column_double(this.pointer, ndx);\n              case capi.SQLITE_TEXT:\n                return capi.sqlite3_column_text(this.pointer, ndx);\n              case capi.SQLITE_BLOB: {\n                const n = capi.sqlite3_column_bytes(this.pointer, ndx),\n                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),\n                  rc = new Uint8Array(n);\n\n                if (n) rc.set(wasm.heap8u().slice(ptr, ptr + n), 0);\n\n                if (n && this.db._blobXfer instanceof Array) {\n                  this.db._blobXfer.push(rc.buffer);\n                }\n                return rc;\n              }\n              default:\n                toss3(\n                  \"Don't know how to translate\",\n                  'type of result column #' + ndx + '.',\n                );\n            }\n            toss3('Not reached.');\n          },\n\n          getInt: function (ndx) {\n            return this.get(ndx, capi.SQLITE_INTEGER);\n          },\n\n          getFloat: function (ndx) {\n            return this.get(ndx, capi.SQLITE_FLOAT);\n          },\n\n          getString: function (ndx) {\n            return this.get(ndx, capi.SQLITE_TEXT);\n          },\n\n          getBlob: function (ndx) {\n            return this.get(ndx, capi.SQLITE_BLOB);\n          },\n\n          getJSON: function (ndx) {\n            const s = this.get(ndx, capi.SQLITE_STRING);\n            return null === s ? s : JSON.parse(s);\n          },\n\n          getColumnName: function (ndx) {\n            return capi.sqlite3_column_name(\n              affirmColIndex(affirmStmtOpen(this), ndx).pointer,\n              ndx,\n            );\n          },\n\n          getColumnNames: function (tgt = []) {\n            affirmColIndex(affirmStmtOpen(this), 0);\n            const n = this.columnCount;\n            for (let i = 0; i < n; ++i) {\n              tgt.push(capi.sqlite3_column_name(this.pointer, i));\n            }\n            return tgt;\n          },\n\n          getParamIndex: function (name) {\n            return affirmStmtOpen(this).parameterCount\n              ? capi.sqlite3_bind_parameter_index(this.pointer, name)\n              : undefined;\n          },\n\n          getParamName: function (ndx) {\n            return affirmStmtOpen(this).parameterCount\n              ? capi.sqlite3_bind_parameter_name(this.pointer, ndx)\n              : undefined;\n          },\n\n          isBusy: function () {\n            return 0 !== capi.sqlite3_stmt_busy(affirmStmtOpen(this));\n          },\n\n          isReadOnly: function () {\n            return 0 !== capi.sqlite3_stmt_readonly(affirmStmtOpen(this));\n          },\n        };\n\n        {\n          const prop = {\n            enumerable: true,\n            get: function () {\n              return __ptrMap.get(this);\n            },\n            set: () => toss3('The pointer property is read-only.'),\n          };\n          Object.defineProperty(Stmt.prototype, 'pointer', prop);\n          Object.defineProperty(DB.prototype, 'pointer', prop);\n        }\n\n        Object.defineProperty(Stmt.prototype, 'columnCount', {\n          enumerable: false,\n          get: function () {\n            return capi.sqlite3_column_count(this.pointer);\n          },\n          set: () => toss3('The columnCount property is read-only.'),\n        });\n\n        sqlite3.oo1 = {\n          DB,\n          Stmt,\n        };\n\n        if (util.isUIThread()) {\n          sqlite3.oo1.JsStorageDb = function (storageName = 'session') {\n            const opt = dbCtorHelper.normalizeArgs(...arguments);\n            storageName = opt.filename;\n            if ('session' !== storageName && 'local' !== storageName) {\n              toss3(\"JsStorageDb db name must be one of 'session' or 'local'.\");\n            }\n            opt.vfs = 'kvvfs';\n            dbCtorHelper.call(this, opt);\n          };\n          const jdb = sqlite3.oo1.JsStorageDb;\n          jdb.prototype = Object.create(DB.prototype);\n\n          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;\n\n          jdb.prototype.clearStorage = function () {\n            return jdb.clearStorage(affirmDbOpen(this).filename);\n          };\n\n          jdb.storageSize = capi.sqlite3_js_kvvfs_size;\n\n          jdb.prototype.storageSize = function () {\n            return jdb.storageSize(affirmDbOpen(this).filename);\n          };\n        }\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const util = sqlite3.util;\n        sqlite3.initWorker1API = function () {\n          'use strict';\n          const toss = (...args) => {\n            throw new Error(args.join(' '));\n          };\n          if (!(globalThis.WorkerGlobalScope instanceof Function)) {\n            toss('initWorker1API() must be run from a Worker thread.');\n          }\n          const sqlite3 = this.sqlite3 || toss('Missing this.sqlite3 object.');\n          const DB = sqlite3.oo1.DB;\n\n          const getDbId = function (db) {\n            let id = wState.idMap.get(db);\n            if (id) return id;\n            id = 'db#' + ++wState.idSeq + '@' + db.pointer;\n\n            wState.idMap.set(db, id);\n            return id;\n          };\n\n          const wState = {\n            dbList: [],\n\n            idSeq: 0,\n\n            idMap: new WeakMap(),\n\n            xfer: [],\n            open: function (opt) {\n              const db = new DB(opt);\n              this.dbs[getDbId(db)] = db;\n              if (this.dbList.indexOf(db) < 0) this.dbList.push(db);\n              return db;\n            },\n            close: function (db, alsoUnlink) {\n              if (db) {\n                delete this.dbs[getDbId(db)];\n                const filename = db.filename;\n                const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);\n                db.close();\n                const ddNdx = this.dbList.indexOf(db);\n                if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);\n                if (alsoUnlink && filename && pVfs) {\n                  util.sqlite3__wasm_vfs_unlink(pVfs, filename);\n                }\n              }\n            },\n\n            post: function (msg, xferList) {\n              if (xferList && xferList.length) {\n                globalThis.postMessage(msg, Array.from(xferList));\n                xferList.length = 0;\n              } else {\n                globalThis.postMessage(msg);\n              }\n            },\n\n            dbs: Object.create(null),\n\n            getDb: function (id, require = true) {\n              return (\n                this.dbs[id] ||\n                (require ? toss('Unknown (or closed) DB ID:', id) : undefined)\n              );\n            },\n          };\n\n          const affirmDbOpen = function (db = wState.dbList[0]) {\n            return db && db.pointer ? db : toss('DB is not opened.');\n          };\n\n          const getMsgDb = function (msgData, affirmExists = true) {\n            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];\n            return affirmExists ? affirmDbOpen(db) : db;\n          };\n\n          const getDefaultDbId = function () {\n            return wState.dbList[0] && getDbId(wState.dbList[0]);\n          };\n\n          const isSpecialDbFilename = (n) => {\n            return '' === n || ':' === n[0];\n          };\n\n          const wMsgHandler = {\n            open: function (ev) {\n              const oargs = Object.create(null),\n                args = ev.args || Object.create(null);\n              if (args.simulateError) {\n                toss('Throwing because of simulateError flag.');\n              }\n              const rc = Object.create(null);\n              oargs.vfs = args.vfs;\n              oargs.filename = args.filename || '';\n              const db = wState.open(oargs);\n              rc.filename = db.filename;\n              rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(\n                db.pointer,\n                'opfs',\n              );\n              rc.dbId = getDbId(db);\n              rc.vfs = db.dbVfsName();\n              return rc;\n            },\n\n            close: function (ev) {\n              const db = getMsgDb(ev, false);\n              const response = {\n                filename: db && db.filename,\n              };\n              if (db) {\n                const doUnlink =\n                  ev.args && 'object' === typeof ev.args\n                    ? !!ev.args.unlink\n                    : false;\n                wState.close(db, doUnlink);\n              }\n              return response;\n            },\n\n            exec: function (ev) {\n              const rc =\n                'string' === typeof ev.args\n                  ? { sql: ev.args }\n                  : ev.args || Object.create(null);\n              if ('stmt' === rc.rowMode) {\n                toss(\n                  \"Invalid rowMode for 'exec': stmt mode\",\n                  'does not work in the Worker API.',\n                );\n              } else if (!rc.sql) {\n                toss(\"'exec' requires input SQL.\");\n              }\n              const db = getMsgDb(ev);\n              if (rc.callback || Array.isArray(rc.resultRows)) {\n                db._blobXfer = wState.xfer;\n              }\n              const theCallback = rc.callback;\n              let rowNumber = 0;\n              const hadColNames = !!rc.columnNames;\n              if ('string' === typeof theCallback) {\n                if (!hadColNames) rc.columnNames = [];\n\n                rc.callback = function (row, stmt) {\n                  wState.post(\n                    {\n                      type: theCallback,\n                      columnNames: rc.columnNames,\n                      rowNumber: ++rowNumber,\n                      row: row,\n                    },\n                    wState.xfer,\n                  );\n                };\n              }\n              try {\n                const changeCount = !!rc.countChanges\n                  ? db.changes(true, 64 === rc.countChanges)\n                  : undefined;\n                db.exec(rc);\n                if (undefined !== changeCount) {\n                  rc.changeCount =\n                    db.changes(true, 64 === rc.countChanges) - changeCount;\n                }\n                const lastInsertRowId = !!rc.lastInsertRowId\n                  ? sqlite3.capi.sqlite3_last_insert_rowid(db)\n                  : undefined;\n                if (undefined !== lastInsertRowId) {\n                  rc.lastInsertRowId = lastInsertRowId;\n                }\n                if (rc.callback instanceof Function) {\n                  rc.callback = theCallback;\n\n                  wState.post({\n                    type: theCallback,\n                    columnNames: rc.columnNames,\n                    rowNumber: null,\n                    row: undefined,\n                  });\n                }\n              } finally {\n                delete db._blobXfer;\n                if (rc.callback) rc.callback = theCallback;\n              }\n              return rc;\n            },\n\n            'config-get': function () {\n              const rc = Object.create(null),\n                src = sqlite3.config;\n              ['bigIntEnabled'].forEach(function (k) {\n                if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];\n              });\n              rc.version = sqlite3.version;\n              rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();\n              return rc;\n            },\n\n            export: function (ev) {\n              const db = getMsgDb(ev);\n              const response = {\n                byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),\n                filename: db.filename,\n                mimetype: 'application/x-sqlite3',\n              };\n              wState.xfer.push(response.byteArray.buffer);\n              return response;\n            },\n\n            toss: function (ev) {\n              toss('Testing worker exception');\n            },\n          };\n\n          globalThis.onmessage = async function (ev) {\n            ev = ev.data;\n            let result,\n              dbId = ev.dbId,\n              evType = ev.type;\n            const arrivalTime = performance.now();\n            try {\n              if (\n                wMsgHandler.hasOwnProperty(evType) &&\n                wMsgHandler[evType] instanceof Function\n              ) {\n                result = await wMsgHandler[evType](ev);\n              } else {\n                toss('Unknown db worker message type:', ev.type);\n              }\n            } catch (err) {\n              evType = 'error';\n              result = {\n                operation: ev.type,\n                message: err.message,\n                errorClass: err.name,\n                input: ev,\n              };\n              if (err.stack) {\n                result.stack =\n                  'string' === typeof err.stack\n                    ? err.stack.split(/\\n\\s*/)\n                    : err.stack;\n              }\n              if (false)\n                {}\n            }\n            if (!dbId) {\n              dbId = result.dbId || getDefaultDbId();\n            }\n\n            wState.post(\n              {\n                type: evType,\n                dbId: dbId,\n                messageId: ev.messageId,\n                workerReceivedTime: arrivalTime,\n                workerRespondTime: performance.now(),\n                departureTime: ev.departureTime,\n\n                result: result,\n              },\n              wState.xfer,\n            );\n          };\n          globalThis.postMessage({\n            type: 'sqlite3-api',\n            result: 'worker1-ready',\n          });\n        }.bind({ sqlite3 });\n      });\n\n      ('use strict');\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const wasm = sqlite3.wasm,\n          capi = sqlite3.capi,\n          toss = sqlite3.util.toss3;\n        const vfs = Object.create(null);\n        sqlite3.vfs = vfs;\n\n        capi.sqlite3_vfs.prototype.registerVfs = function (asDefault = false) {\n          if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {\n            toss('Expecting a sqlite3_vfs-type argument.');\n          }\n          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);\n          if (rc) {\n            toss('sqlite3_vfs_register(', this, ') failed with rc', rc);\n          }\n          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {\n            toss(\n              'BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS',\n              this,\n            );\n          }\n          return this;\n        };\n\n        vfs.installVfs = function (opt) {\n          let count = 0;\n          const propList = ['io', 'vfs'];\n          for (const key of propList) {\n            const o = opt[key];\n            if (o) {\n              ++count;\n              o.struct.installMethods(o.methods, !!o.applyArgcCheck);\n              if ('vfs' === key) {\n                if (!o.struct.$zName && 'string' === typeof o.name) {\n                  o.struct.addOnDispose(\n                    (o.struct.$zName = wasm.allocCString(o.name)),\n                  );\n                }\n                o.struct.registerVfs(!!o.asDefault);\n              }\n            }\n          }\n          if (!count)\n            toss(\n              'Misuse: installVfs() options object requires at least',\n              'one of:',\n              propList,\n            );\n          return this;\n        };\n      });\n\n      ('use strict');\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        if (!sqlite3.wasm.exports.sqlite3_declare_vtab) {\n          return;\n        }\n        const wasm = sqlite3.wasm,\n          capi = sqlite3.capi,\n          toss = sqlite3.util.toss3;\n        const vtab = Object.create(null);\n        sqlite3.vtab = vtab;\n\n        const sii = capi.sqlite3_index_info;\n\n        sii.prototype.nthConstraint = function (n, asPtr = false) {\n          if (n < 0 || n >= this.$nConstraint) return false;\n          const ptr =\n            this.$aConstraint +\n            sii.sqlite3_index_constraint.structInfo.sizeof * n;\n          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);\n        };\n\n        sii.prototype.nthConstraintUsage = function (n, asPtr = false) {\n          if (n < 0 || n >= this.$nConstraint) return false;\n          const ptr =\n            this.$aConstraintUsage +\n            sii.sqlite3_index_constraint_usage.structInfo.sizeof * n;\n          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);\n        };\n\n        sii.prototype.nthOrderBy = function (n, asPtr = false) {\n          if (n < 0 || n >= this.$nOrderBy) return false;\n          const ptr =\n            this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n;\n          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);\n        };\n\n        const __xWrapFactory = function (methodName, StructType) {\n          return function (ptr, removeMapping = false) {\n            if (0 === arguments.length) ptr = new StructType();\n            if (ptr instanceof StructType) {\n              this.set(ptr.pointer, ptr);\n              return ptr;\n            } else if (!wasm.isPtr(ptr)) {\n              sqlite3.SQLite3Error.toss(\n                'Invalid argument to',\n                methodName + '()',\n              );\n            }\n            let rc = this.get(ptr);\n            if (removeMapping) this.delete(ptr);\n            return rc;\n          }.bind(new Map());\n        };\n\n        const StructPtrMapper = function (name, StructType) {\n          const __xWrap = __xWrapFactory(name, StructType);\n\n          return Object.assign(Object.create(null), {\n            StructType,\n\n            create: (ppOut) => {\n              const rc = __xWrap();\n              wasm.pokePtr(ppOut, rc.pointer);\n              return rc;\n            },\n\n            get: (pCObj) => __xWrap(pCObj),\n\n            unget: (pCObj) => __xWrap(pCObj, true),\n\n            dispose: (pCObj) => {\n              const o = __xWrap(pCObj, true);\n              if (o) o.dispose();\n            },\n          });\n        };\n\n        vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);\n\n        vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);\n\n        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);\n\n        vtab.xError = function f(methodName, err, defaultRc) {\n          if (f.errorReporter instanceof Function) {\n            try {\n              f.errorReporter(\n                'sqlite3_module::' + methodName + '(): ' + err.message,\n              );\n            } catch (e) {}\n          }\n          let rc;\n          if (err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;\n          else if (arguments.length > 2) rc = defaultRc;\n          else if (err instanceof sqlite3.SQLite3Error) rc = err.resultCode;\n          return rc || capi.SQLITE_ERROR;\n        };\n        vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;\n\n        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, 'i64');\n\n        vtab.setupModule = function (opt) {\n          let createdMod = false;\n          const mod =\n            this instanceof capi.sqlite3_module\n              ? this\n              : opt.struct || (createdMod = new capi.sqlite3_module());\n          try {\n            const methods = opt.methods || toss(\"Missing 'methods' object.\");\n            for (const e of Object.entries({\n              xConnect: 'xCreate',\n              xDisconnect: 'xDestroy',\n            })) {\n              const k = e[0],\n                v = e[1];\n              if (true === methods[k]) methods[k] = methods[v];\n              else if (true === methods[v]) methods[v] = methods[k];\n            }\n            if (opt.catchExceptions) {\n              const fwrap = function (methodName, func) {\n                if (['xConnect', 'xCreate'].indexOf(methodName) >= 0) {\n                  return function (pDb, pAux, argc, argv, ppVtab, pzErr) {\n                    try {\n                      return func(...arguments) || 0;\n                    } catch (e) {\n                      if (!(e instanceof sqlite3.WasmAllocError)) {\n                        wasm.dealloc(wasm.peekPtr(pzErr));\n                        wasm.pokePtr(pzErr, wasm.allocCString(e.message));\n                      }\n                      return vtab.xError(methodName, e);\n                    }\n                  };\n                } else {\n                  return function (...args) {\n                    try {\n                      return func(...args) || 0;\n                    } catch (e) {\n                      return vtab.xError(methodName, e);\n                    }\n                  };\n                }\n              };\n              const mnames = [\n                'xCreate',\n                'xConnect',\n                'xBestIndex',\n                'xDisconnect',\n                'xDestroy',\n                'xOpen',\n                'xClose',\n                'xFilter',\n                'xNext',\n                'xEof',\n                'xColumn',\n                'xRowid',\n                'xUpdate',\n                'xBegin',\n                'xSync',\n                'xCommit',\n                'xRollback',\n                'xFindFunction',\n                'xRename',\n                'xSavepoint',\n                'xRelease',\n                'xRollbackTo',\n                'xShadowName',\n              ];\n              const remethods = Object.create(null);\n              for (const k of mnames) {\n                const m = methods[k];\n                if (!(m instanceof Function)) continue;\n                else if ('xConnect' === k && methods.xCreate === m) {\n                  remethods[k] = methods.xCreate;\n                } else if ('xCreate' === k && methods.xConnect === m) {\n                  remethods[k] = methods.xConnect;\n                } else {\n                  remethods[k] = fwrap(k, m);\n                }\n              }\n              mod.installMethods(remethods, false);\n            } else {\n              mod.installMethods(methods, !!opt.applyArgcCheck);\n            }\n            if (0 === mod.$iVersion) {\n              let v;\n              if ('number' === typeof opt.iVersion) v = opt.iVersion;\n              else if (mod.$xShadowName) v = 3;\n              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)\n                v = 2;\n              else v = 1;\n              mod.$iVersion = v;\n            }\n          } catch (e) {\n            if (createdMod) createdMod.dispose();\n            throw e;\n          }\n          return mod;\n        };\n\n        capi.sqlite3_module.prototype.setupModule = function (opt) {\n          return vtab.setupModule.call(this, opt);\n        };\n      });\n\n      ('use strict');\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        const installOpfsVfs = function callee(options) {\n          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {\n            return Promise.reject(\n              new Error(\n                'Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. ' +\n                  'The server must emit the COOP/COEP response headers to enable those. ' +\n                  'See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep',\n              ),\n            );\n          } else if ('undefined' === typeof WorkerGlobalScope) {\n            return Promise.reject(\n              new Error(\n                'The OPFS sqlite3_vfs cannot run in the main thread ' +\n                  'because it requires Atomics.wait().',\n              ),\n            );\n          } else if (\n            !globalThis.FileSystemHandle ||\n            !globalThis.FileSystemDirectoryHandle ||\n            !globalThis.FileSystemFileHandle ||\n            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||\n            !navigator?.storage?.getDirectory\n          ) {\n            return Promise.reject(new Error('Missing required OPFS APIs.'));\n          }\n          if (!options || 'object' !== typeof options) {\n            options = Object.create(null);\n          }\n          const urlParams = new URL(globalThis.location.href).searchParams;\n          if (urlParams.has('opfs-disable')) {\n            return Promise.resolve(sqlite3);\n          }\n          if (undefined === options.verbose) {\n            options.verbose = urlParams.has('opfs-verbose')\n              ? +urlParams.get('opfs-verbose') || 2\n              : 1;\n          }\n          if (undefined === options.sanityChecks) {\n            options.sanityChecks = urlParams.has('opfs-sanity-check');\n          }\n          if (undefined === options.proxyUri) {\n            options.proxyUri = callee.defaultProxyUri;\n          }\n\n          if ('function' === typeof options.proxyUri) {\n            options.proxyUri = options.proxyUri();\n          }\n          const thePromise = new Promise(function (\n            promiseResolve_,\n            promiseReject_,\n          ) {\n            const loggers = [\n              sqlite3.config.error,\n              sqlite3.config.warn,\n              sqlite3.config.log,\n            ];\n            const logImpl = (level, ...args) => {\n              if (options.verbose > level)\n                loggers[level]('OPFS syncer:', ...args);\n            };\n            const log = (...args) => logImpl(2, ...args);\n            const warn = (...args) => logImpl(1, ...args);\n            const error = (...args) => logImpl(0, ...args);\n            const toss = sqlite3.util.toss;\n            const capi = sqlite3.capi;\n            const util = sqlite3.util;\n            const wasm = sqlite3.wasm;\n            const sqlite3_vfs = capi.sqlite3_vfs;\n            const sqlite3_file = capi.sqlite3_file;\n            const sqlite3_io_methods = capi.sqlite3_io_methods;\n\n            const opfsUtil = Object.create(null);\n\n            const thisThreadHasOPFS = () => {\n              return (\n                globalThis.FileSystemHandle &&\n                globalThis.FileSystemDirectoryHandle &&\n                globalThis.FileSystemFileHandle &&\n                globalThis.FileSystemFileHandle.prototype\n                  .createSyncAccessHandle &&\n                navigator?.storage?.getDirectory\n              );\n            };\n\n            opfsUtil.metrics = {\n              dump: function () {\n                let k,\n                  n = 0,\n                  t = 0,\n                  w = 0;\n                for (k in state.opIds) {\n                  const m = metrics[k];\n                  n += m.count;\n                  t += m.time;\n                  w += m.wait;\n                  m.avgTime = m.count && m.time ? m.time / m.count : 0;\n                  m.avgWait = m.count && m.wait ? m.wait / m.count : 0;\n                }\n                sqlite3.config.log(\n                  globalThis.location.href,\n                  'metrics for',\n                  globalThis.location.href,\n                  ':',\n                  metrics,\n                  '\\nTotal of',\n                  n,\n                  'op(s) for',\n                  t,\n                  'ms (incl. ' + w + ' ms of waiting on the async side)',\n                );\n                sqlite3.config.log('Serialization metrics:', metrics.s11n);\n                W.postMessage({ type: 'opfs-async-metrics' });\n              },\n              reset: function () {\n                let k;\n                const r = (m) => (m.count = m.time = m.wait = 0);\n                for (k in state.opIds) {\n                  r((metrics[k] = Object.create(null)));\n                }\n                let s = (metrics.s11n = Object.create(null));\n                s = s.serialize = Object.create(null);\n                s.count = s.time = 0;\n                s = metrics.s11n.deserialize = Object.create(null);\n                s.count = s.time = 0;\n              },\n            };\n            const opfsIoMethods = new sqlite3_io_methods();\n            const opfsVfs = new sqlite3_vfs().addOnDispose(() =>\n              opfsIoMethods.dispose(),\n            );\n            let promiseWasRejected = undefined;\n            const promiseReject = (err) => {\n              promiseWasRejected = true;\n              opfsVfs.dispose();\n              return promiseReject_(err);\n            };\n            const promiseResolve = () => {\n              promiseWasRejected = false;\n              return promiseResolve_(sqlite3);\n            };\n            const W = new Worker(\n              __webpack_require__.tu(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"_app-pages-browser_node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-opfs-async--00ff5e\"), __webpack_require__.b)),\n            );\n            setTimeout(() => {\n              if (undefined === promiseWasRejected) {\n                promiseReject(\n                  new Error(\n                    'Timeout while waiting for OPFS async proxy worker.',\n                  ),\n                );\n              }\n            }, 4000);\n            W._originalOnError = W.onerror;\n            W.onerror = function (err) {\n              error('Error initializing OPFS asyncer:', err);\n              promiseReject(\n                new Error(\n                  'Loading OPFS async Worker failed for unknown reasons.',\n                ),\n              );\n            };\n            const pDVfs = capi.sqlite3_vfs_find(null);\n            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;\n            opfsIoMethods.$iVersion = 1;\n            opfsVfs.$iVersion = 2;\n            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;\n            opfsVfs.$mxPathname = 1024;\n            opfsVfs.$zName = wasm.allocCString('opfs');\n\n            opfsVfs.$xDlOpen =\n              opfsVfs.$xDlError =\n              opfsVfs.$xDlSym =\n              opfsVfs.$xDlClose =\n                null;\n            opfsVfs.addOnDispose(\n              '$zName',\n              opfsVfs.$zName,\n              'cleanup default VFS wrapper',\n              () => (dVfs ? dVfs.dispose() : null),\n            );\n\n            const state = Object.create(null);\n            state.verbose = options.verbose;\n            state.littleEndian = (() => {\n              const buffer = new ArrayBuffer(2);\n              new DataView(buffer).setInt16(0, 256, true);\n\n              return new Int16Array(buffer)[0] === 256;\n            })();\n\n            state.asyncIdleWaitTime = 150;\n\n            state.asyncS11nExceptions = 1;\n\n            state.fileBufferSize = 1024 * 64;\n            state.sabS11nOffset = state.fileBufferSize;\n\n            state.sabS11nSize = opfsVfs.$mxPathname * 2;\n\n            state.sabIO = new SharedArrayBuffer(\n              state.fileBufferSize + state.sabS11nSize,\n            );\n            state.opIds = Object.create(null);\n            const metrics = Object.create(null);\n            {\n              let i = 0;\n\n              state.opIds.whichOp = i++;\n\n              state.opIds.rc = i++;\n\n              state.opIds.xAccess = i++;\n              state.opIds.xClose = i++;\n              state.opIds.xDelete = i++;\n              state.opIds.xDeleteNoWait = i++;\n              state.opIds.xFileSize = i++;\n              state.opIds.xLock = i++;\n              state.opIds.xOpen = i++;\n              state.opIds.xRead = i++;\n              state.opIds.xSleep = i++;\n              state.opIds.xSync = i++;\n              state.opIds.xTruncate = i++;\n              state.opIds.xUnlock = i++;\n              state.opIds.xWrite = i++;\n              state.opIds.mkdir = i++;\n              state.opIds['opfs-async-metrics'] = i++;\n              state.opIds['opfs-async-shutdown'] = i++;\n\n              state.opIds.retry = i++;\n              state.sabOP = new SharedArrayBuffer(i * 4);\n              opfsUtil.metrics.reset();\n            }\n\n            state.sq3Codes = Object.create(null);\n            [\n              'SQLITE_ACCESS_EXISTS',\n              'SQLITE_ACCESS_READWRITE',\n              'SQLITE_BUSY',\n              'SQLITE_CANTOPEN',\n              'SQLITE_ERROR',\n              'SQLITE_IOERR',\n              'SQLITE_IOERR_ACCESS',\n              'SQLITE_IOERR_CLOSE',\n              'SQLITE_IOERR_DELETE',\n              'SQLITE_IOERR_FSYNC',\n              'SQLITE_IOERR_LOCK',\n              'SQLITE_IOERR_READ',\n              'SQLITE_IOERR_SHORT_READ',\n              'SQLITE_IOERR_TRUNCATE',\n              'SQLITE_IOERR_UNLOCK',\n              'SQLITE_IOERR_WRITE',\n              'SQLITE_LOCK_EXCLUSIVE',\n              'SQLITE_LOCK_NONE',\n              'SQLITE_LOCK_PENDING',\n              'SQLITE_LOCK_RESERVED',\n              'SQLITE_LOCK_SHARED',\n              'SQLITE_LOCKED',\n              'SQLITE_MISUSE',\n              'SQLITE_NOTFOUND',\n              'SQLITE_OPEN_CREATE',\n              'SQLITE_OPEN_DELETEONCLOSE',\n              'SQLITE_OPEN_MAIN_DB',\n              'SQLITE_OPEN_READONLY',\n            ].forEach((k) => {\n              if (undefined === (state.sq3Codes[k] = capi[k])) {\n                toss('Maintenance required: not found:', k);\n              }\n            });\n            state.opfsFlags = Object.assign(Object.create(null), {\n              OPFS_UNLOCK_ASAP: 0x01,\n\n              OPFS_UNLINK_BEFORE_OPEN: 0x02,\n\n              defaultUnlockAsap: false,\n            });\n\n            const opRun = (op, ...args) => {\n              const opNdx = state.opIds[op] || toss('Invalid op ID:', op);\n              state.s11n.serialize(...args);\n              Atomics.store(state.sabOPView, state.opIds.rc, -1);\n              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);\n              Atomics.notify(state.sabOPView, state.opIds.whichOp);\n              const t = performance.now();\n              while (\n                'not-equal' !==\n                Atomics.wait(state.sabOPView, state.opIds.rc, -1)\n              ) {}\n\n              const rc = Atomics.load(state.sabOPView, state.opIds.rc);\n              metrics[op].wait += performance.now() - t;\n              if (rc && state.asyncS11nExceptions) {\n                const err = state.s11n.deserialize();\n                if (err) error(op + '() async error:', ...err);\n              }\n              return rc;\n            };\n\n            opfsUtil.debug = {\n              asyncShutdown: () => {\n                warn(\n                  'Shutting down OPFS async listener. The OPFS VFS will no longer work.',\n                );\n                opRun('opfs-async-shutdown');\n              },\n              asyncRestart: () => {\n                warn(\n                  'Attempting to restart OPFS VFS async listener. Might work, might not.',\n                );\n                W.postMessage({ type: 'opfs-async-restart' });\n              },\n            };\n\n            const initS11n = () => {\n              if (state.s11n) return state.s11n;\n              const textDecoder = new TextDecoder(),\n                textEncoder = new TextEncoder('utf-8'),\n                viewU8 = new Uint8Array(\n                  state.sabIO,\n                  state.sabS11nOffset,\n                  state.sabS11nSize,\n                ),\n                viewDV = new DataView(\n                  state.sabIO,\n                  state.sabS11nOffset,\n                  state.sabS11nSize,\n                );\n              state.s11n = Object.create(null);\n\n              const TypeIds = Object.create(null);\n              TypeIds.number = {\n                id: 1,\n                size: 8,\n                getter: 'getFloat64',\n                setter: 'setFloat64',\n              };\n              TypeIds.bigint = {\n                id: 2,\n                size: 8,\n                getter: 'getBigInt64',\n                setter: 'setBigInt64',\n              };\n              TypeIds.boolean = {\n                id: 3,\n                size: 4,\n                getter: 'getInt32',\n                setter: 'setInt32',\n              };\n              TypeIds.string = { id: 4 };\n\n              const getTypeId = (v) =>\n                TypeIds[typeof v] ||\n                toss(\n                  'Maintenance required: this value type cannot be serialized.',\n                  v,\n                );\n              const getTypeIdById = (tid) => {\n                switch (tid) {\n                  case TypeIds.number.id:\n                    return TypeIds.number;\n                  case TypeIds.bigint.id:\n                    return TypeIds.bigint;\n                  case TypeIds.boolean.id:\n                    return TypeIds.boolean;\n                  case TypeIds.string.id:\n                    return TypeIds.string;\n                  default:\n                    toss('Invalid type ID:', tid);\n                }\n              };\n\n              state.s11n.deserialize = function (clear = false) {\n                ++metrics.s11n.deserialize.count;\n                const t = performance.now();\n                const argc = viewU8[0];\n                const rc = argc ? [] : null;\n                if (argc) {\n                  const typeIds = [];\n                  let offset = 1,\n                    i,\n                    n,\n                    v;\n                  for (i = 0; i < argc; ++i, ++offset) {\n                    typeIds.push(getTypeIdById(viewU8[offset]));\n                  }\n                  for (i = 0; i < argc; ++i) {\n                    const t = typeIds[i];\n                    if (t.getter) {\n                      v = viewDV[t.getter](offset, state.littleEndian);\n                      offset += t.size;\n                    } else {\n                      n = viewDV.getInt32(offset, state.littleEndian);\n                      offset += 4;\n                      v = textDecoder.decode(viewU8.slice(offset, offset + n));\n                      offset += n;\n                    }\n                    rc.push(v);\n                  }\n                }\n                if (clear) viewU8[0] = 0;\n\n                metrics.s11n.deserialize.time += performance.now() - t;\n                return rc;\n              };\n\n              state.s11n.serialize = function (...args) {\n                const t = performance.now();\n                ++metrics.s11n.serialize.count;\n                if (args.length) {\n                  const typeIds = [];\n                  let i = 0,\n                    offset = 1;\n                  viewU8[0] = args.length & 0xff;\n                  for (; i < args.length; ++i, ++offset) {\n                    typeIds.push(getTypeId(args[i]));\n                    viewU8[offset] = typeIds[i].id;\n                  }\n                  for (i = 0; i < args.length; ++i) {\n                    const t = typeIds[i];\n                    if (t.setter) {\n                      viewDV[t.setter](offset, args[i], state.littleEndian);\n                      offset += t.size;\n                    } else {\n                      const s = textEncoder.encode(args[i]);\n                      viewDV.setInt32(offset, s.byteLength, state.littleEndian);\n                      offset += 4;\n                      viewU8.set(s, offset);\n                      offset += s.byteLength;\n                    }\n                  }\n                } else {\n                  viewU8[0] = 0;\n                }\n                metrics.s11n.serialize.time += performance.now() - t;\n              };\n              return state.s11n;\n            };\n\n            const randomFilename = function f(len = 16) {\n              if (!f._chars) {\n                f._chars =\n                  'abcdefghijklmnopqrstuvwxyz' +\n                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n                  '012346789';\n                f._n = f._chars.length;\n              }\n              const a = [];\n              let i = 0;\n              for (; i < len; ++i) {\n                const ndx = (Math.random() * (f._n * 64)) % f._n | 0;\n                a[i] = f._chars[ndx];\n              }\n              return a.join('');\n            };\n\n            const __openFiles = Object.create(null);\n\n            const opTimer = Object.create(null);\n            opTimer.op = undefined;\n            opTimer.start = undefined;\n            const mTimeStart = (op) => {\n              opTimer.start = performance.now();\n              opTimer.op = op;\n              ++metrics[op].count;\n            };\n            const mTimeEnd = () =>\n              (metrics[opTimer.op].time += performance.now() - opTimer.start);\n\n            const ioSyncWrappers = {\n              xCheckReservedLock: function (pFile, pOut) {\n                wasm.poke(pOut, 0, 'i32');\n                return 0;\n              },\n              xClose: function (pFile) {\n                mTimeStart('xClose');\n                let rc = 0;\n                const f = __openFiles[pFile];\n                if (f) {\n                  delete __openFiles[pFile];\n                  rc = opRun('xClose', pFile);\n                  if (f.sq3File) f.sq3File.dispose();\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xDeviceCharacteristics: function (pFile) {\n                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n              },\n              xFileControl: function (pFile, opId, pArg) {\n                return capi.SQLITE_NOTFOUND;\n              },\n              xFileSize: function (pFile, pSz64) {\n                mTimeStart('xFileSize');\n                let rc = opRun('xFileSize', pFile);\n                if (0 == rc) {\n                  try {\n                    const sz = state.s11n.deserialize()[0];\n                    wasm.poke(pSz64, sz, 'i64');\n                  } catch (e) {\n                    error('Unexpected error reading xFileSize() result:', e);\n                    rc = state.sq3Codes.SQLITE_IOERR;\n                  }\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xLock: function (pFile, lockType) {\n                mTimeStart('xLock');\n                const f = __openFiles[pFile];\n                let rc = 0;\n\n                if (!f.lockType) {\n                  rc = opRun('xLock', pFile, lockType);\n                  if (0 === rc) f.lockType = lockType;\n                } else {\n                  f.lockType = lockType;\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xRead: function (pFile, pDest, n, offset64) {\n                mTimeStart('xRead');\n                const f = __openFiles[pFile];\n                let rc;\n                try {\n                  rc = opRun('xRead', pFile, n, Number(offset64));\n                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {\n                    wasm.heap8u().set(f.sabView.subarray(0, n), pDest);\n                  }\n                } catch (e) {\n                  error('xRead(', arguments, ') failed:', e, f);\n                  rc = capi.SQLITE_IOERR_READ;\n                }\n                mTimeEnd();\n                return rc;\n              },\n              xSync: function (pFile, flags) {\n                mTimeStart('xSync');\n                ++metrics.xSync.count;\n                const rc = opRun('xSync', pFile, flags);\n                mTimeEnd();\n                return rc;\n              },\n              xTruncate: function (pFile, sz64) {\n                mTimeStart('xTruncate');\n                const rc = opRun('xTruncate', pFile, Number(sz64));\n                mTimeEnd();\n                return rc;\n              },\n              xUnlock: function (pFile, lockType) {\n                mTimeStart('xUnlock');\n                const f = __openFiles[pFile];\n                let rc = 0;\n                if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {\n                  rc = opRun('xUnlock', pFile, lockType);\n                }\n                if (0 === rc) f.lockType = lockType;\n                mTimeEnd();\n                return rc;\n              },\n              xWrite: function (pFile, pSrc, n, offset64) {\n                mTimeStart('xWrite');\n                const f = __openFiles[pFile];\n                let rc;\n                try {\n                  f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n));\n                  rc = opRun('xWrite', pFile, n, Number(offset64));\n                } catch (e) {\n                  error('xWrite(', arguments, ') failed:', e, f);\n                  rc = capi.SQLITE_IOERR_WRITE;\n                }\n                mTimeEnd();\n                return rc;\n              },\n            };\n\n            const vfsSyncWrappers = {\n              xAccess: function (pVfs, zName, flags, pOut) {\n                mTimeStart('xAccess');\n                const rc = opRun('xAccess', wasm.cstrToJs(zName));\n                wasm.poke(pOut, rc ? 0 : 1, 'i32');\n                mTimeEnd();\n                return 0;\n              },\n              xCurrentTime: function (pVfs, pOut) {\n                wasm.poke(\n                  pOut,\n                  2440587.5 + new Date().getTime() / 86400000,\n                  'double',\n                );\n                return 0;\n              },\n              xCurrentTimeInt64: function (pVfs, pOut) {\n                wasm.poke(\n                  pOut,\n                  2440587.5 * 86400000 + new Date().getTime(),\n                  'i64',\n                );\n                return 0;\n              },\n              xDelete: function (pVfs, zName, doSyncDir) {\n                mTimeStart('xDelete');\n                const rc = opRun(\n                  'xDelete',\n                  wasm.cstrToJs(zName),\n                  doSyncDir,\n                  false,\n                );\n                mTimeEnd();\n                return rc;\n              },\n              xFullPathname: function (pVfs, zName, nOut, pOut) {\n                const i = wasm.cstrncpy(pOut, zName, nOut);\n                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;\n              },\n              xGetLastError: function (pVfs, nOut, pOut) {\n                warn('OPFS xGetLastError() has nothing sensible to return.');\n                return 0;\n              },\n\n              xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {\n                mTimeStart('xOpen');\n                let opfsFlags = 0;\n                if (0 === zName) {\n                  zName = randomFilename();\n                } else if (wasm.isPtr(zName)) {\n                  if (capi.sqlite3_uri_boolean(zName, 'opfs-unlock-asap', 0)) {\n                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;\n                  }\n                  if (\n                    capi.sqlite3_uri_boolean(zName, 'delete-before-open', 0)\n                  ) {\n                    opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;\n                  }\n                  zName = wasm.cstrToJs(zName);\n                }\n                const fh = Object.create(null);\n                fh.fid = pFile;\n                fh.filename = zName;\n                fh.sab = new SharedArrayBuffer(state.fileBufferSize);\n                fh.flags = flags;\n                fh.readOnly =\n                  !(sqlite3.SQLITE_OPEN_CREATE & flags) &&\n                  !!(flags & capi.SQLITE_OPEN_READONLY);\n                const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);\n                if (!rc) {\n                  if (fh.readOnly) {\n                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');\n                  }\n                  __openFiles[pFile] = fh;\n                  fh.sabView = state.sabFileBufView;\n                  fh.sq3File = new sqlite3_file(pFile);\n                  fh.sq3File.$pMethods = opfsIoMethods.pointer;\n                  fh.lockType = capi.SQLITE_LOCK_NONE;\n                }\n                mTimeEnd();\n                return rc;\n              },\n            };\n\n            if (dVfs) {\n              opfsVfs.$xRandomness = dVfs.$xRandomness;\n              opfsVfs.$xSleep = dVfs.$xSleep;\n            }\n            if (!opfsVfs.$xRandomness) {\n              vfsSyncWrappers.xRandomness = function (pVfs, nOut, pOut) {\n                const heap = wasm.heap8u();\n                let i = 0;\n                for (; i < nOut; ++i)\n                  heap[pOut + i] = (Math.random() * 255000) & 0xff;\n                return i;\n              };\n            }\n            if (!opfsVfs.$xSleep) {\n              vfsSyncWrappers.xSleep = function (pVfs, ms) {\n                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);\n                return 0;\n              };\n            }\n\n            opfsUtil.getResolvedPath = function (filename, splitIt) {\n              const p = new URL(filename, 'file://irrelevant').pathname;\n              return splitIt ? p.split('/').filter((v) => !!v) : p;\n            };\n\n            opfsUtil.getDirForFilename = async function f(\n              absFilename,\n              createDirs = false,\n            ) {\n              const path = opfsUtil.getResolvedPath(absFilename, true);\n              const filename = path.pop();\n              let dh = opfsUtil.rootDirectory;\n              for (const dirName of path) {\n                if (dirName) {\n                  dh = await dh.getDirectoryHandle(dirName, {\n                    create: !!createDirs,\n                  });\n                }\n              }\n              return [dh, filename];\n            };\n\n            opfsUtil.mkdir = async function (absDirName) {\n              try {\n                await opfsUtil.getDirForFilename(\n                  absDirName + '/filepart',\n                  true,\n                );\n                return true;\n              } catch (e) {\n                return false;\n              }\n            };\n\n            opfsUtil.entryExists = async function (fsEntryName) {\n              try {\n                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);\n                await dh.getFileHandle(fn);\n                return true;\n              } catch (e) {\n                return false;\n              }\n            };\n\n            opfsUtil.randomFilename = randomFilename;\n\n            opfsUtil.treeList = async function () {\n              const doDir = async function callee(dirHandle, tgt) {\n                tgt.name = dirHandle.name;\n                tgt.dirs = [];\n                tgt.files = [];\n                for await (const handle of dirHandle.values()) {\n                  if ('directory' === handle.kind) {\n                    const subDir = Object.create(null);\n                    tgt.dirs.push(subDir);\n                    await callee(handle, subDir);\n                  } else {\n                    tgt.files.push(handle.name);\n                  }\n                }\n              };\n              const root = Object.create(null);\n              await doDir(opfsUtil.rootDirectory, root);\n              return root;\n            };\n\n            opfsUtil.rmfr = async function () {\n              const dir = opfsUtil.rootDirectory,\n                opt = { recurse: true };\n              for await (const handle of dir.values()) {\n                dir.removeEntry(handle.name, opt);\n              }\n            };\n\n            opfsUtil.unlink = async function (\n              fsEntryName,\n              recursive = false,\n              throwOnError = false,\n            ) {\n              try {\n                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(\n                  fsEntryName,\n                  false,\n                );\n                await hDir.removeEntry(filenamePart, { recursive });\n                return true;\n              } catch (e) {\n                if (throwOnError) {\n                  throw new Error(\n                    'unlink(',\n                    arguments[0],\n                    ') failed: ' + e.message,\n                    {\n                      cause: e,\n                    },\n                  );\n                }\n                return false;\n              }\n            };\n\n            opfsUtil.traverse = async function (opt) {\n              const defaultOpt = {\n                recursive: true,\n                directory: opfsUtil.rootDirectory,\n              };\n              if ('function' === typeof opt) {\n                opt = { callback: opt };\n              }\n              opt = Object.assign(defaultOpt, opt || {});\n              const doDir = async function callee(dirHandle, depth) {\n                for await (const handle of dirHandle.values()) {\n                  if (false === opt.callback(handle, dirHandle, depth))\n                    return false;\n                  else if (opt.recursive && 'directory' === handle.kind) {\n                    if (false === (await callee(handle, depth + 1))) break;\n                  }\n                }\n              };\n              doDir(opt.directory, 0);\n            };\n\n            const importDbChunked = async function (filename, callback) {\n              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(\n                filename,\n                true,\n              );\n              const hFile = await hDir.getFileHandle(fnamePart, {\n                create: true,\n              });\n              let sah = await hFile.createSyncAccessHandle();\n              let nWrote = 0,\n                chunk,\n                checkedHeader = false,\n                err = false;\n              try {\n                sah.truncate(0);\n                while (undefined !== (chunk = await callback())) {\n                  if (chunk instanceof ArrayBuffer)\n                    chunk = new Uint8Array(chunk);\n                  if (0 === nWrote && chunk.byteLength >= 15) {\n                    util.affirmDbHeader(chunk);\n                    checkedHeader = true;\n                  }\n                  sah.write(chunk, { at: nWrote });\n                  nWrote += chunk.byteLength;\n                }\n                if (nWrote < 512 || 0 !== nWrote % 512) {\n                  toss(\n                    'Input size',\n                    nWrote,\n                    'is not correct for an SQLite database.',\n                  );\n                }\n                if (!checkedHeader) {\n                  const header = new Uint8Array(20);\n                  sah.read(header, { at: 0 });\n                  util.affirmDbHeader(header);\n                }\n                sah.write(new Uint8Array([1, 1]), { at: 18 });\n                return nWrote;\n              } catch (e) {\n                await sah.close();\n                sah = undefined;\n                await hDir.removeEntry(fnamePart).catch(() => {});\n                throw e;\n              } finally {\n                if (sah) await sah.close();\n              }\n            };\n\n            opfsUtil.importDb = async function (filename, bytes) {\n              if (bytes instanceof Function) {\n                return importDbChunked(filename, bytes);\n              }\n              if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n              util.affirmIsDb(bytes);\n              const n = bytes.byteLength;\n              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(\n                filename,\n                true,\n              );\n              let sah,\n                err,\n                nWrote = 0;\n              try {\n                const hFile = await hDir.getFileHandle(fnamePart, {\n                  create: true,\n                });\n                sah = await hFile.createSyncAccessHandle();\n                sah.truncate(0);\n                nWrote = sah.write(bytes, { at: 0 });\n                if (nWrote != n) {\n                  toss(\n                    'Expected to write ' +\n                      n +\n                      ' bytes but wrote ' +\n                      nWrote +\n                      '.',\n                  );\n                }\n                sah.write(new Uint8Array([1, 1]), { at: 18 });\n                return nWrote;\n              } catch (e) {\n                if (sah) {\n                  await sah.close();\n                  sah = undefined;\n                }\n                await hDir.removeEntry(fnamePart).catch(() => {});\n                throw e;\n              } finally {\n                if (sah) await sah.close();\n              }\n            };\n\n            if (sqlite3.oo1) {\n              const OpfsDb = function (...args) {\n                const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);\n                opt.vfs = opfsVfs.$zName;\n                sqlite3.oo1.DB.dbCtorHelper.call(this, opt);\n              };\n              OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);\n              sqlite3.oo1.OpfsDb = OpfsDb;\n              OpfsDb.importDb = opfsUtil.importDb;\n              sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenCallback(\n                opfsVfs.pointer,\n                function (oo1Db, sqlite3) {\n                  sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);\n                },\n              );\n            }\n\n            const sanityCheck = function () {\n              const scope = wasm.scopedAllocPush();\n              const sq3File = new sqlite3_file();\n              try {\n                const fid = sq3File.pointer;\n                const openFlags =\n                  capi.SQLITE_OPEN_CREATE |\n                  capi.SQLITE_OPEN_READWRITE |\n                  capi.SQLITE_OPEN_MAIN_DB;\n                const pOut = wasm.scopedAlloc(8);\n                const dbFile = '/sanity/check/file' + randomFilename(8);\n                const zDbFile = wasm.scopedAllocCString(dbFile);\n                let rc;\n                state.s11n.serialize('This is ä string.');\n                rc = state.s11n.deserialize();\n                log('deserialize() says:', rc);\n                if ('This is ä string.' !== rc[0]) toss('String d13n error.');\n                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n                rc = wasm.peek(pOut, 'i32');\n                log('xAccess(', dbFile, ') exists ?=', rc);\n                rc = vfsSyncWrappers.xOpen(\n                  opfsVfs.pointer,\n                  zDbFile,\n                  fid,\n                  openFlags,\n                  pOut,\n                );\n                log(\n                  'open rc =',\n                  rc,\n                  'state.sabOPView[xOpen] =',\n                  state.sabOPView[state.opIds.xOpen],\n                );\n                if (0 !== rc) {\n                  error('open failed with code', rc);\n                  return;\n                }\n                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n                rc = wasm.peek(pOut, 'i32');\n                if (!rc) toss('xAccess() failed to detect file.');\n                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);\n                if (rc) toss('sync failed w/ rc', rc);\n                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);\n                if (rc) toss('truncate failed w/ rc', rc);\n                wasm.poke(pOut, 0, 'i64');\n                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);\n                if (rc) toss('xFileSize failed w/ rc', rc);\n                log('xFileSize says:', wasm.peek(pOut, 'i64'));\n                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);\n                if (rc) toss('xWrite() failed!');\n                const readBuf = wasm.scopedAlloc(16);\n                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);\n                wasm.poke(readBuf + 6, 0);\n                let jRead = wasm.cstrToJs(readBuf);\n                log('xRead() got:', jRead);\n                if ('sanity' !== jRead) toss('Unexpected xRead() value.');\n                if (vfsSyncWrappers.xSleep) {\n                  log('xSleep()ing before close()ing...');\n                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2000);\n                  log('waking up from xSleep()');\n                }\n                rc = ioSyncWrappers.xClose(fid);\n                log('xClose rc =', rc, 'sabOPView =', state.sabOPView);\n                log('Deleting file:', dbFile);\n                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);\n                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);\n                rc = wasm.peek(pOut, 'i32');\n                if (rc)\n                  toss(\n                    'Expecting 0 from xAccess(',\n                    dbFile,\n                    ') after xDelete().',\n                  );\n                warn('End of OPFS sanity checks.');\n              } finally {\n                sq3File.dispose();\n                wasm.scopedAllocPop(scope);\n              }\n            };\n\n            W.onmessage = function ({ data }) {\n              switch (data.type) {\n                case 'opfs-unavailable':\n                  promiseReject(new Error(data.payload.join(' ')));\n                  break;\n                case 'opfs-async-loaded':\n                  W.postMessage({ type: 'opfs-async-init', args: state });\n                  break;\n                case 'opfs-async-inited': {\n                  if (true === promiseWasRejected) {\n                    break;\n                  }\n                  try {\n                    sqlite3.vfs.installVfs({\n                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },\n                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers },\n                    });\n                    state.sabOPView = new Int32Array(state.sabOP);\n                    state.sabFileBufView = new Uint8Array(\n                      state.sabIO,\n                      0,\n                      state.fileBufferSize,\n                    );\n                    state.sabS11nView = new Uint8Array(\n                      state.sabIO,\n                      state.sabS11nOffset,\n                      state.sabS11nSize,\n                    );\n                    initS11n();\n                    if (options.sanityChecks) {\n                      warn(\n                        'Running sanity checks because of opfs-sanity-check URL arg...',\n                      );\n                      sanityCheck();\n                    }\n                    if (thisThreadHasOPFS()) {\n                      navigator.storage\n                        .getDirectory()\n                        .then((d) => {\n                          W.onerror = W._originalOnError;\n                          delete W._originalOnError;\n                          sqlite3.opfs = opfsUtil;\n                          opfsUtil.rootDirectory = d;\n                          log('End of OPFS sqlite3_vfs setup.', opfsVfs);\n                          promiseResolve();\n                        })\n                        .catch(promiseReject);\n                    } else {\n                      promiseResolve();\n                    }\n                  } catch (e) {\n                    error(e);\n                    promiseReject(e);\n                  }\n                  break;\n                }\n                default: {\n                  const errMsg =\n                    'Unexpected message from the OPFS async worker: ' +\n                    JSON.stringify(data);\n                  error(errMsg);\n                  promiseReject(new Error(errMsg));\n                  break;\n                }\n              }\n            };\n          });\n          return thePromise;\n        };\n        installOpfsVfs.defaultProxyUri = 'sqlite3-opfs-async-proxy.js';\n        globalThis.sqlite3ApiBootstrap.initializersAsync.push(\n          async (sqlite3) => {\n            try {\n              let proxyJs = installOpfsVfs.defaultProxyUri;\n              if (sqlite3.scriptInfo.sqlite3Dir) {\n                installOpfsVfs.defaultProxyUri =\n                  sqlite3.scriptInfo.sqlite3Dir + proxyJs;\n              }\n              return installOpfsVfs().catch((e) => {\n                sqlite3.config.warn(\n                  'Ignoring inability to install OPFS sqlite3_vfs:',\n                  e.message,\n                );\n              });\n            } catch (e) {\n              sqlite3.config.error('installOpfsVfs() exception:', e);\n              return Promise.reject(e);\n            }\n          },\n        );\n      });\n\n      globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {\n        'use strict';\n        const toss = sqlite3.util.toss;\n        const toss3 = sqlite3.util.toss3;\n        const initPromises = Object.create(null);\n        const capi = sqlite3.capi;\n        const util = sqlite3.util;\n        const wasm = sqlite3.wasm;\n\n        const SECTOR_SIZE = 4096;\n        const HEADER_MAX_PATH_SIZE = 512;\n        const HEADER_FLAGS_SIZE = 4;\n        const HEADER_DIGEST_SIZE = 8;\n        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;\n        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;\n        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;\n        const HEADER_OFFSET_DATA = SECTOR_SIZE;\n\n        const PERSISTENT_FILE_TYPES =\n          capi.SQLITE_OPEN_MAIN_DB |\n          capi.SQLITE_OPEN_MAIN_JOURNAL |\n          capi.SQLITE_OPEN_SUPER_JOURNAL |\n          capi.SQLITE_OPEN_WAL;\n        const FLAG_COMPUTE_DIGEST_V2 = capi.SQLITE_OPEN_MEMORY;\n        const OPAQUE_DIR_NAME = '.opaque';\n\n        const getRandomName = () => Math.random().toString(36).slice(2);\n\n        const textDecoder = new TextDecoder();\n        const textEncoder = new TextEncoder();\n\n        const optionDefaults = Object.assign(Object.create(null), {\n          name: 'opfs-sahpool',\n          directory: undefined,\n          initialCapacity: 6,\n          clearOnInit: false,\n\n          verbosity: 2,\n          forceReinitIfPreviouslyFailed: false,\n        });\n\n        const loggers = [\n          sqlite3.config.error,\n          sqlite3.config.warn,\n          sqlite3.config.log,\n        ];\n        const log = sqlite3.config.log;\n        const warn = sqlite3.config.warn;\n        const error = sqlite3.config.error;\n\n        const __mapVfsToPool = new Map();\n        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);\n        const setPoolForVfs = (pVfs, pool) => {\n          if (pool) __mapVfsToPool.set(pVfs, pool);\n          else __mapVfsToPool.delete(pVfs);\n        };\n\n        const __mapSqlite3File = new Map();\n        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);\n        const setPoolForPFile = (pFile, pool) => {\n          if (pool) __mapSqlite3File.set(pFile, pool);\n          else __mapSqlite3File.delete(pFile);\n        };\n\n        const ioMethods = {\n          xCheckReservedLock: function (pFile, pOut) {\n            const pool = getPoolForPFile(pFile);\n            pool.log('xCheckReservedLock');\n            pool.storeErr();\n            wasm.poke32(pOut, 1);\n            return 0;\n          },\n          xClose: function (pFile) {\n            const pool = getPoolForPFile(pFile);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            if (file) {\n              try {\n                pool.log(`xClose ${file.path}`);\n                pool.mapS3FileToOFile(pFile, false);\n                file.sah.flush();\n                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {\n                  pool.deletePath(file.path);\n                }\n              } catch (e) {\n                return pool.storeErr(e, capi.SQLITE_IOERR);\n              }\n            }\n            return 0;\n          },\n          xDeviceCharacteristics: function (pFile) {\n            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n          },\n          xFileControl: function (pFile, opId, pArg) {\n            return capi.SQLITE_NOTFOUND;\n          },\n          xFileSize: function (pFile, pSz64) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xFileSize`);\n            const file = pool.getOFileForS3File(pFile);\n            const size = file.sah.getSize() - HEADER_OFFSET_DATA;\n\n            wasm.poke64(pSz64, BigInt(size));\n            return 0;\n          },\n          xLock: function (pFile, lockType) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xLock ${lockType}`);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            file.lockType = lockType;\n            return 0;\n          },\n          xRead: function (pFile, pDest, n, offset64) {\n            const pool = getPoolForPFile(pFile);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            pool.log(`xRead ${file.path} ${n} @ ${offset64}`);\n            try {\n              const nRead = file.sah.read(\n                wasm.heap8u().subarray(pDest, pDest + n),\n                { at: HEADER_OFFSET_DATA + Number(offset64) },\n              );\n              if (nRead < n) {\n                wasm.heap8u().fill(0, pDest + nRead, pDest + n);\n                return capi.SQLITE_IOERR_SHORT_READ;\n              }\n              return 0;\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n          xSectorSize: function (pFile) {\n            return SECTOR_SIZE;\n          },\n          xSync: function (pFile, flags) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xSync ${flags}`);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n\n            try {\n              file.sah.flush();\n              return 0;\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n          xTruncate: function (pFile, sz64) {\n            const pool = getPoolForPFile(pFile);\n            pool.log(`xTruncate ${sz64}`);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n\n            try {\n              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));\n              return 0;\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n          xUnlock: function (pFile, lockType) {\n            const pool = getPoolForPFile(pFile);\n            pool.log('xUnlock');\n            const file = pool.getOFileForS3File(pFile);\n            file.lockType = lockType;\n            return 0;\n          },\n          xWrite: function (pFile, pSrc, n, offset64) {\n            const pool = getPoolForPFile(pFile);\n            pool.storeErr();\n            const file = pool.getOFileForS3File(pFile);\n            pool.log(`xWrite ${file.path} ${n} ${offset64}`);\n            try {\n              const nBytes = file.sah.write(\n                wasm.heap8u().subarray(pSrc, pSrc + n),\n                { at: HEADER_OFFSET_DATA + Number(offset64) },\n              );\n              return n === nBytes ? 0 : toss('Unknown write() failure.');\n            } catch (e) {\n              return pool.storeErr(e, capi.SQLITE_IOERR);\n            }\n          },\n        };\n\n        const opfsIoMethods = new capi.sqlite3_io_methods();\n        opfsIoMethods.$iVersion = 1;\n        sqlite3.vfs.installVfs({\n          io: { struct: opfsIoMethods, methods: ioMethods },\n        });\n\n        const vfsMethods = {\n          xAccess: function (pVfs, zName, flags, pOut) {\n            const pool = getPoolForVfs(pVfs);\n            pool.storeErr();\n            try {\n              const name = pool.getPath(zName);\n              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);\n            } catch (e) {\n              wasm.poke32(pOut, 0);\n            }\n            return 0;\n          },\n          xCurrentTime: function (pVfs, pOut) {\n            wasm.poke(\n              pOut,\n              2440587.5 + new Date().getTime() / 86400000,\n              'double',\n            );\n            return 0;\n          },\n          xCurrentTimeInt64: function (pVfs, pOut) {\n            wasm.poke(pOut, 2440587.5 * 86400000 + new Date().getTime(), 'i64');\n            return 0;\n          },\n          xDelete: function (pVfs, zName, doSyncDir) {\n            const pool = getPoolForVfs(pVfs);\n            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);\n            pool.storeErr();\n            try {\n              pool.deletePath(pool.getPath(zName));\n              return 0;\n            } catch (e) {\n              pool.storeErr(e);\n              return capi.SQLITE_IOERR_DELETE;\n            }\n          },\n          xFullPathname: function (pVfs, zName, nOut, pOut) {\n            const i = wasm.cstrncpy(pOut, zName, nOut);\n            return i < nOut ? 0 : capi.SQLITE_CANTOPEN;\n          },\n          xGetLastError: function (pVfs, nOut, pOut) {\n            const pool = getPoolForVfs(pVfs);\n            const e = pool.popErr();\n            pool.log(`xGetLastError ${nOut} e =`, e);\n            if (e) {\n              const scope = wasm.scopedAllocPush();\n              try {\n                const [cMsg, n] = wasm.scopedAllocCString(e.message, true);\n                wasm.cstrncpy(pOut, cMsg, nOut);\n                if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);\n              } catch (e) {\n                return capi.SQLITE_NOMEM;\n              } finally {\n                wasm.scopedAllocPop(scope);\n              }\n            }\n            return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;\n          },\n\n          xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {\n            const pool = getPoolForVfs(pVfs);\n            try {\n              flags &= ~FLAG_COMPUTE_DIGEST_V2;\n              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);\n\n              const path =\n                zName && wasm.peek8(zName)\n                  ? pool.getPath(zName)\n                  : getRandomName();\n              let sah = pool.getSAHForPath(path);\n              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {\n                if (pool.getFileCount() < pool.getCapacity()) {\n                  sah = pool.nextAvailableSAH();\n                  pool.setAssociatedPath(sah, path, flags);\n                } else {\n                  toss('SAH pool is full. Cannot create file', path);\n                }\n              }\n              if (!sah) {\n                toss('file not found:', path);\n              }\n\n              const file = { path, flags, sah };\n              pool.mapS3FileToOFile(pFile, file);\n              file.lockType = capi.SQLITE_LOCK_NONE;\n              const sq3File = new capi.sqlite3_file(pFile);\n              sq3File.$pMethods = opfsIoMethods.pointer;\n              sq3File.dispose();\n              wasm.poke32(pOutFlags, flags);\n              return 0;\n            } catch (e) {\n              pool.storeErr(e);\n              return capi.SQLITE_CANTOPEN;\n            }\n          },\n        };\n\n        const createOpfsVfs = function (vfsName) {\n          if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {\n            toss3('VFS name is already registered:', vfsName);\n          }\n          const opfsVfs = new capi.sqlite3_vfs();\n\n          const pDVfs = capi.sqlite3_vfs_find(null);\n          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;\n          opfsVfs.$iVersion = 2;\n          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;\n          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;\n          opfsVfs.addOnDispose(\n            (opfsVfs.$zName = wasm.allocCString(vfsName)),\n            () => setPoolForVfs(opfsVfs.pointer, 0),\n          );\n\n          if (dVfs) {\n            opfsVfs.$xRandomness = dVfs.$xRandomness;\n            opfsVfs.$xSleep = dVfs.$xSleep;\n            dVfs.dispose();\n          }\n          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {\n            vfsMethods.xRandomness = function (pVfs, nOut, pOut) {\n              const heap = wasm.heap8u();\n              let i = 0;\n              for (; i < nOut; ++i)\n                heap[pOut + i] = (Math.random() * 255000) & 0xff;\n              return i;\n            };\n          }\n          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {\n            vfsMethods.xSleep = (pVfs, ms) => 0;\n          }\n          sqlite3.vfs.installVfs({\n            vfs: { struct: opfsVfs, methods: vfsMethods },\n          });\n          return opfsVfs;\n        };\n\n        class OpfsSAHPool {\n          vfsDir;\n\n          #dhVfsRoot;\n\n          #dhOpaque;\n\n          #dhVfsParent;\n\n          #mapSAHToName = new Map();\n\n          #mapFilenameToSAH = new Map();\n\n          #availableSAH = new Set();\n\n          #mapS3FileToOFile_ = new Map();\n\n          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);\n\n          #dvBody;\n\n          #cVfs;\n\n          #verbosity;\n\n          constructor(options = Object.create(null)) {\n            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;\n            this.vfsName = options.name || optionDefaults.name;\n            this.#cVfs = createOpfsVfs(this.vfsName);\n            setPoolForVfs(this.#cVfs.pointer, this);\n            this.vfsDir = options.directory || '.' + this.vfsName;\n            this.#dvBody = new DataView(\n              this.#apBody.buffer,\n              this.#apBody.byteOffset,\n            );\n            this.isReady = this.reset(\n              !!(options.clearOnInit ?? optionDefaults.clearOnInit),\n            ).then(() => {\n              if (this.$error) throw this.$error;\n              return this.getCapacity()\n                ? Promise.resolve(undefined)\n                : this.addCapacity(\n                    options.initialCapacity || optionDefaults.initialCapacity,\n                  );\n            });\n          }\n\n          #logImpl(level, ...args) {\n            if (this.#verbosity > level)\n              loggers[level](this.vfsName + ':', ...args);\n          }\n          log(...args) {\n            this.#logImpl(2, ...args);\n          }\n          warn(...args) {\n            this.#logImpl(1, ...args);\n          }\n          error(...args) {\n            this.#logImpl(0, ...args);\n          }\n\n          getVfs() {\n            return this.#cVfs;\n          }\n\n          getCapacity() {\n            return this.#mapSAHToName.size;\n          }\n\n          getFileCount() {\n            return this.#mapFilenameToSAH.size;\n          }\n\n          getFileNames() {\n            const rc = [];\n            for (const n of this.#mapFilenameToSAH.keys()) rc.push(n);\n            return rc;\n          }\n\n          async addCapacity(n) {\n            for (let i = 0; i < n; ++i) {\n              const name = getRandomName();\n              const h = await this.#dhOpaque.getFileHandle(name, {\n                create: true,\n              });\n              const ah = await h.createSyncAccessHandle();\n              this.#mapSAHToName.set(ah, name);\n              this.setAssociatedPath(ah, '', 0);\n            }\n            return this.getCapacity();\n          }\n\n          async reduceCapacity(n) {\n            let nRm = 0;\n            for (const ah of Array.from(this.#availableSAH)) {\n              if (nRm === n || this.getFileCount() === this.getCapacity()) {\n                break;\n              }\n              const name = this.#mapSAHToName.get(ah);\n\n              ah.close();\n              await this.#dhOpaque.removeEntry(name);\n              this.#mapSAHToName.delete(ah);\n              this.#availableSAH.delete(ah);\n              ++nRm;\n            }\n            return nRm;\n          }\n\n          releaseAccessHandles() {\n            for (const ah of this.#mapSAHToName.keys()) ah.close();\n            this.#mapSAHToName.clear();\n            this.#mapFilenameToSAH.clear();\n            this.#availableSAH.clear();\n          }\n\n          async acquireAccessHandles(clearFiles = false) {\n            const files = [];\n            for await (const [name, h] of this.#dhOpaque) {\n              if ('file' === h.kind) {\n                files.push([name, h]);\n              }\n            }\n            return Promise.all(\n              files.map(async ([name, h]) => {\n                try {\n                  const ah = await h.createSyncAccessHandle();\n                  this.#mapSAHToName.set(ah, name);\n                  if (clearFiles) {\n                    ah.truncate(HEADER_OFFSET_DATA);\n                    this.setAssociatedPath(ah, '', 0);\n                  } else {\n                    const path = this.getAssociatedPath(ah);\n                    if (path) {\n                      this.#mapFilenameToSAH.set(path, ah);\n                    } else {\n                      this.#availableSAH.add(ah);\n                    }\n                  }\n                } catch (e) {\n                  this.storeErr(e);\n                  this.releaseAccessHandles();\n                  throw e;\n                }\n              }),\n            );\n          }\n\n          getAssociatedPath(sah) {\n            sah.read(this.#apBody, { at: 0 });\n\n            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);\n            if (\n              this.#apBody[0] &&\n              (flags & capi.SQLITE_OPEN_DELETEONCLOSE ||\n                (flags & PERSISTENT_FILE_TYPES) === 0)\n            ) {\n              warn(\n                `Removing file with unexpected flags ${flags.toString(16)}`,\n                this.#apBody,\n              );\n              this.setAssociatedPath(sah, '', 0);\n              return '';\n            }\n\n            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);\n            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });\n            const compDigest = this.computeDigest(this.#apBody, flags);\n\n            if (fileDigest.every((v, i) => v === compDigest[i])) {\n              const pathBytes = this.#apBody.findIndex((v) => 0 === v);\n              if (0 === pathBytes) {\n                sah.truncate(HEADER_OFFSET_DATA);\n              }\n\n              return pathBytes\n                ? textDecoder.decode(this.#apBody.subarray(0, pathBytes))\n                : '';\n            } else {\n              warn('Disassociating file with bad digest.');\n              this.setAssociatedPath(sah, '', 0);\n              return '';\n            }\n          }\n\n          setAssociatedPath(sah, path, flags) {\n            const enc = textEncoder.encodeInto(path, this.#apBody);\n            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {\n              toss('Path too long:', path);\n            }\n            if (path && flags) {\n              flags |= FLAG_COMPUTE_DIGEST_V2;\n            }\n            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);\n            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);\n            const digest = this.computeDigest(this.#apBody, flags);\n\n            sah.write(this.#apBody, { at: 0 });\n            sah.write(digest, { at: HEADER_OFFSET_DIGEST });\n            sah.flush();\n\n            if (path) {\n              this.#mapFilenameToSAH.set(path, sah);\n              this.#availableSAH.delete(sah);\n            } else {\n              sah.truncate(HEADER_OFFSET_DATA);\n              this.#availableSAH.add(sah);\n            }\n          }\n\n          computeDigest(byteArray, fileFlags) {\n            if (fileFlags & FLAG_COMPUTE_DIGEST_V2) {\n              let h1 = 0xdeadbeef;\n              let h2 = 0x41c6ce57;\n              for (const v of byteArray) {\n                h1 = Math.imul(h1 ^ v, 2654435761);\n                h2 = Math.imul(h2 ^ v, 104729);\n              }\n              return new Uint32Array([h1 >>> 0, h2 >>> 0]);\n            } else {\n              return new Uint32Array([0, 0]);\n            }\n          }\n\n          async reset(clearFiles) {\n            await this.isReady;\n            let h = await navigator.storage.getDirectory();\n            let prev, prevName;\n            for (const d of this.vfsDir.split('/')) {\n              if (d) {\n                prev = h;\n                h = await h.getDirectoryHandle(d, { create: true });\n              }\n            }\n            this.#dhVfsRoot = h;\n            this.#dhVfsParent = prev;\n            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(\n              OPAQUE_DIR_NAME,\n              { create: true },\n            );\n            this.releaseAccessHandles();\n            return this.acquireAccessHandles(clearFiles);\n          }\n\n          getPath(arg) {\n            if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);\n            return (\n              arg instanceof URL ? arg : new URL(arg, 'file://localhost/')\n            ).pathname;\n          }\n\n          deletePath(path) {\n            const sah = this.#mapFilenameToSAH.get(path);\n            if (sah) {\n              this.#mapFilenameToSAH.delete(path);\n              this.setAssociatedPath(sah, '', 0);\n            }\n            return !!sah;\n          }\n\n          storeErr(e, code) {\n            if (e) {\n              e.sqlite3Rc = code || capi.SQLITE_IOERR;\n              this.error(e);\n            }\n            this.$error = e;\n            return code;\n          }\n\n          popErr() {\n            const rc = this.$error;\n            this.$error = undefined;\n            return rc;\n          }\n\n          nextAvailableSAH() {\n            const [rc] = this.#availableSAH.keys();\n            return rc;\n          }\n\n          getOFileForS3File(pFile) {\n            return this.#mapS3FileToOFile_.get(pFile);\n          }\n\n          mapS3FileToOFile(pFile, file) {\n            if (file) {\n              this.#mapS3FileToOFile_.set(pFile, file);\n              setPoolForPFile(pFile, this);\n            } else {\n              this.#mapS3FileToOFile_.delete(pFile);\n              setPoolForPFile(pFile, false);\n            }\n          }\n\n          hasFilename(name) {\n            return this.#mapFilenameToSAH.has(name);\n          }\n\n          getSAHForPath(path) {\n            return this.#mapFilenameToSAH.get(path);\n          }\n\n          async removeVfs() {\n            if (!this.#cVfs.pointer || !this.#dhOpaque) return false;\n            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);\n            this.#cVfs.dispose();\n            delete initPromises[this.vfsName];\n            try {\n              this.releaseAccessHandles();\n              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {\n                recursive: true,\n              });\n              this.#dhOpaque = undefined;\n              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {\n                recursive: true,\n              });\n              this.#dhVfsRoot = this.#dhVfsParent = undefined;\n            } catch (e) {\n              sqlite3.config.error(\n                this.vfsName,\n                'removeVfs() failed with no recovery strategy:',\n                e,\n              );\n            }\n            return true;\n          }\n\n          pauseVfs() {\n            if (this.#mapS3FileToOFile_.size > 0) {\n              sqlite3.SQLite3Error.toss(\n                capi.SQLITE_MISUSE,\n                'Cannot pause VFS',\n                this.vfsName,\n                'because it has opened files.',\n              );\n            }\n            if (this.#mapSAHToName.size > 0) {\n              capi.sqlite3_vfs_unregister(this.vfsName);\n              this.releaseAccessHandles();\n            }\n            return this;\n          }\n\n          isPaused() {\n            return 0 === this.#mapSAHToName.size;\n          }\n\n          async unpauseVfs() {\n            if (0 === this.#mapSAHToName.size) {\n              return this.acquireAccessHandles(false).then(\n                () => capi.sqlite3_vfs_register(this.#cVfs, 0),\n                this,\n              );\n            }\n            return this;\n          }\n\n          exportFile(name) {\n            const sah =\n              this.#mapFilenameToSAH.get(name) || toss('File not found:', name);\n            const n = sah.getSize() - HEADER_OFFSET_DATA;\n            const b = new Uint8Array(n > 0 ? n : 0);\n            if (n > 0) {\n              const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });\n              if (nRead != n) {\n                toss(\n                  'Expected to read ' + n + ' bytes but read ' + nRead + '.',\n                );\n              }\n            }\n            return b;\n          }\n\n          async importDbChunked(name, callback) {\n            const sah =\n              this.#mapFilenameToSAH.get(name) ||\n              this.nextAvailableSAH() ||\n              toss('No available handles to import to.');\n            sah.truncate(0);\n            let nWrote = 0,\n              chunk,\n              checkedHeader = false,\n              err = false;\n            try {\n              while (undefined !== (chunk = await callback())) {\n                if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);\n                if (0 === nWrote && chunk.byteLength >= 15) {\n                  util.affirmDbHeader(chunk);\n                  checkedHeader = true;\n                }\n                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });\n                nWrote += chunk.byteLength;\n              }\n              if (nWrote < 512 || 0 !== nWrote % 512) {\n                toss(\n                  'Input size',\n                  nWrote,\n                  'is not correct for an SQLite database.',\n                );\n              }\n              if (!checkedHeader) {\n                const header = new Uint8Array(20);\n                sah.read(header, { at: 0 });\n                util.affirmDbHeader(header);\n              }\n              sah.write(new Uint8Array([1, 1]), {\n                at: HEADER_OFFSET_DATA + 18,\n              });\n            } catch (e) {\n              this.setAssociatedPath(sah, '', 0);\n              throw e;\n            }\n            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);\n            return nWrote;\n          }\n\n          importDb(name, bytes) {\n            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n            else if (bytes instanceof Function)\n              return this.importDbChunked(name, bytes);\n            const sah =\n              this.#mapFilenameToSAH.get(name) ||\n              this.nextAvailableSAH() ||\n              toss('No available handles to import to.');\n            const n = bytes.byteLength;\n            if (n < 512 || n % 512 != 0) {\n              toss('Byte array size is invalid for an SQLite db.');\n            }\n            const header = 'SQLite format 3';\n            for (let i = 0; i < header.length; ++i) {\n              if (header.charCodeAt(i) !== bytes[i]) {\n                toss('Input does not contain an SQLite database header.');\n              }\n            }\n            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });\n            if (nWrote != n) {\n              this.setAssociatedPath(sah, '', 0);\n              toss(\n                'Expected to write ' + n + ' bytes but wrote ' + nWrote + '.',\n              );\n            } else {\n              sah.write(new Uint8Array([1, 1]), {\n                at: HEADER_OFFSET_DATA + 18,\n              });\n              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);\n            }\n            return nWrote;\n          }\n        }\n\n        class OpfsSAHPoolUtil {\n          #p;\n\n          constructor(sahPool) {\n            this.#p = sahPool;\n            this.vfsName = sahPool.vfsName;\n          }\n\n          async addCapacity(n) {\n            return this.#p.addCapacity(n);\n          }\n\n          async reduceCapacity(n) {\n            return this.#p.reduceCapacity(n);\n          }\n\n          getCapacity() {\n            return this.#p.getCapacity(this.#p);\n          }\n\n          getFileCount() {\n            return this.#p.getFileCount();\n          }\n          getFileNames() {\n            return this.#p.getFileNames();\n          }\n\n          async reserveMinimumCapacity(min) {\n            const c = this.#p.getCapacity();\n            return c < min ? this.#p.addCapacity(min - c) : c;\n          }\n\n          exportFile(name) {\n            return this.#p.exportFile(name);\n          }\n\n          importDb(name, bytes) {\n            return this.#p.importDb(name, bytes);\n          }\n\n          async wipeFiles() {\n            return this.#p.reset(true);\n          }\n\n          unlink(filename) {\n            return this.#p.deletePath(filename);\n          }\n\n          async removeVfs() {\n            return this.#p.removeVfs();\n          }\n\n          pauseVfs() {\n            this.#p.pauseVfs();\n            return this;\n          }\n          async unpauseVfs() {\n            return this.#p.unpauseVfs().then(() => this);\n          }\n          isPaused() {\n            return this.#p.isPaused();\n          }\n        }\n\n        const apiVersionCheck = async () => {\n          const dh = await navigator.storage.getDirectory();\n          const fn = '.opfs-sahpool-sync-check-' + getRandomName();\n          const fh = await dh.getFileHandle(fn, { create: true });\n          const ah = await fh.createSyncAccessHandle();\n          const close = ah.close();\n          await close;\n          await dh.removeEntry(fn);\n          if (close?.then) {\n            toss(\n              'The local OPFS API is too old for opfs-sahpool:',\n              'it has an async FileSystemSyncAccessHandle.close() method.',\n            );\n          }\n          return true;\n        };\n\n        sqlite3.installOpfsSAHPoolVfs = async function (\n          options = Object.create(null),\n        ) {\n          options = Object.assign(\n            Object.create(null),\n            optionDefaults,\n            options || {},\n          );\n          const vfsName = options.name;\n          if (options.$testThrowPhase1) {\n            throw options.$testThrowPhase1;\n          }\n          if (initPromises[vfsName]) {\n            try {\n              const p = await initPromises[vfsName];\n\n              return p;\n            } catch (e) {\n              if (options.forceReinitIfPreviouslyFailed) {\n                delete initPromises[vfsName];\n              } else {\n                throw e;\n              }\n            }\n          }\n          if (\n            !globalThis.FileSystemHandle ||\n            !globalThis.FileSystemDirectoryHandle ||\n            !globalThis.FileSystemFileHandle ||\n            !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||\n            !navigator?.storage?.getDirectory\n          ) {\n            return (initPromises[vfsName] = Promise.reject(\n              new Error('Missing required OPFS APIs.'),\n            ));\n          }\n\n          return (initPromises[vfsName] = apiVersionCheck()\n            .then(async function () {\n              if (options.$testThrowPhase2) {\n                throw options.$testThrowPhase2;\n              }\n              const thePool = new OpfsSAHPool(options);\n              return thePool.isReady\n                .then(async () => {\n                  const poolUtil = new OpfsSAHPoolUtil(thePool);\n                  if (sqlite3.oo1) {\n                    const oo1 = sqlite3.oo1;\n                    const theVfs = thePool.getVfs();\n                    const OpfsSAHPoolDb = function (...args) {\n                      const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);\n                      opt.vfs = theVfs.$zName;\n                      oo1.DB.dbCtorHelper.call(this, opt);\n                    };\n                    OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);\n                    poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;\n                  }\n                  thePool.log('VFS initialized.');\n                  return poolUtil;\n                })\n                .catch(async (e) => {\n                  await thePool.removeVfs().catch(() => {});\n                  throw e;\n                });\n            })\n            .catch((err) => {\n              return (initPromises[vfsName] = Promise.reject(err));\n            }));\n        };\n      });\n\n      ('use strict');\n      if ('undefined' !== typeof Module) {\n        const SABC = Object.assign(\n          Object.create(null),\n          {\n            exports:\n              'undefined' === typeof wasmExports ? Module['asm'] : wasmExports,\n            memory: Module.wasmMemory,\n          },\n          globalThis.sqlite3ApiConfig || {},\n        );\n\n        globalThis.sqlite3ApiConfig = SABC;\n        let sqlite3;\n        try {\n          sqlite3 = globalThis.sqlite3ApiBootstrap();\n        } catch (e) {\n          console.error('sqlite3ApiBootstrap() error:', e);\n          throw e;\n        } finally {\n          delete globalThis.sqlite3ApiBootstrap;\n          delete globalThis.sqlite3ApiConfig;\n        }\n\n        Module.sqlite3 = sqlite3;\n      } else {\n        console.warn(\n          'This is not running in an Emscripten module context, so',\n          'globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack',\n          'of config info for the WASM environment.',\n          'It must be called manually.',\n        );\n      }\n    };\n\n    moduleRtn = readyPromise;\n\n    return moduleRtn;\n  };\n})();\n\nconst toExportForESM = (function () {\n  const originalInit = sqlite3InitModule;\n  if (!originalInit) {\n    throw new Error(\n      'Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.',\n    );\n  }\n\n  const initModuleState = (globalThis.sqlite3InitModuleState = Object.assign(\n    Object.create(null),\n    {\n      moduleScript: globalThis?.document?.currentScript,\n      isWorker: 'undefined' !== typeof WorkerGlobalScope,\n      location: globalThis.location,\n      urlParams: globalThis?.location?.href\n        ? new URL(globalThis.location.href).searchParams\n        : new URLSearchParams(),\n    },\n  ));\n  initModuleState.debugModule = initModuleState.urlParams.has(\n    'sqlite3.debugModule',\n  )\n    ? (...args) => console.warn('sqlite3.debugModule:', ...args)\n    : () => {};\n\n  if (initModuleState.urlParams.has('sqlite3.dir')) {\n    initModuleState.sqlite3Dir =\n      initModuleState.urlParams.get('sqlite3.dir') + '/';\n  } else if (initModuleState.moduleScript) {\n    const li = initModuleState.moduleScript.src.split('/');\n    li.pop();\n    initModuleState.sqlite3Dir = li.join('/') + '/';\n  }\n\n  globalThis.sqlite3InitModule = function ff(...args) {\n    return originalInit(...args)\n      .then((EmscriptenModule) => {\n        EmscriptenModule.runSQLite3PostLoadInit(EmscriptenModule);\n        const s = EmscriptenModule.sqlite3;\n        s.scriptInfo = initModuleState;\n\n        if (ff.__isUnderTest) s.__isUnderTest = true;\n        const f = s.asyncPostInit;\n        delete s.asyncPostInit;\n        const rv = f();\n        return rv;\n      })\n      .catch((e) => {\n        console.error('Exception loading sqlite3 module:', e);\n        throw e;\n      });\n  };\n  globalThis.sqlite3InitModule.ready = originalInit.ready;\n\n  if (globalThis.sqlite3InitModuleState.moduleScript) {\n    const sim = globalThis.sqlite3InitModuleState;\n    let src = sim.moduleScript.src.split('/');\n    src.pop();\n    sim.scriptDir = src.join('/') + '/';\n  }\n  initModuleState.debugModule('sqlite3InitModuleState =', initModuleState);\n  if (false) {}\n  return globalThis.sqlite3InitModule;\n})();\nsqlite3InitModule = toExportForESM;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sqlite3InitModule);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9zcWxpdGUtd2FzbS9qc3dhc20vc3FsaXRlMy1idW5kbGVyLWZyaWVuZGx5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDhMQUFlOztBQUVuQyxpQ0FBaUM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixNQUFNLE9BQU87QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdURBQXVEOztBQUV2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUxBQXdDO0FBQ3JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCxPQUFPOztBQUUvRDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0VBQW9FLEVBQUU7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQThCO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQztBQUNoQzs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sR0FBRyxLQUFLO0FBQ2pDO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxHQUFHLEtBQUs7QUFDN0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELHFCQUFxQjs7QUFFeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaURBQWlELHFCQUFxQjs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRSxHQUFHLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQixrRUFBa0U7O0FBRWxFLCtDQUErQztBQUMvQyxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBQyxFQUFFLEVBS04sQ0FBQztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksS0FBQyxFQUFFLEVBZ0JOOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSTtBQUNsQjtBQUNBLGtCQUFrQixDQUlFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxLQUEwRCxFQUFFLEVBTS9EOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFDLEdBQUcsQ0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxZQUFZO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSx1REFBdUQ7QUFDdkQsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFDO0FBQ25CLGdCQUFnQixFQUtFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVMsUUFBUSxTQUFTO0FBQzFCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBQyxpQ0FBaUMsQ0FBSzs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUFRLGdNQUE4QyxDQUFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFLDZCQUE2QiwyQ0FBMkM7QUFDeEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxFQUFFLEdBQUcsSUFBSSxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxFQUFFLEdBQUcsRUFBRSxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0IsRUFBRSxNQUFNOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0MsZ0NBQWdDLDBCQUEwQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBQyxFQUFFLEVBU047QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBLGlFQUFlLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcGl5dXNoLmRhZ2FAcG9zdG1hbi5jb20vRG9jdW1lbnRzL1Byb2plY3RzL3BpeXVzaC1kYWdhL2V2YS0yL3Nlc3Npb24xLWJ1aWxkLXRvZG8tY2FsZW5kYXIvbm9kZV9tb2R1bGVzL0BzcWxpdGUub3JnL3NxbGl0ZS13YXNtL3NxbGl0ZS13YXNtL2pzd2FzbS9zcWxpdGUzLWJ1bmRsZXItZnJpZW5kbHkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiogTElDRU5TRSBmb3IgdGhlIHNxbGl0ZTMgV2ViQXNzZW1ibHkvSmF2YVNjcmlwdCBBUElzLlxuICoqXG4gKiogVGhpcyBidW5kbGUgKHR5cGljYWxseSByZWxlYXNlZCBhcyBzcWxpdGUzLmpzIG9yIHNxbGl0ZTMubWpzKVxuICoqIGlzIGFuIGFtYWxnYW1hdGlvbiBvZiBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIGZyb20gdHdvIHByb2plY3RzOlxuICoqXG4gKiogMSkgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZzogdGhlIEVtc2NyaXB0ZW4gXCJnbHVlIGNvZGVcIiBpcyBjb3ZlcmVkIGJ5XG4gKiogICAgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZSBhbmQgVW5pdmVyc2l0eSBvZiBJbGxpbm9pcy9OQ1NBXG4gKiogICAgT3BlbiBTb3VyY2UgTGljZW5zZSwgYXMgZGVzY3JpYmVkIGF0OlxuICoqXG4gKiogICAgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2ludHJvZHVjaW5nX2Vtc2NyaXB0ZW4vZW1zY3JpcHRlbl9saWNlbnNlLmh0bWxcbiAqKlxuICoqIDIpIGh0dHBzOi8vc3FsaXRlLm9yZzogYWxsIGNvZGUgYW5kIGRvY3VtZW50YXRpb24gbGFiZWxlZCBhcyBiZWluZ1xuICoqICAgIGZyb20gdGhpcyBzb3VyY2UgYXJlIHJlbGVhc2VkIHVuZGVyIHRoZSBzYW1lIHRlcm1zIGFzIHRoZSBzcWxpdGUzXG4gKiogICAgQyBsaWJyYXJ5OlxuICoqXG4gKiogMjAyMi0xMC0xNlxuICoqXG4gKiogVGhlIGF1dGhvciBkaXNjbGFpbXMgY29weXJpZ2h0IHRvIHRoaXMgc291cmNlIGNvZGUuICBJbiBwbGFjZSBvZiBhXG4gKiogbGVnYWwgbm90aWNlLCBoZXJlIGlzIGEgYmxlc3Npbmc6XG4gKipcbiAqKiAqICAgTWF5IHlvdSBkbyBnb29kIGFuZCBub3QgZXZpbC5cbiAqKiAqICAgTWF5IHlvdSBmaW5kIGZvcmdpdmVuZXNzIGZvciB5b3Vyc2VsZiBhbmQgZm9yZ2l2ZSBvdGhlcnMuXG4gKiogKiAgIE1heSB5b3Ugc2hhcmUgZnJlZWx5LCBuZXZlciB0YWtpbmcgbW9yZSB0aGFuIHlvdSBnaXZlLlxuICovXG4vKlxuICoqIFRoaXMgY29kZSB3YXMgYnVpbHQgZnJvbSBzcWxpdGUzIHZlcnNpb24uLi5cbiAqKlxuICoqIFNRTElURV9WRVJTSU9OIFwiMy41MC40XCJcbiAqKiBTUUxJVEVfVkVSU0lPTl9OVU1CRVIgMzA1MDAwNFxuICoqIFNRTElURV9TT1VSQ0VfSUQgXCIyMDI1LTA3LTMwIDE5OjMzOjUzIDRkOGFkZmIzMGUwM2Y5Y2YyN2Y4MDBhMmMxYmEzYzQ4ZmI0Y2ExYjA4YjBmNWVkNTlhNGQ1ZWNiZjQ1ZTIwYTNcIlxuICoqXG4gKiogVXNpbmcgdGhlIEVtc2NyaXB0ZW4gU0RLIHZlcnNpb24gMy4xLjcwLlxuICovXG5cbnZhciBzcWxpdGUzSW5pdE1vZHVsZSA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0TmFtZSA9IGltcG9ydC5tZXRhLnVybDtcblxuICByZXR1cm4gZnVuY3Rpb24gKG1vZHVsZUFyZyA9IHt9KSB7XG4gICAgdmFyIG1vZHVsZVJ0bjtcblxuICAgIHZhciBNb2R1bGUgPSBtb2R1bGVBcmc7XG5cbiAgICB2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xuICAgIHZhciByZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnO1xuICAgIHZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nO1xuXG4gICAgdmFyIEVOVklST05NRU5UX0lTX05PREUgPVxuICAgICAgdHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09ICdzdHJpbmcnICYmXG4gICAgICBwcm9jZXNzLnR5cGUgIT0gJ3JlbmRlcmVyJztcbiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPVxuICAgICAgIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG4gICAgY29uc3Qgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUgfHxcbiAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICBkZWJ1Z01vZHVsZTogKCkgPT4ge30sXG4gICAgICB9KTtcbiAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuICAgIHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoXG4gICAgICAnZ2xvYmFsVGhpcy5sb2NhdGlvbiA9JyxcbiAgICAgIGdsb2JhbFRoaXMubG9jYXRpb24sXG4gICAgKTtcblxuICAgIHZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuXG4gICAgdmFyIGFyZ3VtZW50c18gPSBbXTtcbiAgICB2YXIgdGhpc1Byb2dyYW0gPSAnLi90aGlzLnByb2dyYW0nO1xuICAgIHZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiAgICAgIHRocm93IHRvVGhyb3c7XG4gICAgfTtcblxuICAgIHZhciBzY3JpcHREaXJlY3RvcnkgPSAnJztcbiAgICBmdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiAgICAgIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgICAgICByZXR1cm4gTW9kdWxlWydsb2NhdGVGaWxlJ10ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyBwYXRoO1xuICAgIH1cblxuICAgIHZhciByZWFkQXN5bmMsIHJlYWRCaW5hcnk7XG5cbiAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgICAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBzZWxmLmxvY2F0aW9uLmhyZWY7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdERpcmVjdG9yeSA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3NjcmlwdE5hbWUpIHtcbiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JpcHREaXJlY3Rvcnkuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgJycpLmxhc3RJbmRleE9mKCcvJykgKyAxLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICAgICAgICByZWFkQmluYXJ5ID0gKHVybCkgPT4ge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZWFkQXN5bmMgPSAodXJsKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgJyA6ICcgKyByZXNwb25zZS51cmwpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIH1cblxuICAgIHZhciBvdXQgPSBNb2R1bGVbJ3ByaW50J10gfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICB2YXIgZXJyID0gTW9kdWxlWydwcmludEVyciddIHx8IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcblxuICAgIE9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG4gICAgbW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcblxuICAgIGlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtcblxuICAgIGlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuXG4gICAgdmFyIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcblxuICAgIHZhciB3YXNtTWVtb3J5O1xuXG4gICAgdmFyIEFCT1JUID0gZmFsc2U7XG5cbiAgICB2YXIgRVhJVFNUQVRVUztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGFib3J0KHRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBIRUFQLFxuICAgICAgSEVBUDgsXG4gICAgICBIRUFQVTgsXG4gICAgICBIRUFQMTYsXG4gICAgICBIRUFQVTE2LFxuICAgICAgSEVBUDMyLFxuICAgICAgSEVBUFUzMixcbiAgICAgIEhFQVBGMzIsXG4gICAgICBIRUFQNjQsXG4gICAgICBIRUFQVTY0LFxuICAgICAgSEVBUEY2NDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCkge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUDE2J10gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUFUxNiddID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUDMyJ10gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICAgIE1vZHVsZVsnSEVBUEYzMiddID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gICAgICBNb2R1bGVbJ0hFQVBGNjQnXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQNjQnXSA9IEhFQVA2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KGIpO1xuICAgICAgTW9kdWxlWydIRUFQVTY0J10gPSBIRUFQVTY0ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGIpO1xuICAgIH1cblxuICAgIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgSU5JVElBTF9NRU1PUlkgPSBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XG5cbiAgICAgIHdhc21NZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcbiAgICAgICAgaW5pdGlhbDogSU5JVElBTF9NRU1PUlkgLyA2NTUzNixcblxuICAgICAgICBtYXhpbXVtOiAzMjc2OCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG5cbiAgICB2YXIgX19BVFBSRVJVTl9fID0gW107XG4gICAgdmFyIF9fQVRJTklUX18gPSBbXTtcbiAgICB2YXIgX19BVEVYSVRfXyA9IFtdO1xuICAgIHZhciBfX0FUUE9TVFJVTl9fID0gW107XG5cbiAgICB2YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBwcmVSdW4oKSB7XG4gICAgICB2YXIgcHJlUnVucyA9IE1vZHVsZVsncHJlUnVuJ107XG4gICAgICBpZiAocHJlUnVucykge1xuICAgICAgICBpZiAodHlwZW9mIHByZVJ1bnMgPT0gJ2Z1bmN0aW9uJykgcHJlUnVucyA9IFtwcmVSdW5zXTtcbiAgICAgICAgcHJlUnVucy5mb3JFYWNoKGFkZE9uUHJlUnVuKTtcbiAgICAgIH1cbiAgICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7XG4gICAgICBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIU1vZHVsZVsnbm9GU0luaXQnXSAmJiAhRlMuaW5pdGlhbGl6ZWQpIEZTLmluaXQoKTtcbiAgICAgIEZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XG5cbiAgICAgIFRUWS5pbml0KCk7XG4gICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3N0UnVuKCkge1xuICAgICAgdmFyIHBvc3RSdW5zID0gTW9kdWxlWydwb3N0UnVuJ107XG4gICAgICBpZiAocG9zdFJ1bnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3N0UnVucyA9PSAnZnVuY3Rpb24nKSBwb3N0UnVucyA9IFtwb3N0UnVuc107XG4gICAgICAgIHBvc3RSdW5zLmZvckVhY2goYWRkT25Qb3N0UnVuKTtcbiAgICAgIH1cblxuICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgICAgIF9fQVRJTklUX18udW5zaGlmdChjYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT25FeGl0KGNiKSB7fVxuXG4gICAgZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gICAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xuICAgIH1cblxuICAgIHZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xuICAgIHZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gICAgdmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICAgICAgcnVuRGVwZW5kZW5jaWVzKys7XG5cbiAgICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddPy4ocnVuRGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gICAgICBydW5EZXBlbmRlbmNpZXMtLTtcblxuICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10/LihydW5EZXBlbmRlbmNpZXMpO1xuXG4gICAgICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICAgICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7XG4gICAgICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXNGdWxmaWxsZWQpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuICAgICAgTW9kdWxlWydvbkFib3J0J10/Lih3aGF0KTtcblxuICAgICAgd2hhdCA9ICdBYm9ydGVkKCcgKyB3aGF0ICsgJyknO1xuXG4gICAgICBlcnIod2hhdCk7XG5cbiAgICAgIEFCT1JUID0gdHJ1ZTtcblxuICAgICAgd2hhdCArPSAnLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLic7XG5cbiAgICAgIHZhciBlID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtcblxuICAgICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciBkYXRhVVJJUHJlZml4ID0gJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwnO1xuXG4gICAgdmFyIGlzRGF0YVVSSSA9IChmaWxlbmFtZSkgPT4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcblxuICAgIHZhciBpc0ZpbGVVUkkgPSAoZmlsZW5hbWUpID0+IGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRXYXNtQmluYXJ5KCkge1xuICAgICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICAgIHZhciBmID0gJ3NxbGl0ZTMud2FzbSc7XG4gICAgICAgIGlmICghaXNEYXRhVVJJKGYpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2F0ZUZpbGUoZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgVVJMKCdzcWxpdGUzLndhc20nLCBpbXBvcnQubWV0YS51cmwpLmhyZWY7XG4gICAgfVxuXG4gICAgdmFyIHdhc21CaW5hcnlGaWxlO1xuXG4gICAgZnVuY3Rpb24gZ2V0QmluYXJ5U3luYyhmaWxlKSB7XG4gICAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiByZWFkQmluYXJ5KGZpbGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgJ2JvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpIHtcbiAgICAgIGlmICghd2FzbUJpbmFyeSkge1xuICAgICAgICByZXR1cm4gcmVhZEFzeW5jKGJpbmFyeUZpbGUpLnRoZW4oXG4gICAgICAgICAgKHJlc3BvbnNlKSA9PiBuZXcgVWludDhBcnJheShyZXNwb25zZSksXG5cbiAgICAgICAgICAoKSA9PiBnZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBnZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKVxuICAgICAgICAudGhlbigoYmluYXJ5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW1wb3J0cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlY2VpdmVyLCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTtcblxuICAgICAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LCBiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKFxuICAgICAgICAhYmluYXJ5ICYmXG4gICAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICFpc0RhdGFVUkkoYmluYXJ5RmlsZSkgJiZcbiAgICAgICAgdHlwZW9mIGZldGNoID09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmV0Y2goYmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKFxuICAgICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGNhbGxiYWNrLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgIGVycihgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7cmVhc29ufWApO1xuICAgICAgICAgICAgICBlcnIoJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2FzbUltcG9ydHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnY6IHdhc21JbXBvcnRzLFxuICAgICAgICB3YXNpX3NuYXBzaG90X3ByZXZpZXcxOiB3YXNtSW1wb3J0cyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgICAgIHZhciBpbmZvID0gZ2V0V2FzbUltcG9ydHMoKTtcblxuICAgICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICAgICAgd2FzbUV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuXG4gICAgICAgIGFkZE9uSW5pdCh3YXNtRXhwb3J0c1snX193YXNtX2NhbGxfY3RvcnMnXSk7XG5cbiAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xuICAgICAgICByZXR1cm4gd2FzbUV4cG9ydHM7XG4gICAgICB9XG5cbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICAgICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICAgICAgfVxuXG4gICAgICBpZiAoTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnIoYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZX1gKTtcblxuICAgICAgICAgIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3YXNtQmluYXJ5RmlsZSA/Pz0gZmluZFdhc21CaW5hcnkoKTtcblxuICAgICAgaW5zdGFudGlhdGVBc3luYyhcbiAgICAgICAgd2FzbUJpbmFyeSxcbiAgICAgICAgd2FzbUJpbmFyeUZpbGUsXG4gICAgICAgIGluZm8sXG4gICAgICAgIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LFxuICAgICAgKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICB0aGlzLm5hbWUgPSAnRXhpdFN0YXR1cyc7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBgUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke3N0YXR1c30pYDtcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cblxuICAgIHZhciBjYWxsUnVudGltZUNhbGxiYWNrcyA9IChjYWxsYmFja3MpID0+IHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChmKSA9PiBmKE1vZHVsZSkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShwdHIsIHR5cGUgPSAnaTgnKSB7XG4gICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gJyonO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2kxJzpcbiAgICAgICAgICByZXR1cm4gSEVBUDhbcHRyXTtcbiAgICAgICAgY2FzZSAnaTgnOlxuICAgICAgICAgIHJldHVybiBIRUFQOFtwdHJdO1xuICAgICAgICBjYXNlICdpMTYnOlxuICAgICAgICAgIHJldHVybiBIRUFQMTZbcHRyID4+IDFdO1xuICAgICAgICBjYXNlICdpMzInOlxuICAgICAgICAgIHJldHVybiBIRUFQMzJbcHRyID4+IDJdO1xuICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgIHJldHVybiBIRUFQNjRbcHRyID4+IDNdO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgcmV0dXJuIEhFQVBGMzJbcHRyID4+IDJdO1xuICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgIHJldHVybiBIRUFQRjY0W3B0ciA+PiAzXTtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmV0dXJuIEhFQVBVMzJbcHRyID4+IDJdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSB8fCB0cnVlO1xuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUocHRyLCB2YWx1ZSwgdHlwZSA9ICdpOCcpIHtcbiAgICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgIEhFQVA4W3B0cl0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaTgnOlxuICAgICAgICAgIEhFQVA4W3B0cl0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaTE2JzpcbiAgICAgICAgICBIRUFQMTZbcHRyID4+IDFdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2kzMic6XG4gICAgICAgICAgSEVBUDMyW3B0ciA+PiAyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgIEhFQVA2NFtwdHIgPj4gM10gPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgSEVBUEYzMltwdHIgPj4gMl0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICBIRUFQRjY0W3B0ciA+PiAzXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICBIRUFQVTMyW3B0ciA+PiAyXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrUmVzdG9yZSA9ICh2YWwpID0+IF9fZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlKHZhbCk7XG5cbiAgICB2YXIgc3RhY2tTYXZlID0gKCkgPT4gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQoKTtcblxuICAgIHZhciBQQVRIID0ge1xuICAgICAgaXNBYnM6IChwYXRoKSA9PiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgICAgc3BsaXRQYXRoOiAoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID1cbiAgICAgICAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZUFycmF5OiAocGFydHMsIGFsbG93QWJvdmVSb290KSA9PiB7XG4gICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZTogKHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBQQVRILmlzQWJzKHBhdGgpLFxuICAgICAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnN1YnN0cigtMSkgPT09ICcvJztcblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShcbiAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLFxuICAgICAgICAgICFpc0Fic29sdXRlLFxuICAgICAgICApLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgcGF0aCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgICAgIH0sXG4gICAgICBkaXJuYW1lOiAocGF0aCkgPT4ge1xuICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QgKyBkaXI7XG4gICAgICB9LFxuICAgICAgYmFzZW5hbWU6IChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpIHJldHVybiBwYXRoO1xuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoICsgMSk7XG4gICAgICB9LFxuICAgICAgam9pbjogKC4uLnBhdGhzKSA9PiBQQVRILm5vcm1hbGl6ZShwYXRocy5qb2luKCcvJykpLFxuICAgICAgam9pbjI6IChsLCByKSA9PiBQQVRILm5vcm1hbGl6ZShsICsgJy8nICsgciksXG4gICAgfTtcblxuICAgIHZhciBpbml0UmFuZG9tRmlsbCA9ICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNyeXB0byA9PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSA9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICh2aWV3KSA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHZpZXcpO1xuICAgICAgfSBlbHNlIGFib3J0KCdpbml0UmFuZG9tRGV2aWNlJyk7XG4gICAgfTtcbiAgICB2YXIgcmFuZG9tRmlsbCA9ICh2aWV3KSA9PiB7XG4gICAgICByZXR1cm4gKHJhbmRvbUZpbGwgPSBpbml0UmFuZG9tRmlsbCgpKSh2aWV3KTtcbiAgICB9O1xuXG4gICAgdmFyIFBBVEhfRlMgPSB7XG4gICAgICByZXNvbHZlOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IGkgPj0gMCA/IGFyZ3NbaV0gOiBGUy5jd2QoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KFxuICAgICAgICAgIHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKSxcbiAgICAgICAgICAhcmVzb2x2ZWRBYnNvbHV0ZSxcbiAgICAgICAgKS5qb2luKCcvJyk7XG4gICAgICAgIHJldHVybiAocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCB8fCAnLic7XG4gICAgICB9LFxuICAgICAgcmVsYXRpdmU6IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBmcm9tID0gUEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgICAgICAgdG8gPSBQQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtcbiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIFVURjhEZWNvZGVyID1cbiAgICAgIHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIFVURjhBcnJheVRvU3RyaW5nID0gKGhlYXBPckFycmF5LCBpZHggPSAwLCBtYXhCeXRlc1RvUmVhZCA9IE5hTikgPT4ge1xuICAgICAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuICAgICAgdmFyIGVuZFB0ciA9IGlkeDtcblxuICAgICAgd2hpbGUgKGhlYXBPckFycmF5W2VuZFB0cl0gJiYgIShlbmRQdHIgPj0gZW5kSWR4KSkgKytlbmRQdHI7XG5cbiAgICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gICAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgICAgaWYgKCEodTAgJiAweDgwKSkge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgICAgaWYgKCh1MCAmIDB4ZTApID09IDB4YzApIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgICAgICBpZiAoKHUwICYgMHhmMCkgPT0gMHhlMCkge1xuICAgICAgICAgIHUwID0gKCh1MCAmIDE1KSA8PCAxMikgfCAodTEgPDwgNikgfCB1MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1MCA9XG4gICAgICAgICAgICAoKHUwICYgNykgPDwgMTgpIHxcbiAgICAgICAgICAgICh1MSA8PCAxMikgfFxuICAgICAgICAgICAgKHUyIDw8IDYpIHxcbiAgICAgICAgICAgIChoZWFwT3JBcnJheVtpZHgrK10gJiA2Myk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodTAgPCAweDEwMDAwKSB7XG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaCA9IHUwIC0gMHgxMDAwMDtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAgIDB4ZDgwMCB8IChjaCA+PiAxMCksXG4gICAgICAgICAgICAweGRjMDAgfCAoY2ggJiAweDNmZiksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgdmFyIEZTX3N0ZGluX2dldENoYXJfYnVmZmVyID0gW107XG5cbiAgICB2YXIgbGVuZ3RoQnl0ZXNVVEY4ID0gKHN0cikgPT4ge1xuICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAweDdmKSB7XG4gICAgICAgICAgbGVuKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8PSAweDdmZikge1xuICAgICAgICAgIGxlbiArPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgbGVuICs9IDQ7XG4gICAgICAgICAgKytpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbiArPSAzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH07XG5cbiAgICB2YXIgc3RyaW5nVG9VVEY4QXJyYXkgPSAoc3RyLCBoZWFwLCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkgPT4ge1xuICAgICAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpIHJldHVybiAwO1xuXG4gICAgICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gICAgICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICh1ID49IDB4ZDgwMCAmJiB1IDw9IDB4ZGZmZikge1xuICAgICAgICAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICAgICAgICAgdSA9ICgweDEwMDAwICsgKCh1ICYgMHgzZmYpIDw8IDEwKSkgfCAodTEgJiAweDNmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUgPD0gMHg3Zikge1xuICAgICAgICAgIGlmIChvdXRJZHggPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IHU7XG4gICAgICAgIH0gZWxzZSBpZiAodSA8PSAweDdmZikge1xuICAgICAgICAgIGlmIChvdXRJZHggKyAxID49IGVuZElkeCkgYnJlYWs7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweGMwIHwgKHUgPj4gNik7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICAgIH0gZWxzZSBpZiAodSA8PSAweGZmZmYpIHtcbiAgICAgICAgICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhlMCB8ICh1ID4+IDEyKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ZjAgfCAodSA+PiAxOCk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcbiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaGVhcFtvdXRJZHhdID0gMDtcbiAgICAgIHJldHVybiBvdXRJZHggLSBzdGFydElkeDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHtcbiAgICAgIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpICsgMTtcbiAgICAgIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gICAgICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoXG4gICAgICAgIHN0cmluZ3ksXG4gICAgICAgIHU4YXJyYXksXG4gICAgICAgIDAsXG4gICAgICAgIHU4YXJyYXkubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gICAgICByZXR1cm4gdThhcnJheTtcbiAgICB9XG4gICAgdmFyIEZTX3N0ZGluX2dldENoYXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIUZTX3N0ZGluX2dldENoYXJfYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICB0eXBlb2Ygd2luZG93LnByb21wdCA9PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoJ0lucHV0OiAnKTtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIgPSBpbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGU19zdGRpbl9nZXRDaGFyX2J1ZmZlci5zaGlmdCgpO1xuICAgIH07XG4gICAgdmFyIFRUWSA9IHtcbiAgICAgIHR0eXM6IFtdLFxuICAgICAgaW5pdCgpIHt9LFxuICAgICAgc2h1dGRvd24oKSB7fSxcbiAgICAgIHJlZ2lzdGVyKGRldiwgb3BzKSB7XG4gICAgICAgIFRUWS50dHlzW2Rldl0gPSB7IGlucHV0OiBbXSwgb3V0cHV0OiBbXSwgb3BzOiBvcHMgfTtcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCBUVFkuc3RyZWFtX29wcyk7XG4gICAgICB9LFxuICAgICAgc3RyZWFtX29wczoge1xuICAgICAgICBvcGVuKHN0cmVhbSkge1xuICAgICAgICAgIHZhciB0dHkgPSBUVFkudHR5c1tzdHJlYW0ubm9kZS5yZGV2XTtcbiAgICAgICAgICBpZiAoIXR0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0udHR5ID0gdHR5O1xuICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZShzdHJlYW0pIHtcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mc3luYyhzdHJlYW0udHR5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnN5bmMoc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LCBidWZmZXJbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZGVmYXVsdF90dHlfb3BzOiB7XG4gICAgICAgIGdldF9jaGFyKHR0eSkge1xuICAgICAgICAgIHJldHVybiBGU19zdGRpbl9nZXRDaGFyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dF9jaGFyKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnN5bmModHR5KSB7XG4gICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW9jdGxfdGNnZXRzKHR0eSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjX2lmbGFnOiAyNTg1NixcbiAgICAgICAgICAgIGNfb2ZsYWc6IDUsXG4gICAgICAgICAgICBjX2NmbGFnOiAxOTEsXG4gICAgICAgICAgICBjX2xmbGFnOiAzNTM4NyxcbiAgICAgICAgICAgIGNfY2M6IFtcbiAgICAgICAgICAgICAgMHgwMywgMHgxYywgMHg3ZiwgMHgxNSwgMHgwNCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgxMSwgMHgxMywgMHgxYSxcbiAgICAgICAgICAgICAgMHgwMCwgMHgxMiwgMHgwZiwgMHgxNywgMHgxNiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaW9jdGxfdGNzZXRzKHR0eSwgb3B0aW9uYWxfYWN0aW9ucywgZGF0YSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBpb2N0bF90aW9jZ3dpbnN6KHR0eSkge1xuICAgICAgICAgIHJldHVybiBbMjQsIDgwXTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0X3R0eTFfb3BzOiB7XG4gICAgICAgIHB1dF9jaGFyKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnN5bmModHR5KSB7XG4gICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciB6ZXJvTWVtb3J5ID0gKGFkZHJlc3MsIHNpemUpID0+IHtcbiAgICAgIEhFQVBVOC5maWxsKDAsIGFkZHJlc3MsIGFkZHJlc3MgKyBzaXplKTtcbiAgICB9O1xuXG4gICAgdmFyIGFsaWduTWVtb3J5ID0gKHNpemUsIGFsaWdubWVudCkgPT4ge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gYWxpZ25tZW50KSAqIGFsaWdubWVudDtcbiAgICB9O1xuICAgIHZhciBtbWFwQWxsb2MgPSAoc2l6ZSkgPT4ge1xuICAgICAgc2l6ZSA9IGFsaWduTWVtb3J5KHNpemUsIDY1NTM2KTtcbiAgICAgIHZhciBwdHIgPSBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduKDY1NTM2LCBzaXplKTtcbiAgICAgIGlmIChwdHIpIHplcm9NZW1vcnkocHRyLCBzaXplKTtcbiAgICAgIHJldHVybiBwdHI7XG4gICAgfTtcbiAgICB2YXIgTUVNRlMgPSB7XG4gICAgICBvcHNfdGFibGU6IG51bGwsXG4gICAgICBtb3VudChtb3VudCkge1xuICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIDE2Mzg0IHwgNTExLCAwKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7XG4gICAgICAgIGlmIChGUy5pc0Jsa2Rldihtb2RlKSB8fCBGUy5pc0ZJRk8obW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgTUVNRlMub3BzX3RhYmxlIHx8PSB7XG4gICAgICAgICAgZGlyOiB7XG4gICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgIGxvb2t1cDogTUVNRlMubm9kZV9vcHMubG9va3VwLFxuICAgICAgICAgICAgICBta25vZDogTUVNRlMubm9kZV9vcHMubWtub2QsXG4gICAgICAgICAgICAgIHJlbmFtZTogTUVNRlMubm9kZV9vcHMucmVuYW1lLFxuICAgICAgICAgICAgICB1bmxpbms6IE1FTUZTLm5vZGVfb3BzLnVubGluayxcbiAgICAgICAgICAgICAgcm1kaXI6IE1FTUZTLm5vZGVfb3BzLnJtZGlyLFxuICAgICAgICAgICAgICByZWFkZGlyOiBNRU1GUy5ub2RlX29wcy5yZWFkZGlyLFxuICAgICAgICAgICAgICBzeW1saW5rOiBNRU1GUy5ub2RlX29wcy5zeW1saW5rLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmVhbToge1xuICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayxcbiAgICAgICAgICAgICAgcmVhZDogTUVNRlMuc3RyZWFtX29wcy5yZWFkLFxuICAgICAgICAgICAgICB3cml0ZTogTUVNRlMuc3RyZWFtX29wcy53cml0ZSxcbiAgICAgICAgICAgICAgYWxsb2NhdGU6IE1FTUZTLnN0cmVhbV9vcHMuYWxsb2NhdGUsXG4gICAgICAgICAgICAgIG1tYXA6IE1FTUZTLnN0cmVhbV9vcHMubW1hcCxcbiAgICAgICAgICAgICAgbXN5bmM6IE1FTUZTLnN0cmVhbV9vcHMubXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGluazoge1xuICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICByZWFkbGluazogTUVNRlMubm9kZV9vcHMucmVhZGxpbmssXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtOiB7fSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNocmRldjoge1xuICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG5cbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IG5vZGUudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGdldEZpbGVEYXRhQXNUeXBlZEFycmF5KG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5KVxuICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpO1xuICAgICAgfSxcbiAgICAgIGV4cGFuZEZpbGVTdG9yYWdlKG5vZGUsIG5ld0NhcGFjaXR5KSB7XG4gICAgICAgIHZhciBwcmV2Q2FwYWNpdHkgPSBub2RlLmNvbnRlbnRzID8gbm9kZS5jb250ZW50cy5sZW5ndGggOiAwO1xuICAgICAgICBpZiAocHJldkNhcGFjaXR5ID49IG5ld0NhcGFjaXR5KSByZXR1cm47XG5cbiAgICAgICAgdmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWCA9IDEwMjQgKiAxMDI0O1xuICAgICAgICBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KFxuICAgICAgICAgIG5ld0NhcGFjaXR5LFxuICAgICAgICAgIChwcmV2Q2FwYWNpdHkgKlxuICAgICAgICAgICAgKHByZXZDYXBhY2l0eSA8IENBUEFDSVRZX0RPVUJMSU5HX01BWCA/IDIuMCA6IDEuMTI1KSkgPj4+XG4gICAgICAgICAgICAwLFxuICAgICAgICApO1xuICAgICAgICBpZiAocHJldkNhcGFjaXR5ICE9IDApIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgobmV3Q2FwYWNpdHksIDI1Nik7XG4gICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7XG4gICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7XG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA+IDApXG4gICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpLCAwKTtcbiAgICAgIH0sXG4gICAgICByZXNpemVGaWxlU3RvcmFnZShub2RlLCBuZXdTaXplKSB7XG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA9PSBuZXdTaXplKSByZXR1cm47XG4gICAgICAgIGlmIChuZXdTaXplID09IDApIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7XG4gICAgICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChcbiAgICAgICAgICAgICAgb2xkQ29udGVudHMuc3ViYXJyYXkoMCwgTWF0aC5taW4obmV3U2l6ZSwgbm9kZS51c2VkQnl0ZXMpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vZGVfb3BzOiB7XG4gICAgICAgIGdldGF0dHIobm9kZSkge1xuICAgICAgICAgIHZhciBhdHRyID0ge307XG5cbiAgICAgICAgICBhdHRyLmRldiA9IEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkgPyBub2RlLmlkIDogMTtcbiAgICAgICAgICBhdHRyLmlubyA9IG5vZGUuaWQ7XG4gICAgICAgICAgYXR0ci5tb2RlID0gbm9kZS5tb2RlO1xuICAgICAgICAgIGF0dHIubmxpbmsgPSAxO1xuICAgICAgICAgIGF0dHIudWlkID0gMDtcbiAgICAgICAgICBhdHRyLmdpZCA9IDA7XG4gICAgICAgICAgYXR0ci5yZGV2ID0gbm9kZS5yZGV2O1xuICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSA0MDk2O1xuICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IG5vZGUudXNlZEJ5dGVzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IG5vZGUubGluay5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHIuYXRpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgYXR0ci5tdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLmN0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuXG4gICAgICAgICAgYXR0ci5ibGtzaXplID0gNDA5NjtcbiAgICAgICAgICBhdHRyLmJsb2NrcyA9IE1hdGguY2VpbChhdHRyLnNpemUgLyBhdHRyLmJsa3NpemUpO1xuICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRhdHRyKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICBpZiAoYXR0ci5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUubW9kZSA9IGF0dHIubW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHIudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gYXR0ci50aW1lc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTUVNRlMucmVzaXplRmlsZVN0b3JhZ2Uobm9kZSwgYXR0ci5zaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxvb2t1cChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBGUy5nZW5lcmljRXJyb3JzWzQ0XTtcbiAgICAgICAgfSxcbiAgICAgICAgbWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmFtZShvbGRfbm9kZSwgbmV3X2RpciwgbmV3X25hbWUpIHtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgaWYgKG5ld19ub2RlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWxldGUgb2xkX25vZGUucGFyZW50LmNvbnRlbnRzW29sZF9ub2RlLm5hbWVdO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIG9sZF9ub2RlLm5hbWUgPSBuZXdfbmFtZTtcbiAgICAgICAgICBuZXdfZGlyLmNvbnRlbnRzW25ld19uYW1lXSA9IG9sZF9ub2RlO1xuICAgICAgICAgIG5ld19kaXIudGltZXN0YW1wID0gb2xkX25vZGUucGFyZW50LnRpbWVzdGFtcDtcbiAgICAgICAgfSxcbiAgICAgICAgdW5saW5rKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJtZGlyKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkZGlyKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IFsnLicsICcuLiddO1xuICAgICAgICAgIGZvciAodmFyIGtleSBvZiBPYmplY3Qua2V5cyhub2RlLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICBzeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkge1xuICAgICAgICAgIHZhciBub2RlID0gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5ld25hbWUsIDUxMSB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICAgICAgICByZWFkbGluayhub2RlKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5saW5rO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHN0cmVhbV9vcHM6IHtcbiAgICAgICAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnVzZWRCeXRlcykgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihzdHJlYW0ubm9kZS51c2VkQnl0ZXMgLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICBpZiAoc2l6ZSA+IDggJiYgY29udGVudHMuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSksIG9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xuICAgICAgICAgICAgY2FuT3duID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBub2RlID0gc3RyZWFtLm5vZGU7XG4gICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHtcbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uICsgbGVuZ3RoIDw9IG5vZGUudXNlZEJ5dGVzKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoXG4gICAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzW3Bvc2l0aW9uICsgaV0gPSBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBsbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9mZnNldDtcbiAgICAgICAgICBpZiAod2hlbmNlID09PSAxKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIGlmICh3aGVuY2UgPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKHN0cmVhbS5ub2RlLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3RyZWFtLm5vZGUudXNlZEJ5dGVzLFxuICAgICAgICAgICAgb2Zmc2V0ICsgbGVuZ3RoLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG1tYXAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xuICAgICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwdHI7XG4gICAgICAgICAgdmFyIGFsbG9jYXRlZDtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcblxuICAgICAgICAgIGlmICghKGZsYWdzICYgMikgJiYgY29udGVudHMgJiYgY29udGVudHMuYnVmZmVyID09PSBIRUFQOC5idWZmZXIpIHtcbiAgICAgICAgICAgIGFsbG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcHRyID0gY29udGVudHMuYnl0ZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxsb2NhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHB0ciA9IG1tYXBBbGxvYyhsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IDAgfHwgcG9zaXRpb24gKyBsZW5ndGggPCBjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEhFQVA4LnNldChjb250ZW50cywgcHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgcHRyLCBhbGxvY2F0ZWQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpIHtcbiAgICAgICAgICBNRU1GUy5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCAwLCBsZW5ndGgsIG9mZnNldCwgZmFsc2UpO1xuXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB2YXIgYXN5bmNMb2FkID0gKHVybCwgb25sb2FkLCBvbmVycm9yLCBub1J1bkRlcCkgPT4ge1xuICAgICAgdmFyIGRlcCA9ICFub1J1bkRlcCA/IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koYGFsICR7dXJsfWApIDogJyc7XG4gICAgICByZWFkQXN5bmModXJsKS50aGVuKFxuICAgICAgICAoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgICBvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgICBpZiAoZGVwKSByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAob25lcnJvcikge1xuICAgICAgICAgICAgb25lcnJvcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBgTG9hZGluZyBkYXRhIGZpbGUgXCIke3VybH1cIiBmYWlsZWQuYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgaWYgKGRlcCkgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgIH07XG5cbiAgICB2YXIgRlNfY3JlYXRlRGF0YUZpbGUgPSAoXG4gICAgICBwYXJlbnQsXG4gICAgICBuYW1lLFxuICAgICAgZmlsZURhdGEsXG4gICAgICBjYW5SZWFkLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Pd24sXG4gICAgKSA9PiB7XG4gICAgICBGUy5jcmVhdGVEYXRhRmlsZShwYXJlbnQsIG5hbWUsIGZpbGVEYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKTtcbiAgICB9O1xuXG4gICAgdmFyIHByZWxvYWRQbHVnaW5zID0gTW9kdWxlWydwcmVsb2FkUGx1Z2lucyddIHx8IFtdO1xuICAgIHZhciBGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luID0gKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgb25lcnJvcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBCcm93c2VyICE9ICd1bmRlZmluZWQnKSBCcm93c2VyLmluaXQoKTtcblxuICAgICAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIHByZWxvYWRQbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICBpZiAoaGFuZGxlZCkgcmV0dXJuO1xuICAgICAgICBpZiAocGx1Z2luWydjYW5IYW5kbGUnXShmdWxsbmFtZSkpIHtcbiAgICAgICAgICBwbHVnaW5bJ2hhbmRsZSddKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgb25lcnJvcik7XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfTtcbiAgICB2YXIgRlNfY3JlYXRlUHJlbG9hZGVkRmlsZSA9IChcbiAgICAgIHBhcmVudCxcbiAgICAgIG5hbWUsXG4gICAgICB1cmwsXG4gICAgICBjYW5SZWFkLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBvbmxvYWQsXG4gICAgICBvbmVycm9yLFxuICAgICAgZG9udENyZWF0ZUZpbGUsXG4gICAgICBjYW5Pd24sXG4gICAgICBwcmVGaW5pc2gsXG4gICAgKSA9PiB7XG4gICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lID8gUEFUSF9GUy5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LCBuYW1lKSkgOiBwYXJlbnQ7XG4gICAgICB2YXIgZGVwID0gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShgY3AgJHtmdWxsbmFtZX1gKTtcbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGJ5dGVBcnJheSkge1xuICAgICAgICBmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KSB7XG4gICAgICAgICAgcHJlRmluaXNoPy4oKTtcbiAgICAgICAgICBpZiAoIWRvbnRDcmVhdGVGaWxlKSB7XG4gICAgICAgICAgICBGU19jcmVhdGVEYXRhRmlsZShcbiAgICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBieXRlQXJyYXksXG4gICAgICAgICAgICAgIGNhblJlYWQsXG4gICAgICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgICAgICBjYW5Pd24sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbmxvYWQ/LigpO1xuICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgRlNfaGFuZGxlZEJ5UHJlbG9hZFBsdWdpbihieXRlQXJyYXksIGZ1bGxuYW1lLCBmaW5pc2gsICgpID0+IHtcbiAgICAgICAgICAgIG9uZXJyb3I/LigpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH0pXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2goYnl0ZUFycmF5KTtcbiAgICAgIH1cbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgIGlmICh0eXBlb2YgdXJsID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFzeW5jTG9hZCh1cmwsIHByb2Nlc3NEYXRhLCBvbmVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NEYXRhKHVybCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBGU19tb2RlU3RyaW5nVG9GbGFncyA9IChzdHIpID0+IHtcbiAgICAgIHZhciBmbGFnTW9kZXMgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgICdyKyc6IDIsXG4gICAgICAgIHc6IDUxMiB8IDY0IHwgMSxcbiAgICAgICAgJ3crJzogNTEyIHwgNjQgfCAyLFxuICAgICAgICBhOiAxMDI0IHwgNjQgfCAxLFxuICAgICAgICAnYSsnOiAxMDI0IHwgNjQgfCAyLFxuICAgICAgfTtcbiAgICAgIHZhciBmbGFncyA9IGZsYWdNb2Rlc1tzdHJdO1xuICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZSBvcGVuIG1vZGU6ICR7c3RyfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH07XG5cbiAgICB2YXIgRlNfZ2V0TW9kZSA9IChjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgdmFyIG1vZGUgPSAwO1xuICAgICAgaWYgKGNhblJlYWQpIG1vZGUgfD0gMjkyIHwgNzM7XG4gICAgICBpZiAoY2FuV3JpdGUpIG1vZGUgfD0gMTQ2O1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfTtcblxuICAgIHZhciBGUyA9IHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICBtb3VudHM6IFtdLFxuICAgICAgZGV2aWNlczoge30sXG4gICAgICBzdHJlYW1zOiBbXSxcbiAgICAgIG5leHRJbm9kZTogMSxcbiAgICAgIG5hbWVUYWJsZTogbnVsbCxcbiAgICAgIGN1cnJlbnRQYXRoOiAnLycsXG4gICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICBpZ25vcmVQZXJtaXNzaW9uczogdHJ1ZSxcbiAgICAgIEVycm5vRXJyb3I6IGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3IoZXJybm8pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSAnRXJybm9FcnJvcic7XG4gICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2VuZXJpY0Vycm9yczoge30sXG4gICAgICBmaWxlc3lzdGVtczogbnVsbCxcbiAgICAgIHN5bmNGU1JlcXVlc3RzOiAwLFxuICAgICAgcmVhZEZpbGVzOiB7fSxcbiAgICAgIEZTU3RyZWFtOiBjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuc2hhcmVkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IG9iamVjdCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgICB9XG4gICAgICAgIHNldCBvYmplY3QodmFsKSB7XG4gICAgICAgICAgdGhpcy5ub2RlID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc1JlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzV3JpdGUoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzQXBwZW5kKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsYWdzICYgMTAyNDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZmxhZ3MoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkLmZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIHNldCBmbGFncyh2YWwpIHtcbiAgICAgICAgICB0aGlzLnNoYXJlZC5mbGFncyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHNldCBwb3NpdGlvbih2YWwpIHtcbiAgICAgICAgICB0aGlzLnNoYXJlZC5wb3NpdGlvbiA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIEZTTm9kZTogY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpIHtcbiAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy5tb3VudCA9IHBhcmVudC5tb3VudDtcbiAgICAgICAgICB0aGlzLm1vdW50ZWQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgICAgdGhpcy5ub2RlX29wcyA9IHt9O1xuICAgICAgICAgIHRoaXMuc3RyZWFtX29wcyA9IHt9O1xuICAgICAgICAgIHRoaXMucmRldiA9IHJkZXY7XG4gICAgICAgICAgdGhpcy5yZWFkTW9kZSA9IDI5MiB8IDczO1xuICAgICAgICAgIHRoaXMud3JpdGVNb2RlID0gMTQ2O1xuICAgICAgICB9XG4gICAgICAgIGdldCByZWFkKCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgdGhpcy5yZWFkTW9kZSkgPT09IHRoaXMucmVhZE1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHJlYWQodmFsKSB7XG4gICAgICAgICAgdmFsID8gKHRoaXMubW9kZSB8PSB0aGlzLnJlYWRNb2RlKSA6ICh0aGlzLm1vZGUgJj0gfnRoaXMucmVhZE1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB3cml0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHRoaXMud3JpdGVNb2RlKSA9PT0gdGhpcy53cml0ZU1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHdyaXRlKHZhbCkge1xuICAgICAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gdGhpcy53cml0ZU1vZGUpIDogKHRoaXMubW9kZSAmPSB+dGhpcy53cml0ZU1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc0ZvbGRlcigpIHtcbiAgICAgICAgICByZXR1cm4gRlMuaXNEaXIodGhpcy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNEZXZpY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsb29rdXBQYXRoKHBhdGgsIG9wdHMgPSB7fSkge1xuICAgICAgICBwYXRoID0gUEFUSF9GUy5yZXNvbHZlKHBhdGgpO1xuXG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgZm9sbG93X21vdW50OiB0cnVlLFxuICAgICAgICAgIHJlY3Vyc2VfY291bnQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcblxuICAgICAgICBpZiAob3B0cy5yZWN1cnNlX2NvdW50ID4gOCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5yb290O1xuICAgICAgICB2YXIgY3VycmVudF9wYXRoID0gJy8nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gaSA9PT0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcblxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQoY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmICghaXNsYXN0IHx8IChpc2xhc3QgJiYgb3B0cy5mb2xsb3dfbW91bnQpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG5cbiAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLCB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBsb29rdXAubm9kZTtcblxuICAgICAgICAgICAgICBpZiAoY291bnQrKyA+IDQwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGF0aDogY3VycmVudF9wYXRoLCBub2RlOiBjdXJyZW50IH07XG4gICAgICB9LFxuICAgICAgZ2V0UGF0aChub2RlKSB7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnQubW91bnRwb2ludDtcbiAgICAgICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG1vdW50O1xuICAgICAgICAgICAgcmV0dXJuIG1vdW50W21vdW50Lmxlbmd0aCAtIDFdICE9PSAnLydcbiAgICAgICAgICAgICAgPyBgJHttb3VudH0vJHtwYXRofWBcbiAgICAgICAgICAgICAgOiBtb3VudCArIHBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGggPSBwYXRoID8gYCR7bm9kZS5uYW1lfS8ke3BhdGh9YCA6IG5vZGUubmFtZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXNoTmFtZShwYXJlbnRpZCwgbmFtZSkge1xuICAgICAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgaGFzaEFkZE5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBub2RlLm5hbWVfbmV4dCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZTtcbiAgICAgIH0sXG4gICAgICBoYXNoUmVtb3ZlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChGUy5uYW1lVGFibGVbaGFzaF0gPT09IG5vZGUpIHtcbiAgICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlLm5hbWVfbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubmFtZV9uZXh0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQubmFtZV9uZXh0ID0gbm9kZS5uYW1lX25leHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmFtZV9uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxvb2t1cE5vZGUocGFyZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5TG9va3VwKHBhcmVudCk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShwYXJlbnQuaWQsIG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gRlMubmFtZVRhYmxlW2hhc2hdOyBub2RlOyBub2RlID0gbm9kZS5uYW1lX25leHQpIHtcbiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50LmlkID09PSBwYXJlbnQuaWQgJiYgbm9kZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBGUy5GU05vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KTtcblxuICAgICAgICBGUy5oYXNoQWRkTm9kZShub2RlKTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95Tm9kZShub2RlKSB7XG4gICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIGlzUm9vdChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBub2RlLnBhcmVudDtcbiAgICAgIH0sXG4gICAgICBpc01vdW50cG9pbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gISFub2RlLm1vdW50ZWQ7XG4gICAgICB9LFxuICAgICAgaXNGaWxlKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAzMjc2ODtcbiAgICAgIH0sXG4gICAgICBpc0Rpcihtb2RlKSB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMTYzODQ7XG4gICAgICB9LFxuICAgICAgaXNMaW5rKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2MDtcbiAgICAgIH0sXG4gICAgICBpc0NocmRldihtb2RlKSB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gODE5MjtcbiAgICAgIH0sXG4gICAgICBpc0Jsa2Rldihtb2RlKSB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMjQ1NzY7XG4gICAgICB9LFxuICAgICAgaXNGSUZPKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2O1xuICAgICAgfSxcbiAgICAgIGlzU29ja2V0KG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNDkxNTIpID09PSA0OTE1MjtcbiAgICAgIH0sXG4gICAgICBmbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFnKSB7XG4gICAgICAgIHZhciBwZXJtcyA9IFsncicsICd3JywgJ3J3J11bZmxhZyAmIDNdO1xuICAgICAgICBpZiAoZmxhZyAmIDUxMikge1xuICAgICAgICAgIHBlcm1zICs9ICd3JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVybXM7XG4gICAgICB9LFxuICAgICAgbm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSB7XG4gICAgICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlcm1zLmluY2x1ZGVzKCdyJykgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3cnKSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgbWF5TG9va3VwKGRpcikge1xuICAgICAgICBpZiAoIUZTLmlzRGlyKGRpci5tb2RlKSkgcmV0dXJuIDU0O1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgaWYgKCFkaXIubm9kZV9vcHMubG9va3VwKSByZXR1cm4gMjtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgbWF5Q3JlYXRlKGRpciwgbmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xuICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgfSxcbiAgICAgIG1heURlbGV0ZShkaXIsIG5hbWUsIGlzZGlyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHJldHVybiBlcnJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc2Rpcikge1xuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDU0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIG1heU9wZW4obm9kZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIDQ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgaWYgKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSAhPT0gJ3InIHx8IGZsYWdzICYgNTEyKSB7XG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpKTtcbiAgICAgIH0sXG4gICAgICBNQVhfT1BFTl9GRFM6IDQwOTYsXG4gICAgICBuZXh0ZmQoKSB7XG4gICAgICAgIGZvciAodmFyIGZkID0gMDsgZmQgPD0gRlMuTUFYX09QRU5fRkRTOyBmZCsrKSB7XG4gICAgICAgICAgaWYgKCFGUy5zdHJlYW1zW2ZkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMyk7XG4gICAgICB9LFxuICAgICAgZ2V0U3RyZWFtQ2hlY2tlZChmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGdldFN0cmVhbTogKGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxcbiAgICAgIGNyZWF0ZVN0cmVhbShzdHJlYW0sIGZkID0gLTEpIHtcbiAgICAgICAgc3RyZWFtID0gT2JqZWN0LmFzc2lnbihuZXcgRlMuRlNTdHJlYW0oKSwgc3RyZWFtKTtcbiAgICAgICAgaWYgKGZkID09IC0xKSB7XG4gICAgICAgICAgZmQgPSBGUy5uZXh0ZmQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZmQgPSBmZDtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBzdHJlYW07XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgY2xvc2VTdHJlYW0oZmQpIHtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGR1cFN0cmVhbShvcmlnU3RyZWFtLCBmZCA9IC0xKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0ob3JpZ1N0cmVhbSwgZmQpO1xuICAgICAgICBzdHJlYW0uc3RyZWFtX29wcz8uZHVwPy4oc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBjaHJkZXZfc3RyZWFtX29wczoge1xuICAgICAgICBvcGVuKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBkZXZpY2UgPSBGUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7XG5cbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcyA9IGRldmljZS5zdHJlYW1fb3BzO1xuXG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3Blbj8uKHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxsc2VlaygpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgbWFqb3I6IChkZXYpID0+IGRldiA+PiA4LFxuICAgICAgbWlub3I6IChkZXYpID0+IGRldiAmIDB4ZmYsXG4gICAgICBtYWtlZGV2OiAobWEsIG1pKSA9PiAobWEgPDwgOCkgfCBtaSxcbiAgICAgIHJlZ2lzdGVyRGV2aWNlKGRldiwgb3BzKSB7XG4gICAgICAgIEZTLmRldmljZXNbZGV2XSA9IHsgc3RyZWFtX29wczogb3BzIH07XG4gICAgICB9LFxuICAgICAgZ2V0RGV2aWNlOiAoZGV2KSA9PiBGUy5kZXZpY2VzW2Rldl0sXG4gICAgICBnZXRNb3VudHMobW91bnQpIHtcbiAgICAgICAgdmFyIG1vdW50cyA9IFtdO1xuICAgICAgICB2YXIgY2hlY2sgPSBbbW91bnRdO1xuXG4gICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbSA9IGNoZWNrLnBvcCgpO1xuXG4gICAgICAgICAgbW91bnRzLnB1c2gobSk7XG5cbiAgICAgICAgICBjaGVjay5wdXNoKC4uLm0ubW91bnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3VudHM7XG4gICAgICB9LFxuICAgICAgc3luY2ZzKHBvcHVsYXRlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHBvcHVsYXRlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IHBvcHVsYXRlO1xuICAgICAgICAgIHBvcHVsYXRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuXG4gICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcbiAgICAgICAgICBlcnIoXG4gICAgICAgICAgICBgd2FybmluZzogJHtGUy5zeW5jRlNSZXF1ZXN0c30gRlMuc3luY2ZzIG9wZXJhdGlvbnMgaW4gZmxpZ2h0IGF0IG9uY2UsIHByb2JhYmx5IGp1c3QgZG9pbmcgZXh0cmEgd29ya2AsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvQ2FsbGJhY2soZXJyQ29kZSkge1xuICAgICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzLS07XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyckNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnJDb2RlKSB7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIGlmICghZG9uZS5lcnJvcmVkKSB7XG4gICAgICAgICAgICAgIGRvbmUuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBkb0NhbGxiYWNrKGVyckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytjb21wbGV0ZWQgPj0gbW91bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9DYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtb3VudHMuZm9yRWFjaCgobW91bnQpID0+IHtcbiAgICAgICAgICBpZiAoIW1vdW50LnR5cGUuc3luY2ZzKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnQudHlwZS5zeW5jZnMobW91bnQsIHBvcHVsYXRlLCBkb25lKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbW91bnQodHlwZSwgb3B0cywgbW91bnRwb2ludCkge1xuICAgICAgICB2YXIgcm9vdCA9IG1vdW50cG9pbnQgPT09ICcvJztcbiAgICAgICAgdmFyIHBzZXVkbyA9ICFtb3VudHBvaW50O1xuICAgICAgICB2YXIgbm9kZTtcblxuICAgICAgICBpZiAocm9vdCAmJiBGUy5yb290KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9IGVsc2UgaWYgKCFyb290ICYmICFwc2V1ZG8pIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG5cbiAgICAgICAgICBtb3VudHBvaW50ID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuXG4gICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VudCA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgbW91bnRwb2ludCxcbiAgICAgICAgICBtb3VudHM6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3VudFJvb3QgPSB0eXBlLm1vdW50KG1vdW50KTtcbiAgICAgICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7XG4gICAgICAgIG1vdW50LnJvb3QgPSBtb3VudFJvb3Q7XG5cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICBGUy5yb290ID0gbW91bnRSb290O1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgICBub2RlLm1vdW50ZWQgPSBtb3VudDtcblxuICAgICAgICAgIGlmIChub2RlLm1vdW50KSB7XG4gICAgICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5wdXNoKG1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW91bnRSb290O1xuICAgICAgfSxcbiAgICAgIHVubW91bnQobW91bnRwb2ludCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG5cbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudGVkO1xuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcblxuICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGhhc2gpID0+IHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcblxuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmFtZV9uZXh0O1xuXG4gICAgICAgICAgICBpZiAobW91bnRzLmluY2x1ZGVzKGN1cnJlbnQubW91bnQpKSB7XG4gICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGUubW91bnRlZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xuICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH0sXG4gICAgICBsb29rdXAocGFyZW50LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubG9va3VwKHBhcmVudCwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgbWtub2QocGF0aCwgbW9kZSwgZGV2KSB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09ICcuJyB8fCBuYW1lID09PSAnLi4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMubWtub2QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5ta25vZChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICB9LFxuICAgICAgY3JlYXRlKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0Mzg7XG4gICAgICAgIG1vZGUgJj0gNDA5NTtcbiAgICAgICAgbW9kZSB8PSAzMjc2ODtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgfSxcbiAgICAgIG1rZGlyKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA1MTE7XG4gICAgICAgIG1vZGUgJj0gNTExIHwgNTEyO1xuICAgICAgICBtb2RlIHw9IDE2Mzg0O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LFxuICAgICAgbWtkaXJUcmVlKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgdmFyIGRpcnMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIHZhciBkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICghZGlyc1tpXSkgY29udGludWU7XG4gICAgICAgICAgZCArPSAnLycgKyBkaXJzW2ldO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBGUy5ta2RpcihkLCBtb2RlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5lcnJubyAhPSAyMCkgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBta2RldihwYXRoLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZXYgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSA0Mzg7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSB8PSA4MTkyO1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sXG4gICAgICBzeW1saW5rKG9sZHBhdGgsIG5ld3BhdGgpIHtcbiAgICAgICAgaWYgKCFQQVRIX0ZTLnJlc29sdmUob2xkcGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3cGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld3BhdGgpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5ld25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5zeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCk7XG4gICAgICB9LFxuICAgICAgcmVuYW1lKG9sZF9wYXRoLCBuZXdfcGF0aCkge1xuICAgICAgICB2YXIgb2xkX2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUobmV3X3BhdGgpO1xuICAgICAgICB2YXIgb2xkX25hbWUgPSBQQVRILmJhc2VuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19uYW1lID0gUEFUSC5iYXNlbmFtZShuZXdfcGF0aCk7XG5cbiAgICAgICAgdmFyIGxvb2t1cCwgb2xkX2RpciwgbmV3X2RpcjtcblxuICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG9sZF9wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgb2xkX2RpciA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld19wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgbmV3X2RpciA9IGxvb2t1cC5ub2RlO1xuXG4gICAgICAgIGlmICghb2xkX2RpciB8fCAhbmV3X2RpcikgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuXG4gICAgICAgIGlmIChvbGRfZGlyLm1vdW50ICE9PSBuZXdfZGlyLm1vdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZF9ub2RlID0gRlMubG9va3VwTm9kZShvbGRfZGlyLCBvbGRfbmFtZSk7XG5cbiAgICAgICAgdmFyIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShvbGRfcGF0aCwgbmV3X2Rpcm5hbWUpO1xuICAgICAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUobmV3X3BhdGgsIG9sZF9kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgaWYgKG9sZF9ub2RlID09PSBuZXdfbm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc2RpciA9IEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShvbGRfZGlyLCBvbGRfbmFtZSwgaXNkaXIpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyQ29kZSA9IG5ld19ub2RlXG4gICAgICAgICAgPyBGUy5tYXlEZWxldGUobmV3X2RpciwgbmV3X25hbWUsIGlzZGlyKVxuICAgICAgICAgIDogRlMubWF5Q3JlYXRlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9sZF9kaXIubm9kZV9vcHMucmVuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBGUy5pc01vdW50cG9pbnQob2xkX25vZGUpIHx8XG4gICAgICAgICAgKG5ld19ub2RlICYmIEZTLmlzTW91bnRwb2ludChuZXdfbm9kZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdfZGlyICE9PSBvbGRfZGlyKSB7XG4gICAgICAgICAgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhvbGRfZGlyLCAndycpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShvbGRfbm9kZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZShvbGRfbm9kZSwgbmV3X2RpciwgbmV3X25hbWUpO1xuXG4gICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuaGFzaEFkZE5vZGUob2xkX25vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcm1kaXIocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnJtZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnJtZGlyKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIHJlYWRkaXIocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnJlYWRkaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMucmVhZGRpcihub2RlKTtcbiAgICAgIH0sXG4gICAgICB1bmxpbmsocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy51bmxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIHJlYWRsaW5rKHBhdGgpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCk7XG4gICAgICAgIHZhciBsaW5rID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBVEhfRlMucmVzb2x2ZShcbiAgICAgICAgICBGUy5nZXRQYXRoKGxpbmsucGFyZW50KSxcbiAgICAgICAgICBsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHN0YXQocGF0aCwgZG9udEZvbGxvdykge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIGxzdGF0KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIEZTLnN0YXQocGF0aCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgY2htb2QocGF0aCwgbW9kZSwgZG9udEZvbGxvdykge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIG1vZGU6IChtb2RlICYgNDA5NSkgfCAobm9kZS5tb2RlICYgfjQwOTUpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbGNobW9kKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmNobW9kKGZkLCBtb2RlKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtcbiAgICAgICAgRlMuY2htb2Qoc3RyZWFtLm5vZGUsIG1vZGUpO1xuICAgICAgfSxcbiAgICAgIGNob3duKHBhdGgsIHVpZCwgZ2lkLCBkb250Rm9sbG93KSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsY2hvd24ocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgRlMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZjaG93bihmZCwgdWlkLCBnaWQpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xuICAgICAgICBGUy5jaG93bihzdHJlYW0ubm9kZSwgdWlkLCBnaWQpO1xuICAgICAgfSxcbiAgICAgIHRydW5jYXRlKHBhdGgsIGxlbikge1xuICAgICAgICBpZiAobGVuIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgJ3cnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHNpemU6IGxlbixcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZ0cnVuY2F0ZShmZCwgbGVuKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtcbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy50cnVuY2F0ZShzdHJlYW0ubm9kZSwgbGVuKTtcbiAgICAgIH0sXG4gICAgICB1dGltZShwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvcGVuKHBhdGgsIGZsYWdzLCBtb2RlKSB7XG4gICAgICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyA9IHR5cGVvZiBmbGFncyA9PSAnc3RyaW5nJyA/IEZTX21vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKSA6IGZsYWdzO1xuICAgICAgICBpZiAoZmxhZ3MgJiA2NCkge1xuICAgICAgICAgIG1vZGUgPSB0eXBlb2YgbW9kZSA9PSAndW5kZWZpbmVkJyA/IDQzOCA6IG1vZGU7XG4gICAgICAgICAgbW9kZSA9IChtb2RlICYgNDA5NSkgfCAzMjc2ODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7XG4gICAgICAgICAgICAgIGZvbGxvdzogIShmbGFncyAmIDEzMTA3MiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgMTI4KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgZmxhZ3MgJj0gfjUxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIDY1NTM2ICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlPcGVuKG5vZGUsIGZsYWdzKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgNTEyICYmICFjcmVhdGVkKSB7XG4gICAgICAgICAgRlMudHJ1bmNhdGUobm9kZSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbGFncyAmPSB+KDEyOCB8IDUxMiB8IDEzMTA3Mik7XG5cbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbSh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBGUy5nZXRQYXRoKG5vZGUpLFxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIHNlZWthYmxlOiB0cnVlLFxuICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgIHN0cmVhbV9vcHM6IG5vZGUuc3RyZWFtX29wcyxcblxuICAgICAgICAgIHVuZ290dGVuOiBbXSxcbiAgICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ2xvZ1JlYWRGaWxlcyddICYmICEoZmxhZ3MgJiAxKSkge1xuICAgICAgICAgIGlmICghKHBhdGggaW4gRlMucmVhZEZpbGVzKSkge1xuICAgICAgICAgICAgRlMucmVhZEZpbGVzW3BhdGhdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBjbG9zZShzdHJlYW0pIHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmdldGRlbnRzKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5jbG9zZSkge1xuICAgICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIEZTLmNsb3NlU3RyZWFtKHN0cmVhbS5mZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmZkID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBpc0Nsb3NlZChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5mZCA9PT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBsbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnNlZWthYmxlIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoZW5jZSAhPSAwICYmIHdoZW5jZSAhPSAxICYmIHdoZW5jZSAhPSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3NpdGlvbiA9IHN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICAgc3RyZWFtLnVuZ290dGVuID0gW107XG4gICAgICAgIHJldHVybiBzdHJlYW0ucG9zaXRpb247XG4gICAgICB9LFxuICAgICAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5yZWFkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyZWFtLnNlZWthYmxlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlc1JlYWQgPSBzdHJlYW0uc3RyZWFtX29wcy5yZWFkKFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNSZWFkO1xuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgfSxcbiAgICAgIHdyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBjYW5Pd24sXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICAgIH0sXG4gICAgICBhbGxvY2F0ZShzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgbGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpICYmICFGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTM4KTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZShzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIH0sXG4gICAgICBtbWFwKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwcm90ICYgMikgIT09IDAgJiZcbiAgICAgICAgICAoZmxhZ3MgJiAyKSA9PT0gMCAmJlxuICAgICAgICAgIChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMlxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5tbWFwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tbWFwKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpO1xuICAgICAgfSxcbiAgICAgIG1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgIG1tYXBGbGFncyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBpb2N0bChzdHJlYW0sIGNtZCwgYXJnKSB7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1OSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKHN0cmVhbSwgY21kLCBhcmcpO1xuICAgICAgfSxcbiAgICAgIHJlYWRGaWxlKHBhdGgsIG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAwO1xuICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICd1dGY4JyAmJiBvcHRzLmVuY29kaW5nICE9PSAnYmluYXJ5Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbmNvZGluZyB0eXBlIFwiJHtvcHRzLmVuY29kaW5nfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7XG4gICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgcmV0ID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCA1Nzc7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MsIG9wdHMubW9kZSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxKTtcbiAgICAgICAgICB2YXIgYWN0dWFsTnVtQnl0ZXMgPSBzdHJpbmdUb1VURjhBcnJheShkYXRhLCBidWYsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgYnVmLCAwLCBhY3R1YWxOdW1CeXRlcywgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgsIHVuZGVmaW5lZCwgb3B0cy5jYW5Pd24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIH0sXG4gICAgICBjd2Q6ICgpID0+IEZTLmN1cnJlbnRQYXRoLFxuICAgICAgY2hkaXIocGF0aCkge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGxvb2t1cC5ub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNEaXIobG9va3VwLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsICd4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY3VycmVudFBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKSB7XG4gICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZScpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUvd2ViX3VzZXInKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVEZWZhdWx0RGV2aWNlcygpIHtcbiAgICAgICAgRlMubWtkaXIoJy9kZXYnKTtcblxuICAgICAgICBGUy5yZWdpc3RlckRldmljZShGUy5tYWtlZGV2KDEsIDMpLCB7XG4gICAgICAgICAgcmVhZDogKCkgPT4gMCxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiBsZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICBGUy5ta2RldignL2Rldi9udWxsJywgRlMubWFrZWRldigxLCAzKSk7XG5cbiAgICAgICAgVFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwgMCksIFRUWS5kZWZhdWx0X3R0eV9vcHMpO1xuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LCAwKSwgVFRZLmRlZmF1bHRfdHR5MV9vcHMpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHknLCBGUy5tYWtlZGV2KDUsIDApKTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvdHR5MScsIEZTLm1ha2VkZXYoNiwgMCkpO1xuXG4gICAgICAgIHZhciByYW5kb21CdWZmZXIgPSBuZXcgVWludDhBcnJheSgxMDI0KSxcbiAgICAgICAgICByYW5kb21MZWZ0ID0gMDtcbiAgICAgICAgdmFyIHJhbmRvbUJ5dGUgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHJhbmRvbUxlZnQgPT09IDApIHtcbiAgICAgICAgICAgIHJhbmRvbUxlZnQgPSByYW5kb21GaWxsKHJhbmRvbUJ1ZmZlcikuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUJ1ZmZlclstLXJhbmRvbUxlZnRdO1xuICAgICAgICB9O1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAncmFuZG9tJywgcmFuZG9tQnl0ZSk7XG4gICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICd1cmFuZG9tJywgcmFuZG9tQnl0ZSk7XG5cbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobS90bXAnKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKSB7XG4gICAgICAgIEZTLm1rZGlyKCcvcHJvYycpO1xuICAgICAgICB2YXIgcHJvY19zZWxmID0gRlMubWtkaXIoJy9wcm9jL3NlbGYnKTtcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jL3NlbGYvZmQnKTtcbiAgICAgICAgRlMubW91bnQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW91bnQoKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsICdmZCcsIDE2Mzg0IHwgNTExLCA3Myk7XG4gICAgICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7XG4gICAgICAgICAgICAgICAgbG9va3VwKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGZkID0gK25hbWU7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LFxuICAgICAgICAgICAgICAgICAgICBub2RlX29wczogeyByZWFkbGluazogKCkgPT4gc3RyZWFtLnBhdGggfSxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXQucGFyZW50ID0gcmV0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAnL3Byb2Mvc2VsZi9mZCcsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU3RhbmRhcmRTdHJlYW1zKGlucHV0LCBvdXRwdXQsIGVycm9yKSB7XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRpbicsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZGluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBvdXRwdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3Rkb3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eTEnLCAnL2Rldi9zdGRlcnInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGRpbiA9IEZTLm9wZW4oJy9kZXYvc3RkaW4nLCAwKTtcbiAgICAgICAgdmFyIHN0ZG91dCA9IEZTLm9wZW4oJy9kZXYvc3Rkb3V0JywgMSk7XG4gICAgICAgIHZhciBzdGRlcnIgPSBGUy5vcGVuKCcvZGV2L3N0ZGVycicsIDEpO1xuICAgICAgfSxcbiAgICAgIHN0YXRpY0luaXQoKSB7XG4gICAgICAgIFs0NF0uZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0gPSBuZXcgRlMuRXJybm9FcnJvcihjb2RlKTtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nO1xuICAgICAgICB9KTtcblxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XG5cbiAgICAgICAgRlMubW91bnQoTUVNRlMsIHt9LCAnLycpO1xuXG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO1xuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO1xuICAgICAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTtcblxuICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHtcbiAgICAgICAgICBNRU1GUzogTUVNRlMsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaW5pdChpbnB1dCwgb3V0cHV0LCBlcnJvcikge1xuICAgICAgICBGUy5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgaW5wdXQgPz89IE1vZHVsZVsnc3RkaW4nXTtcbiAgICAgICAgb3V0cHV0ID8/PSBNb2R1bGVbJ3N0ZG91dCddO1xuICAgICAgICBlcnJvciA/Pz0gTW9kdWxlWydzdGRlcnInXTtcblxuICAgICAgICBGUy5jcmVhdGVTdGFuZGFyZFN0cmVhbXMoaW5wdXQsIG91dHB1dCwgZXJyb3IpO1xuICAgICAgfSxcbiAgICAgIHF1aXQoKSB7XG4gICAgICAgIEZTLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07XG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmluZE9iamVjdChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKCFyZXQuZXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5vYmplY3Q7XG4gICAgICB9LFxuICAgICAgYW5hbHl6ZVBhdGgocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICBwYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgaXNSb290OiBmYWxzZSxcbiAgICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAwLFxuICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgcGF0aDogbnVsbCxcbiAgICAgICAgICBvYmplY3Q6IG51bGwsXG4gICAgICAgICAgcGFyZW50RXhpc3RzOiBmYWxzZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBudWxsLFxuICAgICAgICAgIHBhcmVudE9iamVjdDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICByZXQucGFyZW50RXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGFyZW50UGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7XG4gICAgICAgICAgcmV0LmV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgcmV0LnBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgICByZXQub2JqZWN0ID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lO1xuICAgICAgICAgIHJldC5pc1Jvb3QgPSBsb29rdXAucGF0aCA9PT0gJy8nO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0LmVycm9yID0gZS5lcnJubztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVBhdGgocGFyZW50LCBwYXRoLCBjYW5SZWFkLCBjYW5Xcml0ZSkge1xuICAgICAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpO1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykucmV2ZXJzZSgpO1xuICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gUEFUSC5qb2luMihwYXJlbnQsIHBhcnQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBGUy5ta2RpcihjdXJyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIHBhcmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKSB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihcbiAgICAgICAgICB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RlID0gRlNfZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIHJldHVybiBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGF0YUZpbGUocGFyZW50LCBuYW1lLCBkYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKSB7XG4gICAgICAgIHZhciBwYXRoID0gbmFtZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgICAgcGF0aCA9IG5hbWUgPyBQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkgOiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZGUgPSBGU19nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKVxuICAgICAgICAgICAgICBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBkYXRhID0gYXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUgfCAxNDYpO1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKG5vZGUsIDU3Nyk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCwgY2FuT3duKTtcbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGV2aWNlKHBhcmVudCwgbmFtZSwgaW5wdXQsIG91dHB1dCkge1xuICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIoXG4gICAgICAgICAgdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgICB2YXIgbW9kZSA9IEZTX2dldE1vZGUoISFpbnB1dCwgISFvdXRwdXQpO1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPz89IDY0O1xuICAgICAgICB2YXIgZGV2ID0gRlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywgMCk7XG5cbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCB7XG4gICAgICAgICAgb3BlbihzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0Py5idWZmZXI/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBvdXRwdXQoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQoYnVmZmVyW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBGUy5ta2RldihwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxcbiAgICAgIGZvcmNlTG9hZEZpbGUob2JqKSB7XG4gICAgICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cylcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9iai5jb250ZW50cyA9IHJlYWRCaW5hcnkob2JqLnVybCk7XG4gICAgICAgICAgICBvYmoudXNlZEJ5dGVzID0gb2JqLmNvbnRlbnRzLmxlbmd0aDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlYXRlTGF6eUZpbGUocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlKSB7XG4gICAgICAgIGNsYXNzIExhenlVaW50OEFycmF5IHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldChpZHgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPiB0aGlzLmxlbmd0aCAtIDEgfHwgaWR4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaWR4ICUgdGhpcy5jaHVua1NpemU7XG4gICAgICAgICAgICB2YXIgY2h1bmtOdW0gPSAoaWR4IC8gdGhpcy5jaHVua1NpemUpIHwgMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldHRlcihjaHVua051bSlbY2h1bmtPZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXREYXRhR2V0dGVyKGdldHRlcikge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhY2hlTGVuZ3RoKCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGRhdGFsZW5ndGggPSBOdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LWxlbmd0aCcpKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPVxuICAgICAgICAgICAgICAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdBY2NlcHQtUmFuZ2VzJykpICYmXG4gICAgICAgICAgICAgIGhlYWRlciA9PT0gJ2J5dGVzJztcbiAgICAgICAgICAgIHZhciB1c2VzR3ppcCA9XG4gICAgICAgICAgICAgIChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnKSkgJiZcbiAgICAgICAgICAgICAgaGVhZGVyID09PSAnZ3ppcCc7XG5cbiAgICAgICAgICAgIHZhciBjaHVua1NpemUgPSAxMDI0ICogMTAyNDtcblxuICAgICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRvWEhSID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmcm9tID4gdG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgcmFuZ2UgKCcgK1xuICAgICAgICAgICAgICAgICAgICBmcm9tICtcbiAgICAgICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIHRvICtcbiAgICAgICAgICAgICAgICAgICAgJykgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ29ubHkgJyArIGRhdGFsZW5ndGggKyAnIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciEnLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChkYXRhbGVuZ3RoICE9PSBjaHVua1NpemUpXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBmcm9tICsgJy0nICsgdG8pO1xuXG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UgfHwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGxhenlBcnJheSA9IHRoaXM7XG4gICAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcigoY2h1bmtOdW0pID0+IHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtOdW0gKiBjaHVua1NpemU7XG4gICAgICAgICAgICAgIHZhciBlbmQgPSAoY2h1bmtOdW0gKyAxKSAqIGNodW5rU2l6ZSAtIDE7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPSBkb1hIUihzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9YSFIgZmFpbGVkIScpO1xuICAgICAgICAgICAgICByZXR1cm4gbGF6eUFycmF5LmNodW5rc1tjaHVua051bV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHVzZXNHemlwIHx8ICFkYXRhbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGggPSAxO1xuICAgICAgICAgICAgICBkYXRhbGVuZ3RoID0gdGhpcy5nZXR0ZXIoMCkubGVuZ3RoO1xuICAgICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgICAgICBvdXQoXG4gICAgICAgICAgICAgICAgJ0xhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZCcsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXQgY2h1bmtTaXplKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1NpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghRU5WSVJPTk1FTlRfSVNfV09SS0VSKVxuICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MnO1xuICAgICAgICAgIHZhciBsYXp5QXJyYXkgPSBuZXcgTGF6eVVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKTtcblxuICAgICAgICBpZiAocHJvcGVydGllcy5jb250ZW50cykge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIHtcbiAgICAgICAgICB1c2VkQnl0ZXM6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTtcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmbiguLi5hcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDaHVua3Moc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oY29udGVudHMubGVuZ3RoIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKGNvbnRlbnRzLnNsaWNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50cy5nZXQocG9zaXRpb24gKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW1fb3BzLnJlYWQgPSAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmVhbV9vcHMubW1hcCA9IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICB2YXIgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JpdGVDaHVua3Moc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm4geyBwdHIsIGFsbG9jYXRlZDogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBzdHJlYW1fb3BzO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciBVVEY4VG9TdHJpbmcgPSAocHRyLCBtYXhCeXRlc1RvUmVhZCkgPT4ge1xuICAgICAgcmV0dXJuIHB0ciA/IFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiAnJztcbiAgICB9O1xuICAgIHZhciBTWVNDQUxMUyA9IHtcbiAgICAgIERFRkFVTFRfUE9MTE1BU0s6IDUsXG4gICAgICBjYWxjdWxhdGVBdChkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSkge1xuICAgICAgICBpZiAoUEFUSC5pc0FicyhwYXRoKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChkaXJmZCk7XG4gICAgICAgICAgZGlyID0gZGlyc3RyZWFtLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSC5qb2luMihkaXIsIHBhdGgpO1xuICAgICAgfSxcbiAgICAgIGRvU3RhdChmdW5jLCBwYXRoLCBidWYpIHtcbiAgICAgICAgdmFyIHN0YXQgPSBmdW5jKHBhdGgpO1xuICAgICAgICBIRUFQMzJbYnVmID4+IDJdID0gc3RhdC5kZXY7XG4gICAgICAgIEhFQVAzMlsoYnVmICsgNCkgPj4gMl0gPSBzdGF0Lm1vZGU7XG4gICAgICAgIEhFQVBVMzJbKGJ1ZiArIDgpID4+IDJdID0gc3RhdC5ubGluaztcbiAgICAgICAgSEVBUDMyWyhidWYgKyAxMikgPj4gMl0gPSBzdGF0LnVpZDtcbiAgICAgICAgSEVBUDMyWyhidWYgKyAxNikgPj4gMl0gPSBzdGF0LmdpZDtcbiAgICAgICAgSEVBUDMyWyhidWYgKyAyMCkgPj4gMl0gPSBzdGF0LnJkZXY7XG4gICAgICAgIEhFQVA2NFsoYnVmICsgMjQpID4+IDNdID0gQmlnSW50KHN0YXQuc2l6ZSk7XG4gICAgICAgIEhFQVAzMlsoYnVmICsgMzIpID4+IDJdID0gNDA5NjtcbiAgICAgICAgSEVBUDMyWyhidWYgKyAzNikgPj4gMl0gPSBzdGF0LmJsb2NrcztcbiAgICAgICAgdmFyIGF0aW1lID0gc3RhdC5hdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBtdGltZSA9IHN0YXQubXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgY3RpbWUgPSBzdGF0LmN0aW1lLmdldFRpbWUoKTtcbiAgICAgICAgSEVBUDY0WyhidWYgKyA0MCkgPj4gM10gPSBCaWdJbnQoTWF0aC5mbG9vcihhdGltZSAvIDEwMDApKTtcbiAgICAgICAgSEVBUFUzMlsoYnVmICsgNDgpID4+IDJdID0gKGF0aW1lICUgMTAwMCkgKiAxMDAwICogMTAwMDtcbiAgICAgICAgSEVBUDY0WyhidWYgKyA1NikgPj4gM10gPSBCaWdJbnQoTWF0aC5mbG9vcihtdGltZSAvIDEwMDApKTtcbiAgICAgICAgSEVBUFUzMlsoYnVmICsgNjQpID4+IDJdID0gKG10aW1lICUgMTAwMCkgKiAxMDAwICogMTAwMDtcbiAgICAgICAgSEVBUDY0WyhidWYgKyA3MikgPj4gM10gPSBCaWdJbnQoTWF0aC5mbG9vcihjdGltZSAvIDEwMDApKTtcbiAgICAgICAgSEVBUFUzMlsoYnVmICsgODApID4+IDJdID0gKGN0aW1lICUgMTAwMCkgKiAxMDAwICogMTAwMDtcbiAgICAgICAgSEVBUDY0WyhidWYgKyA4OCkgPj4gM10gPSBCaWdJbnQoc3RhdC5pbm8pO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBkb01zeW5jKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KSB7XG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gSEVBUFU4LnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xuICAgICAgICBGUy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW4sIGZsYWdzKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdHJlYW1Gcm9tRkQoZmQpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHZhcmFyZ3M6IHVuZGVmaW5lZCxcbiAgICAgIGdldFN0cihwdHIpIHtcbiAgICAgICAgdmFyIHJldCA9IFVURjhUb1N0cmluZyhwdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfY2htb2QocGF0aCwgbW9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGFtb2RlICYgfjcpIHtcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gLTQ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJtcyA9ICcnO1xuICAgICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7XG4gICAgICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnO1xuICAgICAgICBpZiAocGVybXMgJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNobW9kKGZkLCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBGUy5mY2htb2QoZmQsIG1vZGUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNob3duMzIoZmQsIG93bmVyLCBncm91cCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgRlMuZmNob3duKGZkLCBvd25lciwgZ3JvdXApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN5c2NhbGxHZXRWYXJhcmdJKCkge1xuICAgICAgdmFyIHJldCA9IEhFQVAzMlsrU1lTQ0FMTFMudmFyYXJncyA+PiAyXTtcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHZhciBzeXNjYWxsR2V0VmFyYXJnUCA9IHN5c2NhbGxHZXRWYXJhcmdJO1xuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9mY250bDY0KGZkLCBjbWQsIHZhcmFyZ3MpIHtcbiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICB2YXIgYXJnID0gc3lzY2FsbEdldFZhcmFyZ0koKTtcbiAgICAgICAgICAgIGlmIChhcmcgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoRlMuc3RyZWFtc1thcmddKSB7XG4gICAgICAgICAgICAgIGFyZysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1N0cmVhbTtcbiAgICAgICAgICAgIG5ld1N0cmVhbSA9IEZTLmR1cFN0cmVhbShzdHJlYW0sIGFyZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RyZWFtLmZkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5mbGFncztcbiAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBzeXNjYWxsR2V0VmFyYXJnSSgpO1xuICAgICAgICAgICAgc3RyZWFtLmZsYWdzIHw9IGFyZztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEyOiB7XG4gICAgICAgICAgICB2YXIgYXJnID0gc3lzY2FsbEdldFZhcmFyZ1AoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBIRUFQMTZbKGFyZyArIG9mZnNldCkgPj4gMV0gPSAyO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMjg7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMuc3RhdCwgc3RyZWFtLnBhdGgsIGJ1Zik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgSU5UNTNfTUFYID0gOTAwNzE5OTI1NDc0MDk5MjtcblxuICAgIHZhciBJTlQ1M19NSU4gPSAtOTAwNzE5OTI1NDc0MDk5MjtcbiAgICB2YXIgYmlnaW50VG9JNTNDaGVja2VkID0gKG51bSkgPT5cbiAgICAgIG51bSA8IElOVDUzX01JTiB8fCBudW0gPiBJTlQ1M19NQVggPyBOYU4gOiBOdW1iZXIobnVtKTtcbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2Z0cnVuY2F0ZTY0KGZkLCBsZW5ndGgpIHtcbiAgICAgIGxlbmd0aCA9IGJpZ2ludFRvSTUzQ2hlY2tlZChsZW5ndGgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkgcmV0dXJuIDYxO1xuICAgICAgICBGUy5mdHJ1bmNhdGUoZmQsIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZ1RvVVRGOCA9IChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSA9PiB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0Y3dkKGJ1Ziwgc2l6ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHJldHVybiAtMjg7XG4gICAgICAgIHZhciBjd2QgPSBGUy5jd2QoKTtcbiAgICAgICAgdmFyIGN3ZExlbmd0aEluQnl0ZXMgPSBsZW5ndGhCeXRlc1VURjgoY3dkKSArIDE7XG4gICAgICAgIGlmIChzaXplIDwgY3dkTGVuZ3RoSW5CeXRlcykgcmV0dXJuIC02ODtcbiAgICAgICAgc3RyaW5nVG9VVEY4KGN3ZCwgYnVmLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIGN3ZExlbmd0aEluQnl0ZXM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2lvY3RsKGZkLCBvcCwgdmFyYXJncykge1xuICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgIGNhc2UgMjE1MDk6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTA1OiB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLnR0eS5vcHMuaW9jdGxfdGNnZXRzKSB7XG4gICAgICAgICAgICAgIHZhciB0ZXJtaW9zID0gc3RyZWFtLnR0eS5vcHMuaW9jdGxfdGNnZXRzKHN0cmVhbSk7XG4gICAgICAgICAgICAgIHZhciBhcmdwID0gc3lzY2FsbEdldFZhcmFyZ1AoKTtcbiAgICAgICAgICAgICAgSEVBUDMyW2FyZ3AgPj4gMl0gPSB0ZXJtaW9zLmNfaWZsYWcgfHwgMDtcbiAgICAgICAgICAgICAgSEVBUDMyWyhhcmdwICsgNCkgPj4gMl0gPSB0ZXJtaW9zLmNfb2ZsYWcgfHwgMDtcbiAgICAgICAgICAgICAgSEVBUDMyWyhhcmdwICsgOCkgPj4gMl0gPSB0ZXJtaW9zLmNfY2ZsYWcgfHwgMDtcbiAgICAgICAgICAgICAgSEVBUDMyWyhhcmdwICsgMTIpID4+IDJdID0gdGVybWlvcy5jX2xmbGFnIHx8IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgICAgIEhFQVA4W2FyZ3AgKyBpICsgMTddID0gdGVybWlvcy5jX2NjW2ldIHx8IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUxMDpcbiAgICAgICAgICBjYXNlIDIxNTExOlxuICAgICAgICAgIGNhc2UgMjE1MTI6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTA2OlxuICAgICAgICAgIGNhc2UgMjE1MDc6XG4gICAgICAgICAgY2FzZSAyMTUwODoge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgaWYgKHN0cmVhbS50dHkub3BzLmlvY3RsX3Rjc2V0cykge1xuICAgICAgICAgICAgICB2YXIgYXJncCA9IHN5c2NhbGxHZXRWYXJhcmdQKCk7XG4gICAgICAgICAgICAgIHZhciBjX2lmbGFnID0gSEVBUDMyW2FyZ3AgPj4gMl07XG4gICAgICAgICAgICAgIHZhciBjX29mbGFnID0gSEVBUDMyWyhhcmdwICsgNCkgPj4gMl07XG4gICAgICAgICAgICAgIHZhciBjX2NmbGFnID0gSEVBUDMyWyhhcmdwICsgOCkgPj4gMl07XG4gICAgICAgICAgICAgIHZhciBjX2xmbGFnID0gSEVBUDMyWyhhcmdwICsgMTIpID4+IDJdO1xuICAgICAgICAgICAgICB2YXIgY19jYyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjX2NjLnB1c2goSEVBUDhbYXJncCArIGkgKyAxN10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzdHJlYW0udHR5Lm9wcy5pb2N0bF90Y3NldHMoc3RyZWFtLnR0eSwgb3AsIHtcbiAgICAgICAgICAgICAgICBjX2lmbGFnLFxuICAgICAgICAgICAgICAgIGNfb2ZsYWcsXG4gICAgICAgICAgICAgICAgY19jZmxhZyxcbiAgICAgICAgICAgICAgICBjX2xmbGFnLFxuICAgICAgICAgICAgICAgIGNfY2MsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MTk6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIHZhciBhcmdwID0gc3lzY2FsbEdldFZhcmFyZ1AoKTtcbiAgICAgICAgICAgIEhFQVAzMlthcmdwID4+IDJdID0gMDtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTIwOiB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTMxOiB7XG4gICAgICAgICAgICB2YXIgYXJncCA9IHN5c2NhbGxHZXRWYXJhcmdQKCk7XG4gICAgICAgICAgICByZXR1cm4gRlMuaW9jdGwoc3RyZWFtLCBvcCwgYXJncCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjE1MjM6IHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0udHR5Lm9wcy5pb2N0bF90aW9jZ3dpbnN6KSB7XG4gICAgICAgICAgICAgIHZhciB3aW5zaXplID0gc3RyZWFtLnR0eS5vcHMuaW9jdGxfdGlvY2d3aW5zeihzdHJlYW0udHR5KTtcbiAgICAgICAgICAgICAgdmFyIGFyZ3AgPSBzeXNjYWxsR2V0VmFyYXJnUCgpO1xuICAgICAgICAgICAgICBIRUFQMTZbYXJncCA+PiAxXSA9IHdpbnNpemVbMF07XG4gICAgICAgICAgICAgIEhFQVAxNlsoYXJncCArIDIpID4+IDFdID0gd2luc2l6ZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIxNTI0OiB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMTUxNToge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX2xzdGF0NjQocGF0aCwgYnVmKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLmxzdGF0LCBwYXRoLCBidWYpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9ta2RpcmF0KGRpcmZkLCBwYXRoLCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuXG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nKVxuICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICBGUy5ta2RpcihwYXRoLCBtb2RlLCAwKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX25ld2ZzdGF0YXQoZGlyZmQsIHBhdGgsIGJ1ZiwgZmxhZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICAgIHZhciBub2ZvbGxvdyA9IGZsYWdzICYgMjU2O1xuICAgICAgICB2YXIgYWxsb3dFbXB0eSA9IGZsYWdzICYgNDA5NjtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyAmIH42NDAwO1xuICAgICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpO1xuICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KG5vZm9sbG93ID8gRlMubHN0YXQgOiBGUy5zdGF0LCBwYXRoLCBidWYpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF9vcGVuYXQoZGlyZmQsIHBhdGgsIGZsYWdzLCB2YXJhcmdzKSB7XG4gICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICAgIHZhciBtb2RlID0gdmFyYXJncyA/IHN5c2NhbGxHZXRWYXJhcmdJKCkgOiAwO1xuICAgICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgbW9kZSkuZmQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX3JlYWRsaW5rYXQoZGlyZmQsIHBhdGgsIGJ1ZiwgYnVmc2l6ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgICAgaWYgKGJ1ZnNpemUgPD0gMCkgcmV0dXJuIC0yODtcbiAgICAgICAgdmFyIHJldCA9IEZTLnJlYWRsaW5rKHBhdGgpO1xuXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihidWZzaXplLCBsZW5ndGhCeXRlc1VURjgocmV0KSk7XG4gICAgICAgIHZhciBlbmRDaGFyID0gSEVBUDhbYnVmICsgbGVuXTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHJldCwgYnVmLCBidWZzaXplICsgMSk7XG5cbiAgICAgICAgSEVBUDhbYnVmICsgbGVuXSA9IGVuZENoYXI7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX19zeXNjYWxsX3JtZGlyKHBhdGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICAgIEZTLnJtZGlyKHBhdGgpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIC1lLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGxfc3RhdDY0KHBhdGgsIGJ1Zikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBwYXRoLCBidWYpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF91bmxpbmthdChkaXJmZCwgcGF0aCwgZmxhZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICAgIGlmIChmbGFncyA9PT0gMCkge1xuICAgICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncyA9PT0gNTEyKSB7XG4gICAgICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWJvcnQoJ0ludmFsaWQgZmxhZ3MgcGFzc2VkIHRvIHVubGlua2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhZEk1M0Zyb21JNjQgPSAocHRyKSA9PiB7XG4gICAgICByZXR1cm4gSEVBUFUzMltwdHIgPj4gMl0gKyBIRUFQMzJbKHB0ciArIDQpID4+IDJdICogNDI5NDk2NzI5NjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX19fc3lzY2FsbF91dGltZW5zYXQoZGlyZmQsIHBhdGgsIHRpbWVzLCBmbGFncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCB0cnVlKTtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgYXRpbWUsXG4gICAgICAgICAgbXRpbWU7XG4gICAgICAgIGlmICghdGltZXMpIHtcbiAgICAgICAgICBhdGltZSA9IG5vdztcbiAgICAgICAgICBtdGltZSA9IG5vdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2Vjb25kcyA9IHJlYWRJNTNGcm9tSTY0KHRpbWVzKTtcbiAgICAgICAgICB2YXIgbmFub3NlY29uZHMgPSBIRUFQMzJbKHRpbWVzICsgOCkgPj4gMl07XG4gICAgICAgICAgaWYgKG5hbm9zZWNvbmRzID09IDEwNzM3NDE4MjMpIHtcbiAgICAgICAgICAgIGF0aW1lID0gbm93O1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFub3NlY29uZHMgPT0gMTA3Mzc0MTgyMikge1xuICAgICAgICAgICAgYXRpbWUgPSAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXRpbWUgPSBzZWNvbmRzICogMTAwMCArIG5hbm9zZWNvbmRzIC8gKDEwMDAgKiAxMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltZXMgKz0gMTY7XG4gICAgICAgICAgc2Vjb25kcyA9IHJlYWRJNTNGcm9tSTY0KHRpbWVzKTtcbiAgICAgICAgICBuYW5vc2Vjb25kcyA9IEhFQVAzMlsodGltZXMgKyA4KSA+PiAyXTtcbiAgICAgICAgICBpZiAobmFub3NlY29uZHMgPT0gMTA3Mzc0MTgyMykge1xuICAgICAgICAgICAgbXRpbWUgPSBub3c7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW5vc2Vjb25kcyA9PSAxMDczNzQxODIyKSB7XG4gICAgICAgICAgICBtdGltZSA9IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdGltZSA9IHNlY29uZHMgKiAxMDAwICsgbmFub3NlY29uZHMgLyAoMTAwMCAqIDEwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtdGltZSAhPSAtMSB8fCBhdGltZSAhPSAtMSkge1xuICAgICAgICAgIEZTLnV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiAtZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm93SXNNb25vdG9uaWMgPSAxO1xuICAgIHZhciBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMgPSAoKSA9PiBub3dJc01vbm90b25pYztcblxuICAgIHZhciBpc0xlYXBZZWFyID0gKHllYXIpID0+XG4gICAgICB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcblxuICAgIHZhciBNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA9IFtcbiAgICAgIDAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1LFxuICAgIF07XG5cbiAgICB2YXIgTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUgPSBbXG4gICAgICAwLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCxcbiAgICBdO1xuICAgIHZhciB5ZGF5RnJvbURhdGUgPSAoZGF0ZSkgPT4ge1xuICAgICAgdmFyIGxlYXAgPSBpc0xlYXBZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICB2YXIgbW9udGhEYXlzQ3VtdWxhdGl2ZSA9IGxlYXBcbiAgICAgICAgPyBNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVxuICAgICAgICA6IE1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFO1xuICAgICAgdmFyIHlkYXkgPSBtb250aERheXNDdW11bGF0aXZlW2RhdGUuZ2V0TW9udGgoKV0gKyBkYXRlLmdldERhdGUoKSAtIDE7XG5cbiAgICAgIHJldHVybiB5ZGF5O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfX2xvY2FsdGltZV9qcyh0aW1lLCB0bVB0cikge1xuICAgICAgdGltZSA9IGJpZ2ludFRvSTUzQ2hlY2tlZCh0aW1lKTtcblxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gICAgICBIRUFQMzJbdG1QdHIgPj4gMl0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyA0KSA+PiAyXSA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDgpID4+IDJdID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDEyKSA+PiAyXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDE2KSA+PiAyXSA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAyMCkgPj4gMl0gPSBkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTAwO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDI0KSA+PiAyXSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgIHZhciB5ZGF5ID0geWRheUZyb21EYXRlKGRhdGUpIHwgMDtcbiAgICAgIEhFQVAzMlsodG1QdHIgKyAyOCkgPj4gMl0gPSB5ZGF5O1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDM2KSA+PiAyXSA9IC0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjApO1xuXG4gICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIGRzdCA9XG4gICAgICAgIChzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmXG4gICAgICAgICAgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KSkgfCAwO1xuICAgICAgSEVBUDMyWyh0bVB0ciArIDMyKSA+PiAyXSA9IGRzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX21tYXBfanMobGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCwgYWxsb2NhdGVkLCBhZGRyKSB7XG4gICAgICBvZmZzZXQgPSBiaWdpbnRUb0k1M0NoZWNrZWQob2Zmc2V0KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHJldHVybiA2MTtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHZhciByZXMgPSBGUy5tbWFwKHN0cmVhbSwgbGVuLCBvZmZzZXQsIHByb3QsIGZsYWdzKTtcbiAgICAgICAgdmFyIHB0ciA9IHJlcy5wdHI7XG4gICAgICAgIEhFQVAzMlthbGxvY2F0ZWQgPj4gMl0gPSByZXMuYWxsb2NhdGVkO1xuICAgICAgICBIRUFQVTMyW2FkZHIgPj4gMl0gPSBwdHI7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19tdW5tYXBfanMoYWRkciwgbGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG9mZnNldCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgICBpZiAocHJvdCAmIDIpIHtcbiAgICAgICAgICBTWVNDQUxMUy5kb01zeW5jKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gLWUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9fdHpzZXRfanMgPSAodGltZXpvbmUsIGRheWxpZ2h0LCBzdGRfbmFtZSwgZHN0X25hbWUpID0+IHtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7XG5cbiAgICAgIEhFQVBVMzJbdGltZXpvbmUgPj4gMl0gPSBzdGRUaW1lem9uZU9mZnNldCAqIDYwO1xuXG4gICAgICBIRUFQMzJbZGF5bGlnaHQgPj4gMl0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG5cbiAgICAgIHZhciBleHRyYWN0Wm9uZSA9ICh0aW1lem9uZU9mZnNldCkgPT4ge1xuICAgICAgICB2YXIgc2lnbiA9IHRpbWV6b25lT2Zmc2V0ID49IDAgPyAnLScgOiAnKyc7XG5cbiAgICAgICAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgICAgdmFyIGhvdXJzID0gU3RyaW5nKE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB2YXIgbWludXRlcyA9IFN0cmluZyhhYnNPZmZzZXQgJSA2MCkucGFkU3RhcnQoMiwgJzAnKTtcblxuICAgICAgICByZXR1cm4gYFVUQyR7c2lnbn0ke2hvdXJzfSR7bWludXRlc31gO1xuICAgICAgfTtcblxuICAgICAgdmFyIHdpbnRlck5hbWUgPSBleHRyYWN0Wm9uZSh3aW50ZXJPZmZzZXQpO1xuICAgICAgdmFyIHN1bW1lck5hbWUgPSBleHRyYWN0Wm9uZShzdW1tZXJPZmZzZXQpO1xuICAgICAgaWYgKHN1bW1lck9mZnNldCA8IHdpbnRlck9mZnNldCkge1xuICAgICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgc3RkX25hbWUsIDE3KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN1bW1lck5hbWUsIGRzdF9uYW1lLCAxNyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmdUb1VURjgod2ludGVyTmFtZSwgZHN0X25hbWUsIDE3KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN1bW1lck5hbWUsIHN0ZF9uYW1lLCAxNyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfZW1zY3JpcHRlbl9kYXRlX25vdyA9ICgpID0+IERhdGUubm93KCk7XG5cbiAgICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgdmFyIGdldEhlYXBNYXggPSAoKSA9PiAyMTQ3NDgzNjQ4O1xuXG4gICAgdmFyIGdyb3dNZW1vcnkgPSAoc2l6ZSkgPT4ge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIHZhciBwYWdlcyA9ICgoc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1KSAvIDY1NTM2KSB8IDA7XG4gICAgICB0cnkge1xuICAgICAgICB3YXNtTWVtb3J5Lmdyb3cocGFnZXMpO1xuICAgICAgICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfTtcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAgPSAocmVxdWVzdGVkU2l6ZSkgPT4ge1xuICAgICAgdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuXG4gICAgICByZXF1ZXN0ZWRTaXplID4+Pj0gMDtcblxuICAgICAgdmFyIG1heEhlYXBTaXplID0gZ2V0SGVhcE1heCgpO1xuICAgICAgaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGN1dERvd24gPSAxOyBjdXREb3duIDw9IDQ7IGN1dERvd24gKj0gMikge1xuICAgICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTtcblxuICAgICAgICBvdmVyR3Jvd25IZWFwU2l6ZSA9IE1hdGgubWluKFxuICAgICAgICAgIG92ZXJHcm93bkhlYXBTaXplLFxuICAgICAgICAgIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYsXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG5ld1NpemUgPSBNYXRoLm1pbihcbiAgICAgICAgICBtYXhIZWFwU2l6ZSxcbiAgICAgICAgICBhbGlnbk1lbW9yeShNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KSxcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBncm93TWVtb3J5KG5ld1NpemUpO1xuICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgRU5WID0ge307XG5cbiAgICB2YXIgZ2V0RXhlY3V0YWJsZU5hbWUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgICB9O1xuICAgIHZhciBnZXRFbnZTdHJpbmdzID0gKCkgPT4ge1xuICAgICAgaWYgKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3MpIHtcbiAgICAgICAgdmFyIGxhbmcgPVxuICAgICAgICAgIChcbiAgICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIG5hdmlnYXRvci5sYW5ndWFnZXMgJiZcbiAgICAgICAgICAgICAgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSkgfHxcbiAgICAgICAgICAgICdDJ1xuICAgICAgICAgICkucmVwbGFjZSgnLScsICdfJykgKyAnLlVURi04JztcbiAgICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgICBVU0VSOiAnd2ViX3VzZXInLFxuICAgICAgICAgIExPR05BTUU6ICd3ZWJfdXNlcicsXG4gICAgICAgICAgUEFUSDogJy8nLFxuICAgICAgICAgIFBXRDogJy8nLFxuICAgICAgICAgIEhPTUU6ICcvaG9tZS93ZWJfdXNlcicsXG4gICAgICAgICAgTEFORzogbGFuZyxcbiAgICAgICAgICBfOiBnZXRFeGVjdXRhYmxlTmFtZSgpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHggaW4gRU5WKSB7XG4gICAgICAgICAgaWYgKEVOVlt4XSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgZW52W3hdO1xuICAgICAgICAgIGVsc2UgZW52W3hdID0gRU5WW3hdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIHggaW4gZW52KSB7XG4gICAgICAgICAgc3RyaW5ncy5wdXNoKGAke3h9PSR7ZW52W3hdfWApO1xuICAgICAgICB9XG4gICAgICAgIGdldEVudlN0cmluZ3Muc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzO1xuICAgIH07XG5cbiAgICB2YXIgc3RyaW5nVG9Bc2NpaSA9IChzdHIsIGJ1ZmZlcikgPT4ge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgSEVBUDhbYnVmZmVyKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIEhFQVA4W2J1ZmZlcl0gPSAwO1xuICAgIH07XG4gICAgdmFyIF9lbnZpcm9uX2dldCA9IChfX2Vudmlyb24sIGVudmlyb25fYnVmKSA9PiB7XG4gICAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgICBnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaCgoc3RyaW5nLCBpKSA9PiB7XG4gICAgICAgIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gICAgICAgIEhFQVBVMzJbKF9fZW52aXJvbiArIGkgKiA0KSA+PiAyXSA9IHB0cjtcbiAgICAgICAgc3RyaW5nVG9Bc2NpaShzdHJpbmcsIHB0cik7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICB2YXIgX2Vudmlyb25fc2l6ZXNfZ2V0ID0gKHBlbnZpcm9uX2NvdW50LCBwZW52aXJvbl9idWZfc2l6ZSkgPT4ge1xuICAgICAgdmFyIHN0cmluZ3MgPSBnZXRFbnZTdHJpbmdzKCk7XG4gICAgICBIRUFQVTMyW3BlbnZpcm9uX2NvdW50ID4+IDJdID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgICBzdHJpbmdzLmZvckVhY2goKHN0cmluZykgPT4gKGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDEpKTtcbiAgICAgIEhFQVBVMzJbcGVudmlyb25fYnVmX3NpemUgPj4gMl0gPSBidWZTaXplO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCwgcGJ1Zikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJpZ2h0c0Jhc2UgPSAwO1xuICAgICAgICB2YXIgcmlnaHRzSW5oZXJpdGluZyA9IDA7XG4gICAgICAgIHZhciBmbGFncyA9IDA7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcblxuICAgICAgICAgIHZhciB0eXBlID0gc3RyZWFtLnR0eVxuICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICA6IEZTLmlzRGlyKHN0cmVhbS5tb2RlKVxuICAgICAgICAgICAgICA/IDNcbiAgICAgICAgICAgICAgOiBGUy5pc0xpbmsoc3RyZWFtLm1vZGUpXG4gICAgICAgICAgICAgICAgPyA3XG4gICAgICAgICAgICAgICAgOiA0O1xuICAgICAgICB9XG4gICAgICAgIEhFQVA4W3BidWZdID0gdHlwZTtcbiAgICAgICAgSEVBUDE2WyhwYnVmICsgMikgPj4gMV0gPSBmbGFncztcbiAgICAgICAgSEVBUDY0WyhwYnVmICsgOCkgPj4gM10gPSBCaWdJbnQocmlnaHRzQmFzZSk7XG4gICAgICAgIEhFQVA2NFsocGJ1ZiArIDE2KSA+PiAzXSA9IEJpZ0ludChyaWdodHNJbmhlcml0aW5nKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb1JlYWR2ID0gKHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkgPT4ge1xuICAgICAgdmFyIHJldCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgIHZhciBwdHIgPSBIRUFQVTMyW2lvdiA+PiAyXTtcbiAgICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKGlvdiArIDQpID4+IDJdO1xuICAgICAgICBpb3YgKz0gODtcbiAgICAgICAgdmFyIGN1cnIgPSBGUy5yZWFkKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmIChjdXJyIDwgbGVuKSBicmVhaztcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gY3VycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2ZkX3JlYWQoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgdmFyIG51bSA9IGRvUmVhZHYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICAgIEhFQVBVMzJbcG51bSA+PiAyXSA9IG51bTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF9zZWVrKGZkLCBvZmZzZXQsIHdoZW5jZSwgbmV3T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBiaWdpbnRUb0k1M0NoZWNrZWQob2Zmc2V0KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHJldHVybiA2MTtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIEZTLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICAgSEVBUDY0W25ld09mZnNldCA+PiAzXSA9IEJpZ0ludChzdHJlYW0ucG9zaXRpb24pO1xuICAgICAgICBpZiAoc3RyZWFtLmdldGRlbnRzICYmIG9mZnNldCA9PT0gMCAmJiB3aGVuY2UgPT09IDApXG4gICAgICAgICAgc3RyZWFtLmdldGRlbnRzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlLm5hbWUgPT09ICdFcnJub0Vycm9yJykpIHRocm93IGU7XG4gICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mZF9zeW5jKGZkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzPy5mc3luYykge1xuICAgICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5mc3luYyhzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZS5uYW1lID09PSAnRXJybm9FcnJvcicpKSB0aHJvdyBlO1xuICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9Xcml0ZXYgPSAoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSA9PiB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+IDJdO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoaW92ICsgNCkgPj4gMl07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLndyaXRlKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmIChjdXJyIDwgbGVuKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gY3VycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICAgIHZhciBudW0gPSBkb1dyaXRldihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICAgICAgSEVBUFUzMltwbnVtID4+IDJdID0gbnVtO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUubmFtZSA9PT0gJ0Vycm5vRXJyb3InKSkgdGhyb3cgZTtcbiAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgRlMuY3JlYXRlUHJlbG9hZGVkRmlsZSA9IEZTX2NyZWF0ZVByZWxvYWRlZEZpbGU7XG4gICAgRlMuc3RhdGljSW5pdCgpO1xuXG4gICAgdmFyIHdhc21JbXBvcnRzID0ge1xuICAgICAgX19zeXNjYWxsX2NobW9kOiBfX19zeXNjYWxsX2NobW9kLFxuXG4gICAgICBfX3N5c2NhbGxfZmFjY2Vzc2F0OiBfX19zeXNjYWxsX2ZhY2Nlc3NhdCxcblxuICAgICAgX19zeXNjYWxsX2ZjaG1vZDogX19fc3lzY2FsbF9mY2htb2QsXG5cbiAgICAgIF9fc3lzY2FsbF9mY2hvd24zMjogX19fc3lzY2FsbF9mY2hvd24zMixcblxuICAgICAgX19zeXNjYWxsX2ZjbnRsNjQ6IF9fX3N5c2NhbGxfZmNudGw2NCxcblxuICAgICAgX19zeXNjYWxsX2ZzdGF0NjQ6IF9fX3N5c2NhbGxfZnN0YXQ2NCxcblxuICAgICAgX19zeXNjYWxsX2Z0cnVuY2F0ZTY0OiBfX19zeXNjYWxsX2Z0cnVuY2F0ZTY0LFxuXG4gICAgICBfX3N5c2NhbGxfZ2V0Y3dkOiBfX19zeXNjYWxsX2dldGN3ZCxcblxuICAgICAgX19zeXNjYWxsX2lvY3RsOiBfX19zeXNjYWxsX2lvY3RsLFxuXG4gICAgICBfX3N5c2NhbGxfbHN0YXQ2NDogX19fc3lzY2FsbF9sc3RhdDY0LFxuXG4gICAgICBfX3N5c2NhbGxfbWtkaXJhdDogX19fc3lzY2FsbF9ta2RpcmF0LFxuXG4gICAgICBfX3N5c2NhbGxfbmV3ZnN0YXRhdDogX19fc3lzY2FsbF9uZXdmc3RhdGF0LFxuXG4gICAgICBfX3N5c2NhbGxfb3BlbmF0OiBfX19zeXNjYWxsX29wZW5hdCxcblxuICAgICAgX19zeXNjYWxsX3JlYWRsaW5rYXQ6IF9fX3N5c2NhbGxfcmVhZGxpbmthdCxcblxuICAgICAgX19zeXNjYWxsX3JtZGlyOiBfX19zeXNjYWxsX3JtZGlyLFxuXG4gICAgICBfX3N5c2NhbGxfc3RhdDY0OiBfX19zeXNjYWxsX3N0YXQ2NCxcblxuICAgICAgX19zeXNjYWxsX3VubGlua2F0OiBfX19zeXNjYWxsX3VubGlua2F0LFxuXG4gICAgICBfX3N5c2NhbGxfdXRpbWVuc2F0OiBfX19zeXNjYWxsX3V0aW1lbnNhdCxcblxuICAgICAgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWM6IF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyxcblxuICAgICAgX2xvY2FsdGltZV9qczogX19sb2NhbHRpbWVfanMsXG5cbiAgICAgIF9tbWFwX2pzOiBfX21tYXBfanMsXG5cbiAgICAgIF9tdW5tYXBfanM6IF9fbXVubWFwX2pzLFxuXG4gICAgICBfdHpzZXRfanM6IF9fdHpzZXRfanMsXG5cbiAgICAgIGVtc2NyaXB0ZW5fZGF0ZV9ub3c6IF9lbXNjcmlwdGVuX2RhdGVfbm93LFxuXG4gICAgICBlbXNjcmlwdGVuX2dldF9ub3c6IF9lbXNjcmlwdGVuX2dldF9ub3csXG5cbiAgICAgIGVtc2NyaXB0ZW5fcmVzaXplX2hlYXA6IF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLFxuXG4gICAgICBlbnZpcm9uX2dldDogX2Vudmlyb25fZ2V0LFxuXG4gICAgICBlbnZpcm9uX3NpemVzX2dldDogX2Vudmlyb25fc2l6ZXNfZ2V0LFxuXG4gICAgICBmZF9jbG9zZTogX2ZkX2Nsb3NlLFxuXG4gICAgICBmZF9mZHN0YXRfZ2V0OiBfZmRfZmRzdGF0X2dldCxcblxuICAgICAgZmRfcmVhZDogX2ZkX3JlYWQsXG5cbiAgICAgIGZkX3NlZWs6IF9mZF9zZWVrLFxuXG4gICAgICBmZF9zeW5jOiBfZmRfc3luYyxcblxuICAgICAgZmRfd3JpdGU6IF9mZF93cml0ZSxcblxuICAgICAgbWVtb3J5OiB3YXNtTWVtb3J5LFxuICAgIH07XG4gICAgdmFyIHdhc21FeHBvcnRzID0gY3JlYXRlV2FzbSgpO1xuICAgIHZhciBfX193YXNtX2NhbGxfY3RvcnMgPSAoKSA9PlxuICAgICAgKF9fX3dhc21fY2FsbF9jdG9ycyA9IHdhc21FeHBvcnRzWydfX3dhc21fY2FsbF9jdG9ycyddKSgpO1xuICAgIHZhciBfc3FsaXRlM19zdGF0dXM2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3N0YXR1czY0J10gPSAoYTAsIGExLCBhMiwgYTMpID0+XG4gICAgICAoX3NxbGl0ZTNfc3RhdHVzNjQgPSBNb2R1bGVbJ19zcWxpdGUzX3N0YXR1czY0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zdGF0dXM2NCddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19zdGF0dXMgPSAoTW9kdWxlWydfc3FsaXRlM19zdGF0dXMnXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM19zdGF0dXMgPSBNb2R1bGVbJ19zcWxpdGUzX3N0YXR1cyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RhdHVzJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX2RiX3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX3N0YXR1cyddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfZGJfc3RhdHVzID0gTW9kdWxlWydfc3FsaXRlM19kYl9zdGF0dXMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2RiX3N0YXR1cyddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfbXNpemUgPSAoTW9kdWxlWydfc3FsaXRlM19tc2l6ZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX21zaXplID0gTW9kdWxlWydfc3FsaXRlM19tc2l6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfbXNpemUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmZzX2ZpbmQgPSAoTW9kdWxlWydfc3FsaXRlM192ZnNfZmluZCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3Zmc19maW5kID0gTW9kdWxlWydfc3FsaXRlM192ZnNfZmluZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmZzX2ZpbmQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2luaXRpYWxpemUnXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfaW5pdGlhbGl6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfaW5pdGlhbGl6ZSddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfbWFsbG9jID0gKE1vZHVsZVsnX3NxbGl0ZTNfbWFsbG9jJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfbWFsbG9jID0gTW9kdWxlWydfc3FsaXRlM19tYWxsb2MnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX21hbGxvYyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19mcmVlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZnJlZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2ZyZWUgPSBNb2R1bGVbJ19zcWxpdGUzX2ZyZWUnXSA9IHdhc21FeHBvcnRzWydzcWxpdGUzX2ZyZWUnXSkoXG4gICAgICAgIGEwLFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Zmc19yZWdpc3RlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc19yZWdpc3RlciddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM192ZnNfcmVnaXN0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc19yZWdpc3RlciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmZzX3JlZ2lzdGVyJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM192ZnNfdW5yZWdpc3RlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Zmc191bnJlZ2lzdGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192ZnNfdW5yZWdpc3RlciddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19tYWxsb2M2NCA9IChNb2R1bGVbJ19zcWxpdGUzX21hbGxvYzY0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfbWFsbG9jNjQgPSBNb2R1bGVbJ19zcWxpdGUzX21hbGxvYzY0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19tYWxsb2M2NCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19yZWFsbG9jID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVhbGxvYyddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19yZWFsbG9jID0gTW9kdWxlWydfc3FsaXRlM19yZWFsbG9jJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZWFsbG9jJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19yZWFsbG9jNjQgPSAoTW9kdWxlWydfc3FsaXRlM19yZWFsbG9jNjQnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfcmVhbGxvYzY0ID0gTW9kdWxlWydfc3FsaXRlM19yZWFsbG9jNjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3JlYWxsb2M2NCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfdGV4dCA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3RleHQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV90ZXh0ID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV90ZXh0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV90ZXh0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3JhbmRvbW5lc3MgPSAoTW9kdWxlWydfc3FsaXRlM19yYW5kb21uZXNzJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3JhbmRvbW5lc3MgPSBNb2R1bGVbJ19zcWxpdGUzX3JhbmRvbW5lc3MnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3JhbmRvbW5lc3MnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0cmljbXAgPSAoTW9kdWxlWydfc3FsaXRlM19zdHJpY21wJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3N0cmljbXAgPSBNb2R1bGVbJ19zcWxpdGUzX3N0cmljbXAnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0cmljbXAnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0cm5pY21wID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RybmljbXAnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX3N0cm5pY21wID0gTW9kdWxlWydfc3FsaXRlM19zdHJuaWNtcCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RybmljbXAnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM191cmlfcGFyYW1ldGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXJpX3BhcmFtZXRlciddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM191cmlfcGFyYW1ldGVyID0gTW9kdWxlWydfc3FsaXRlM191cmlfcGFyYW1ldGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM191cmlfcGFyYW1ldGVyJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM191cmlfYm9vbGVhbiA9IChNb2R1bGVbJ19zcWxpdGUzX3VyaV9ib29sZWFuJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM191cmlfYm9vbGVhbiA9IE1vZHVsZVsnX3NxbGl0ZTNfdXJpX2Jvb2xlYW4nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3VyaV9ib29sZWFuJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc2VyaWFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfc2VyaWFsaXplJ10gPSAoYTAsIGExLCBhMiwgYTMpID0+XG4gICAgICAoX3NxbGl0ZTNfc2VyaWFsaXplID0gTW9kdWxlWydfc3FsaXRlM19zZXJpYWxpemUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3NlcmlhbGl6ZSddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19wcmVwYXJlX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfcHJlcGFyZV92MiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcHJlcGFyZV92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJlcGFyZV92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJlcGFyZV92MiddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RlcCA9IChNb2R1bGVbJ19zcWxpdGUzX3N0ZXAnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19zdGVwID0gTW9kdWxlWydfc3FsaXRlM19zdGVwJ10gPSB3YXNtRXhwb3J0c1snc3FsaXRlM19zdGVwJ10pKFxuICAgICAgICBhMCxcbiAgICAgICkpO1xuICAgIHZhciBfc3FsaXRlM19jb2x1bW5faW50NjQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5faW50NjQnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2ludDY0ID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5faW50NjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9pbnQ2NCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzZXQgPSAoTW9kdWxlWydfc3FsaXRlM19yZXNldCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc2V0ID0gTW9kdWxlWydfc3FsaXRlM19yZXNldCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzZXQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfZXhlYyA9IChNb2R1bGVbJ19zcWxpdGUzX2V4ZWMnXSA9IChhMCwgYTEsIGEyLCBhMywgYTQpID0+XG4gICAgICAoX3NxbGl0ZTNfZXhlYyA9IE1vZHVsZVsnX3NxbGl0ZTNfZXhlYyddID0gd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXhlYyddKShcbiAgICAgICAgYTAsXG4gICAgICAgIGExLFxuICAgICAgICBhMixcbiAgICAgICAgYTMsXG4gICAgICAgIGE0LFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5faW50J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9pbnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9pbnQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2ZpbmFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNfZmluYWxpemUnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19maW5hbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZmluYWxpemUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2ZpbmFsaXplJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2ZpbGVfY29udHJvbCA9IChNb2R1bGVbJ19zcWxpdGUzX2ZpbGVfY29udHJvbCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2ZpbGVfY29udHJvbCA9IE1vZHVsZVsnX3NxbGl0ZTNfZmlsZV9jb250cm9sJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19maWxlX2NvbnRyb2wnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX25hbWUgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fbmFtZSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19jb2x1bW5fbmFtZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX25hbWUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9uYW1lJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fdGV4dCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl90ZXh0J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl90ZXh0ID0gTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fdGV4dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sdW1uX3RleHQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl90eXBlID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX3R5cGUnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX3R5cGUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl90eXBlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fdHlwZSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfZXJybXNnID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXJybXNnJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfZXJybXNnID0gTW9kdWxlWydfc3FsaXRlM19lcnJtc2cnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2Vycm1zZyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19kZXNlcmlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2Rlc2VyaWFsaXplJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICAgYTUsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2Rlc2VyaWFsaXplID0gTW9kdWxlWydfc3FsaXRlM19kZXNlcmlhbGl6ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZGVzZXJpYWxpemUnXSkoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkpO1xuICAgIHZhciBfc3FsaXRlM19jbGVhcl9iaW5kaW5ncyA9IChNb2R1bGVbJ19zcWxpdGUzX2NsZWFyX2JpbmRpbmdzJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MgPSBNb2R1bGVbJ19zcWxpdGUzX2NsZWFyX2JpbmRpbmdzJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jbGVhcl9iaW5kaW5ncyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfYmxvYiddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2Jsb2InXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX2Jsb2InXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfYnl0ZXMgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ieXRlcyddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX2J5dGVzID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ieXRlcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfYnl0ZXMnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZG91YmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZG91YmxlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfZG91YmxlID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9kb3VibGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX2RvdWJsZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9pbnQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ludCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfaW50J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX2ludDY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfaW50NjQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV9pbnQ2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfaW50NjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX2ludDY0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9zdWJ0eXBlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfc3VidHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfc3VidHlwZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfc3VidHlwZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfcG9pbnRlciddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9wb2ludGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9wb2ludGVyJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV90eXBlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfdHlwZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX3R5cGUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX3R5cGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX3R5cGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX25vY2hhbmdlID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQgPSAoTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcm9tYmluZCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9mcm9tYmluZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdmFsdWVfZHVwID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZHVwJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdmFsdWVfZHVwID0gTW9kdWxlWydfc3FsaXRlM192YWx1ZV9kdXAnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX2R1cCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM192YWx1ZV9mcmVlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfZnJlZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSBNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX2ZyZWUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ZhbHVlX2ZyZWUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfYmxvYiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9ibG9iID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfYmxvYiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2Jsb2InXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnXSA9XG4gICAgICAoYTApID0+XG4gICAgICAgIChfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZG91YmxlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfZG91YmxlJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3IgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3InXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3InXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9lcnJvciddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfaW50J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9pbnQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQ2NCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQ2NCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfaW50NjQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9pbnQ2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2ludDY0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfbnVsbCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9udWxsJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X251bGwgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9udWxsJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfbnVsbCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfcG9pbnRlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9wb2ludGVyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXIgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9wb2ludGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfcG9pbnRlciddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfc3VidHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19yZXN1bHRfc3VidHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfdGV4dCA9IChNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF90ZXh0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcmVzdWx0X3RleHQgPSBNb2R1bGVbJ19zcWxpdGUzX3Jlc3VsdF90ZXh0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfdGV4dCddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2IgPSAoTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2InXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19yZXN1bHRfemVyb2Jsb2InXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0ID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlID0gKE1vZHVsZVsnX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlID0gTW9kdWxlWydfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3VzZXJfZGF0YSA9IChNb2R1bGVbJ19zcWxpdGUzX3VzZXJfZGF0YSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3VzZXJfZGF0YSA9IE1vZHVsZVsnX3NxbGl0ZTNfdXNlcl9kYXRhJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM191c2VyX2RhdGEnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUgPSAoTW9kdWxlWydfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlID0gTW9kdWxlWydfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192dGFiX25vY2hhbmdlID0gTW9kdWxlWydfc3FsaXRlM192dGFiX25vY2hhbmdlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192dGFiX25vY2hhbmdlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luX2ZpcnN0J10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW5fZmlyc3QnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Z0YWJfaW5fZmlyc3QnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW5fbmV4dCA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW5fbmV4dCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM192dGFiX2luX25leHQgPSBNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfaW5fbmV4dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdnRhYl9pbl9uZXh0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCA9IChNb2R1bGVbJ19zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0J10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19nZXRfYXV4ZGF0YSA9IChNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXhkYXRhJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2dldF9hdXhkYXRhID0gTW9kdWxlWydfc3FsaXRlM19nZXRfYXV4ZGF0YSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZ2V0X2F1eGRhdGEnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3NldF9hdXhkYXRhID0gKE1vZHVsZVsnX3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19zZXRfYXV4ZGF0YSA9IE1vZHVsZVsnX3NxbGl0ZTNfc2V0X2F1eGRhdGEnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3NldF9hdXhkYXRhJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9jb3VudCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2NvdW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fY291bnQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfZGF0YV9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2RhdGFfY291bnQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19kYXRhX2NvdW50ID0gTW9kdWxlWydfc3FsaXRlM19kYXRhX2NvdW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kYXRhX2NvdW50J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9ibG9iID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2Jsb2InXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfY29sdW1uX2Jsb2IgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9ibG9iJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fYmxvYiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29sdW1uX2J5dGVzID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2J5dGVzJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl9ieXRlcyA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2J5dGVzJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fYnl0ZXMnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl9kb3VibGUgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fZG91YmxlJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl9kb3VibGUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl9kb3VibGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbHVtbl9kb3VibGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbHVtbl92YWx1ZSA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl92YWx1ZSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19jb2x1bW5fdmFsdWUgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbHVtbl92YWx1ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29sdW1uX3ZhbHVlJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19jb2x1bW5fZGVjbHR5cGUgPSAoTW9kdWxlWydfc3FsaXRlM19jb2x1bW5fZGVjbHR5cGUnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbHVtbl9kZWNsdHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfY29sdW1uX2RlY2x0eXBlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb2x1bW5fZGVjbHR5cGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfYmxvYiA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfYmxvYiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF9ibG9iID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2Jsb2InXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfYmxvYiddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9kb3VibGUgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX2RvdWJsZSddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF9kb3VibGUgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfZG91YmxlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19iaW5kX2RvdWJsZSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfaW50ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9pbnQnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX2JpbmRfaW50ID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX2ludCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF9pbnQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19iaW5kX2ludDY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9pbnQ2NCddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF9pbnQ2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9pbnQ2NCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF9pbnQ2NCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfbnVsbCA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfbnVsbCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX251bGwgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfbnVsbCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYmluZF9udWxsJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19iaW5kX3BvaW50ZXIgPSAoTW9kdWxlWydfc3FsaXRlM19iaW5kX3BvaW50ZXInXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2JpbmRfcG9pbnRlciA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9wb2ludGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19iaW5kX3BvaW50ZXInXSkoYTAsIGExLCBhMiwgYTMsIGE0KSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfdGV4dCA9IChNb2R1bGVbJ19zcWxpdGUzX2JpbmRfdGV4dCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF90ZXh0ID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX3RleHQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfdGV4dCddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50J1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQgPSBNb2R1bGVbJ19zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfbmFtZSddID1cbiAgICAgIChhMCwgYTEpID0+XG4gICAgICAgIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9uYW1lJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4ID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCdcbiAgICBdID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCA9IE1vZHVsZVsnX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19kYl9oYW5kbGUgPSAoTW9kdWxlWydfc3FsaXRlM19kYl9oYW5kbGUnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19kYl9oYW5kbGUgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX2hhbmRsZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZGJfaGFuZGxlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSAoTW9kdWxlWydfc3FsaXRlM19zdG10X3JlYWRvbmx5J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfc3RtdF9yZWFkb25seSA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RtdF9yZWFkb25seSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RtdF9yZWFkb25seSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19zdG10X2lzZXhwbGFpbiA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfaXNleHBsYWluJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW4gPSBNb2R1bGVbJ19zcWxpdGUzX3N0bXRfaXNleHBsYWluJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zdG10X2lzZXhwbGFpbiddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19zdG10X2V4cGxhaW4gPSAoTW9kdWxlWydfc3FsaXRlM19zdG10X2V4cGxhaW4nXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfc3RtdF9leHBsYWluID0gTW9kdWxlWydfc3FsaXRlM19zdG10X2V4cGxhaW4nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0bXRfZXhwbGFpbiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RtdF9idXN5ID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3RtdF9idXN5J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfc3RtdF9idXN5ID0gTW9kdWxlWydfc3FsaXRlM19zdG10X2J1c3knXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0bXRfYnVzeSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19zdG10X3N0YXR1cyA9IChNb2R1bGVbJ19zcWxpdGUzX3N0bXRfc3RhdHVzJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM19zdG10X3N0YXR1cyA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RtdF9zdGF0dXMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0bXRfc3RhdHVzJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3FsID0gKE1vZHVsZVsnX3NxbGl0ZTNfc3FsJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfc3FsID0gTW9kdWxlWydfc3FsaXRlM19zcWwnXSA9IHdhc21FeHBvcnRzWydzcWxpdGUzX3NxbCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19leHBhbmRlZF9zcWwgPSAoTW9kdWxlWydfc3FsaXRlM19leHBhbmRlZF9zcWwnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19leHBhbmRlZF9zcWwgPSBNb2R1bGVbJ19zcWxpdGUzX2V4cGFuZGVkX3NxbCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXhwYW5kZWRfc3FsJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9vbGQgPSAoTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfb2xkJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3ByZXVwZGF0ZV9vbGQgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19wcmV1cGRhdGVfY291bnQgPSAoTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfY291bnQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19wcmV1cGRhdGVfY291bnQgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19wcmV1cGRhdGVfZGVwdGgnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnXSA9XG4gICAgICAoYTApID0+XG4gICAgICAgIChfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcHJldXBkYXRlX25ldyA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9uZXcnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfcHJldXBkYXRlX25ldyA9IE1vZHVsZVsnX3NxbGl0ZTNfcHJldXBkYXRlX25ldyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJldXBkYXRlX25ldyddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZSA9IChNb2R1bGVbJ19zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZSddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXIgPSAoTW9kdWxlWydfc3FsaXRlM19zZXRfYXV0aG9yaXplciddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19zZXRfYXV0aG9yaXplciA9IE1vZHVsZVsnX3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3NldF9hdXRob3JpemVyJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RyZ2xvYiA9IChNb2R1bGVbJ19zcWxpdGUzX3N0cmdsb2InXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfc3RyZ2xvYiA9IE1vZHVsZVsnX3NxbGl0ZTNfc3RyZ2xvYiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfc3RyZ2xvYiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfc3RybGlrZSA9IChNb2R1bGVbJ19zcWxpdGUzX3N0cmxpa2UnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX3N0cmxpa2UgPSBNb2R1bGVbJ19zcWxpdGUzX3N0cmxpa2UnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3N0cmxpa2UnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbJ19zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19hdXRvX2V4dGVuc2lvbiddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbidcbiAgICBdID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbidcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24nXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uJ1xuICAgIF0gPSAoKSA9PlxuICAgICAgKF9zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlWydfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24nXSkoKSk7XG4gICAgdmFyIF9zcWxpdGUzX3ByZXBhcmVfdjMgPSAoTW9kdWxlWydfc3FsaXRlM19wcmVwYXJlX3YzJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICAgYTUsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3ByZXBhcmVfdjMgPSBNb2R1bGVbJ19zcWxpdGUzX3ByZXBhcmVfdjMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3ByZXBhcmVfdjMnXSkoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkpO1xuICAgIHZhciBfc3FsaXRlM19jcmVhdGVfbW9kdWxlID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGUgPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NyZWF0ZV9tb2R1bGUnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjInXSkoYTAsIGExLCBhMiwgYTMsIGE0KSk7XG4gICAgdmFyIF9zcWxpdGUzX2Ryb3BfbW9kdWxlcyA9IChNb2R1bGVbJ19zcWxpdGUzX2Ryb3BfbW9kdWxlcyddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19kcm9wX21vZHVsZXMgPSBNb2R1bGVbJ19zcWxpdGUzX2Ryb3BfbW9kdWxlcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZHJvcF9tb2R1bGVzJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19kZWNsYXJlX3Z0YWIgPSAoTW9kdWxlWydfc3FsaXRlM19kZWNsYXJlX3Z0YWInXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfZGVjbGFyZV92dGFiID0gTW9kdWxlWydfc3FsaXRlM19kZWNsYXJlX3Z0YWInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2RlY2xhcmVfdnRhYiddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdCA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gTW9kdWxlWydfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192dGFiX29uX2NvbmZsaWN0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uID0gTW9kdWxlWydfc3FsaXRlM192dGFiX2NvbGxhdGlvbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24nXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3Z0YWJfaW4gPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX2luJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM192dGFiX2luID0gTW9kdWxlWydfc3FsaXRlM192dGFiX2luJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192dGFiX2luJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUgPSAoTW9kdWxlWydfc3FsaXRlM192dGFiX3Joc192YWx1ZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM192dGFiX3Joc192YWx1ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdnRhYl9kaXN0aW5jdCA9IChNb2R1bGVbJ19zcWxpdGUzX3Z0YWJfZGlzdGluY3QnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM192dGFiX2Rpc3RpbmN0ID0gTW9kdWxlWydfc3FsaXRlM192dGFiX2Rpc3RpbmN0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM192dGFiX2Rpc3RpbmN0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2tleXdvcmRfbmFtZSA9IChNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfbmFtZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19rZXl3b3JkX25hbWUgPSBNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfbmFtZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfa2V5d29yZF9uYW1lJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IChNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfY291bnQnXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9jb3VudCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfa2V5d29yZF9jb3VudCddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfa2V5d29yZF9jaGVjayA9IChNb2R1bGVbJ19zcWxpdGUzX2tleXdvcmRfY2hlY2snXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfa2V5d29yZF9jaGVjayA9IE1vZHVsZVsnX3NxbGl0ZTNfa2V5d29yZF9jaGVjayddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfa2V5d29yZF9jaGVjayddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29tcGxldGUgPSAoTW9kdWxlWydfc3FsaXRlM19jb21wbGV0ZSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbXBsZXRlID0gTW9kdWxlWydfc3FsaXRlM19jb21wbGV0ZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY29tcGxldGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfbGlidmVyc2lvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2xpYnZlcnNpb24nXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfbGlidmVyc2lvbiA9IE1vZHVsZVsnX3NxbGl0ZTNfbGlidmVyc2lvbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfbGlidmVyc2lvbiddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXIgPSAoTW9kdWxlWydfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciddID1cbiAgICAgICgpID0+XG4gICAgICAgIChfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciA9IE1vZHVsZVsnX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXInXSkoKSk7XG4gICAgdmFyIF9zcWxpdGUzX3NodXRkb3duID0gKE1vZHVsZVsnX3NxbGl0ZTNfc2h1dGRvd24nXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfc2h1dGRvd24gPSBNb2R1bGVbJ19zcWxpdGUzX3NodXRkb3duJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zaHV0ZG93biddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQgPSAoTW9kdWxlWydfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkID0gTW9kdWxlWydfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQnXG4gICAgXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY2hhbmdlczY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2hhbmdlczY0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfY2hhbmdlczY0ID0gTW9kdWxlWydfc3FsaXRlM19jaGFuZ2VzNjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NoYW5nZXM2NCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19jaGFuZ2VzID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2hhbmdlcyddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX2NoYW5nZXMgPSBNb2R1bGVbJ19zcWxpdGUzX2NoYW5nZXMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NoYW5nZXMnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ID0gTW9kdWxlWydfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gKE1vZHVsZVsnX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX3RvdGFsX2NoYW5nZXMgPSBNb2R1bGVbJ19zcWxpdGUzX3RvdGFsX2NoYW5nZXMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3RvdGFsX2NoYW5nZXMnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfdHhuX3N0YXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNfdHhuX3N0YXRlJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX3R4bl9zdGF0ZSA9IE1vZHVsZVsnX3NxbGl0ZTNfdHhuX3N0YXRlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM190eG5fc3RhdGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2Nsb3NlX3YyID0gKE1vZHVsZVsnX3NxbGl0ZTNfY2xvc2VfdjInXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19jbG9zZV92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfY2xvc2VfdjInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2Nsb3NlX3YyJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2J1c3lfaGFuZGxlciA9IChNb2R1bGVbJ19zcWxpdGUzX2J1c3lfaGFuZGxlciddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19idXN5X2hhbmRsZXIgPSBNb2R1bGVbJ19zcWxpdGUzX2J1c3lfaGFuZGxlciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlciA9IChNb2R1bGVbJ19zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyID0gTW9kdWxlWydfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX2J1c3lfdGltZW91dCA9IChNb2R1bGVbJ19zcWxpdGUzX2J1c3lfdGltZW91dCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19idXN5X3RpbWVvdXQgPSBNb2R1bGVbJ19zcWxpdGUzX2J1c3lfdGltZW91dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfYnVzeV90aW1lb3V0J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19pbnRlcnJ1cHQgPSAoTW9kdWxlWydfc3FsaXRlM19pbnRlcnJ1cHQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19pbnRlcnJ1cHQgPSBNb2R1bGVbJ19zcWxpdGUzX2ludGVycnVwdCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfaW50ZXJydXB0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2lzX2ludGVycnVwdGVkID0gKE1vZHVsZVsnX3NxbGl0ZTNfaXNfaW50ZXJydXB0ZWQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19pc19pbnRlcnJ1cHRlZCA9IE1vZHVsZVsnX3NxbGl0ZTNfaXNfaW50ZXJydXB0ZWQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2lzX2ludGVycnVwdGVkJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICAgIGE1LFxuICAgICAgYTYsXG4gICAgICBhNyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uID0gTW9kdWxlWydfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24nXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiddKShcbiAgICAgICAgYTAsXG4gICAgICAgIGExLFxuICAgICAgICBhMixcbiAgICAgICAgYTMsXG4gICAgICAgIGE0LFxuICAgICAgICBhNSxcbiAgICAgICAgYTYsXG4gICAgICAgIGE3LFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICAgIGE1LFxuICAgICAgYTYsXG4gICAgICBhNyxcbiAgICAgIGE4LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIgPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICAgIGEyLFxuICAgICAgICBhMyxcbiAgICAgICAgYTQsXG4gICAgICAgIGE1LFxuICAgICAgICBhNixcbiAgICAgICAgYTcsXG4gICAgICAgIGE4LFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24nXG4gICAgXSA9IChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgPT5cbiAgICAgIChfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbidcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uJ10pKFxuICAgICAgICBhMCxcbiAgICAgICAgYTEsXG4gICAgICAgIGEyLFxuICAgICAgICBhMyxcbiAgICAgICAgYTQsXG4gICAgICAgIGE1LFxuICAgICAgICBhNixcbiAgICAgICAgYTcsXG4gICAgICAgIGE4LFxuICAgICAgICBhOSxcbiAgICAgICkpO1xuICAgIHZhciBfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiA9IChNb2R1bGVbJ19zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uID0gTW9kdWxlWydfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb24nXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM190cmFjZV92MiA9IChNb2R1bGVbJ19zcWxpdGUzX3RyYWNlX3YyJ10gPSAoYTAsIGExLCBhMiwgYTMpID0+XG4gICAgICAoX3NxbGl0ZTNfdHJhY2VfdjIgPSBNb2R1bGVbJ19zcWxpdGUzX3RyYWNlX3YyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM190cmFjZV92MiddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19jb21taXRfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbW1pdF9ob29rJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM19jb21taXRfaG9vayA9IE1vZHVsZVsnX3NxbGl0ZTNfY29tbWl0X2hvb2snXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbW1pdF9ob29rJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfdXBkYXRlX2hvb2sgPSAoTW9kdWxlWydfc3FsaXRlM191cGRhdGVfaG9vayddID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfdXBkYXRlX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3VwZGF0ZV9ob29rJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM191cGRhdGVfaG9vayddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX3JvbGxiYWNrX2hvb2sgPSAoTW9kdWxlWydfc3FsaXRlM19yb2xsYmFja19ob29rJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3JvbGxiYWNrX2hvb2sgPSBNb2R1bGVbJ19zcWxpdGUzX3JvbGxiYWNrX2hvb2snXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3JvbGxiYWNrX2hvb2snXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19wcmV1cGRhdGVfaG9vayA9IChNb2R1bGVbJ19zcWxpdGUzX3ByZXVwZGF0ZV9ob29rJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rID0gTW9kdWxlWydfc3FsaXRlM19wcmV1cGRhdGVfaG9vayddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19lcnJvcl9vZmZzZXQgPSAoTW9kdWxlWydfc3FsaXRlM19lcnJvcl9vZmZzZXQnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM19lcnJvcl9vZmZzZXQgPSBNb2R1bGVbJ19zcWxpdGUzX2Vycm9yX29mZnNldCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0J10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX2VycmNvZGUgPSAoTW9kdWxlWydfc3FsaXRlM19lcnJjb2RlJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfZXJyY29kZSA9IE1vZHVsZVsnX3NxbGl0ZTNfZXJyY29kZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXJyY29kZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUgPSBNb2R1bGVbJ19zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfZXJyc3RyID0gKE1vZHVsZVsnX3NxbGl0ZTNfZXJyc3RyJ10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfZXJyc3RyID0gTW9kdWxlWydfc3FsaXRlM19lcnJzdHInXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2VycnN0ciddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19saW1pdCA9IChNb2R1bGVbJ19zcWxpdGUzX2xpbWl0J10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM19saW1pdCA9IE1vZHVsZVsnX3NxbGl0ZTNfbGltaXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2xpbWl0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfb3BlbiA9IChNb2R1bGVbJ19zcWxpdGUzX29wZW4nXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfb3BlbiA9IE1vZHVsZVsnX3NxbGl0ZTNfb3BlbiddID0gd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfb3BlbiddKShcbiAgICAgICAgYTAsXG4gICAgICAgIGExLFxuICAgICAgKSk7XG4gICAgdmFyIF9zcWxpdGUzX29wZW5fdjIgPSAoTW9kdWxlWydfc3FsaXRlM19vcGVuX3YyJ10gPSAoYTAsIGExLCBhMiwgYTMpID0+XG4gICAgICAoX3NxbGl0ZTNfb3Blbl92MiA9IE1vZHVsZVsnX3NxbGl0ZTNfb3Blbl92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfb3Blbl92MiddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uID0gKE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiA9IE1vZHVsZVsnX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IChNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInXSA9XG4gICAgICAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkgPT5cbiAgICAgICAgKF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIgPSBNb2R1bGVbJ19zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiddKShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSk7XG4gICAgdmFyIF9zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQgPSAoTW9kdWxlWydfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19nZXRfYXV0b2NvbW1pdCA9IChNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXRvY29tbWl0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQgPSBNb2R1bGVbJ19zcWxpdGUzX2dldF9hdXRvY29tbWl0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19nZXRfYXV0b2NvbW1pdCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSdcbiAgICBdID0gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpID0+XG4gICAgICAoX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSddKShcbiAgICAgICAgYTAsXG4gICAgICAgIGExLFxuICAgICAgICBhMixcbiAgICAgICAgYTMsXG4gICAgICAgIGE0LFxuICAgICAgICBhNSxcbiAgICAgICAgYTYsXG4gICAgICAgIGE3LFxuICAgICAgICBhOCxcbiAgICAgICkpO1xuICAgIHZhciBfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcydcbiAgICBdID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM191cmlfa2V5ID0gKE1vZHVsZVsnX3NxbGl0ZTNfdXJpX2tleSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM191cmlfa2V5ID0gTW9kdWxlWydfc3FsaXRlM191cmlfa2V5J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM191cmlfa2V5J10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM191cmlfaW50NjQgPSAoTW9kdWxlWydfc3FsaXRlM191cmlfaW50NjQnXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzX3VyaV9pbnQ2NCA9IE1vZHVsZVsnX3NxbGl0ZTNfdXJpX2ludDY0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM191cmlfaW50NjQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19kYl9uYW1lID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfbmFtZSddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19kYl9uYW1lID0gTW9kdWxlWydfc3FsaXRlM19kYl9uYW1lJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kYl9uYW1lJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19kYl9maWxlbmFtZSA9IChNb2R1bGVbJ19zcWxpdGUzX2RiX2ZpbGVuYW1lJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX2RiX2ZpbGVuYW1lID0gTW9kdWxlWydfc3FsaXRlM19kYl9maWxlbmFtZSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfZGJfZmlsZW5hbWUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX2RiX3JlYWRvbmx5ID0gKE1vZHVsZVsnX3NxbGl0ZTNfZGJfcmVhZG9ubHknXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfZGJfcmVhZG9ubHkgPSBNb2R1bGVbJ19zcWxpdGUzX2RiX3JlYWRvbmx5J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19kYl9yZWFkb25seSddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkID0gKE1vZHVsZVsnX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkID0gTW9kdWxlWydfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCA9IChNb2R1bGVbJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQgPSBNb2R1bGVbJ19zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fZGlmZiA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kaWZmJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2RpZmYgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kaWZmJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fZGlmZiddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fYXR0YWNoID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2F0dGFjaCddID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fYXR0YWNoID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fYXR0YWNoJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY3JlYXRlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fY3JlYXRlJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9kZWxldGUnXSA9IChhMCkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fZGVsZXRlID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fZGVsZXRlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fZGVsZXRlJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyJ10gPVxuICAgICAgKGEwLCBhMSwgYTIpID0+XG4gICAgICAgIChfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0ID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0ID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nXG4gICAgXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0nXG4gICAgXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0nXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0ID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9lbmFibGUgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fZW5hYmxlJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9lbmFibGUgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9lbmFibGUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9lbmFibGUnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCA9IChNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0ID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHkgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHknXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkID0gKE1vZHVsZVsnX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcnXG4gICAgXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnID0gTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSdcbiAgICBdID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjIgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0nXSA9XG4gICAgICAoYTAsIGExLCBhMikgPT5cbiAgICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0nXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0nXG4gICAgXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X25leHQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXh0J10gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9vcCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X29wJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9vcCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfb3AnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X29wJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9wayA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X3BrJ10gPSAoYTAsIGExLCBhMikgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9wayA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfcGsnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X3BrJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X29sZCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9vbGQnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXcgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXcnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9uZXcnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X25ldyddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0ID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJ1xuICAgIF0gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cydcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHMnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydCA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2ludmVydCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0J10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJ1xuICAgIF0gPSAoYTAsIGExLCBhMiwgYTMpID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0gPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSddKShhMCwgYTEsIGEyLCBhMykpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgICBhMyxcbiAgICAgIGE0LFxuICAgICAgYTUsXG4gICAgICBhNixcbiAgICAgIGE3LFxuICAgICAgYTgsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjInXSkoXG4gICAgICAgIGEwLFxuICAgICAgICBhMSxcbiAgICAgICAgYTIsXG4gICAgICAgIGEzLFxuICAgICAgICBhNCxcbiAgICAgICAgYTUsXG4gICAgICAgIGE2LFxuICAgICAgICBhNyxcbiAgICAgICAgYTgsXG4gICAgICApKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9hcHBseSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICAgIGE1LFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5J10pKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSdcbiAgICBdID0gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0nXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSddKShcbiAgICAgICAgYTAsXG4gICAgICAgIGExLFxuICAgICAgICBhMixcbiAgICAgICAgYTMsXG4gICAgICAgIGE0LFxuICAgICAgICBhNSxcbiAgICAgICAgYTYsXG4gICAgICAgIGE3LFxuICAgICAgICBhOCxcbiAgICAgICkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gKE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSddID1cbiAgICAgIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSA9PlxuICAgICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSddID1cbiAgICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX25ldyddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX25ldyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCA9IE1vZHVsZVsnX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0J10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0nXSA9XG4gICAgICAoYTAsIGExLCBhMikgPT5cbiAgICAgICAgKF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0gPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0nXSA9XG4gICAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXG4gICAgXSA9IChhMCwgYTEsIGEyKSA9PlxuICAgICAgKF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0gPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSA9IChNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUgPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQgPSAoTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICAgIGEzLFxuICAgICAgYTQsXG4gICAgICBhNSxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0ID0gTW9kdWxlWydfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCddKShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSk7XG4gICAgdmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSdcbiAgICBdID0gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpID0+XG4gICAgICAoX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0gPSBNb2R1bGVbJ19zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSddKShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSk7XG4gICAgdmFyIF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSAoTW9kdWxlWydfc3FsaXRlM3Nlc3Npb25fY29uZmlnJ10gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSBNb2R1bGVbJ19zcWxpdGUzc2Vzc2lvbl9jb25maWcnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzc2Vzc2lvbl9jb25maWcnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX3NvdXJjZWlkID0gKE1vZHVsZVsnX3NxbGl0ZTNfc291cmNlaWQnXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfc291cmNlaWQgPSBNb2R1bGVbJ19zcWxpdGUzX3NvdXJjZWlkJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19zb3VyY2VpZCddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3B0ciA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3BzdGFja19wdHInXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3B0ciA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3B0ciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fcHN0YWNrX3B0ciddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3Jlc3RvcmUgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3BzdGFja19yZXN0b3JlJ1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3Jlc3RvcmUgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3BzdGFja19yZXN0b3JlJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVzdG9yZSddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MnXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3BzdGFja19hbGxvYyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fcHN0YWNrX2FsbG9jJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3BzdGFja19yZW1haW5pbmcgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3BzdGFja19yZW1haW5pbmcnXG4gICAgXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3JlbWFpbmluZyA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX3BzdGFja19yZW1haW5pbmcnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fcHN0YWNrX3JlbWFpbmluZyddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhJ10gPVxuICAgICAgKCkgPT5cbiAgICAgICAgKF9zcWxpdGUzX193YXNtX3BzdGFja19xdW90YSA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3BzdGFja19xdW90YSddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZGJfZXJyb3IgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9lcnJvciddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9kYl9lcnJvciA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfZXJyb3InXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2RiX2Vycm9yJ10pKGEwLCBhMSwgYTIpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJ1Y3QgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV90ZXN0X3N0cnVjdCddID0gKFxuICAgICAgYTAsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3Rlc3Rfc3RydWN0ID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV90ZXN0X3N0cnVjdCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJ1Y3QnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZW51bV9qc29uID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZW51bV9qc29uJ10gPSAoKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2VudW1fanNvbiA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZW51bV9qc29uJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9lbnVtX2pzb24nXSkoKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Zmc191bmxpbmsgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9kYl92ZnMgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl92ZnMnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfdmZzID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl92ZnMnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2RiX3ZmcyddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZGJfcmVzZXQgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9yZXNldCddID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2RiX3Jlc2V0ID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9yZXNldCddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fZGJfcmVzZXQnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX2RiX2V4cG9ydF9jaHVua2VkJ1xuICAgIF0gPSAoYTAsIGExKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2RiX2V4cG9ydF9jaHVua2VkID0gTW9kdWxlW1xuICAgICAgICAnX3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQnXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2RiX3NlcmlhbGl6ZSA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX3NlcmlhbGl6ZSddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgICBhNCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9zZXJpYWxpemUnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2RiX3NlcmlhbGl6ZSddKShhMCwgYTEsIGEyLCBhMywgYTQpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdmZzX2NyZWF0ZV9maWxlID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUnXG4gICAgXSA9IChhMCwgYTEsIGEyLCBhMykgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUnXG4gICAgICBdID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fdmZzX2NyZWF0ZV9maWxlJ10pKGEwLCBhMSwgYTIsIGEzKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSdcbiAgICBdID0gKGEwLCBhMSwgYTIpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjaydcbiAgICBdID0gKGEwLCBhMSkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayA9IE1vZHVsZVtcbiAgICAgICAgJ19zcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrJ1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9rdnZmc19tZXRob2RzID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fa3Z2ZnNfbWV0aG9kcyddID1cbiAgICAgICgpID0+XG4gICAgICAgIChfc3FsaXRlM19fd2FzbV9rdnZmc19tZXRob2RzID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9rdnZmc19tZXRob2RzJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMnXSkoKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Z0YWJfY29uZmlnID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdnRhYl9jb25maWcnXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdnRhYl9jb25maWcgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Z0YWJfY29uZmlnJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV92dGFiX2NvbmZpZyddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcCA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcCddID0gKFxuICAgICAgYTAsXG4gICAgICBhMSxcbiAgICAgIGEyLFxuICAgICAgYTMsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcCA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX2lwJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9kYl9jb25maWdfaXAnXSkoYTAsIGExLCBhMiwgYTMpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaSA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19waWknXSA9XG4gICAgICAoYTAsIGExLCBhMiwgYTMsIGE0KSA9PlxuICAgICAgICAoX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaSA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaSddID1cbiAgICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcGlpJ10pKGEwLCBhMSwgYTIsIGEzLCBhNCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcyA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICAgYTIsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcyddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3MnXSkoYTAsIGExLCBhMikpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9jb25maWdfaSA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2NvbmZpZ19pJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9jb25maWdfaSA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fY29uZmlnX2knXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2NvbmZpZ19pJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9jb25maWdfaWkgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9jb25maWdfaWknXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgICBhMixcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fY29uZmlnX2lpID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9jb25maWdfaWknXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX2NvbmZpZ19paSddKShhMCwgYTEsIGEyKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX2NvbmZpZ19qID0gKE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fY29uZmlnX2onXSA9IChcbiAgICAgIGEwLFxuICAgICAgYTEsXG4gICAgKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX2NvbmZpZ19qID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9jb25maWdfaiddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fY29uZmlnX2onXSkoYTAsIGExKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3FmbXRfdG9rZW4gPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuJ10gPSAoXG4gICAgICBhMCxcbiAgICAgIGExLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuJ10pKGEwLCBhMSkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9pbml0X3dhc21mcyA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX2luaXRfd2FzbWZzJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21faW5pdF93YXNtZnMgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX2luaXRfd2FzbWZzJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9pbml0X3dhc21mcyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X2ludHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50cHRyJ10gPSAoXG4gICAgICBhMCxcbiAgICApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnRwdHIgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50cHRyJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X2ludHB0ciddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X3ZvaWRwdHIgPSAoTW9kdWxlWydfc3FsaXRlM19fd2FzbV90ZXN0X3ZvaWRwdHInXSA9IChcbiAgICAgIGEwLFxuICAgICkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X3ZvaWRwdHIgPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3Rfdm9pZHB0ciddID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ3NxbGl0ZTNfX3dhc21fdGVzdF92b2lkcHRyJ10pKGEwKSk7XG4gICAgdmFyIF9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWF4ID0gKE1vZHVsZVtcbiAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21heCdcbiAgICBdID0gKCkgPT5cbiAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21heCA9IE1vZHVsZVsnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9tYXgnXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWF4J10pKCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW4nXG4gICAgXSA9ICgpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW4gPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWluJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbiddKSgpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF90aW1lczIgPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfdGltZXMyJ1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF90aW1lczIgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X3RpbWVzMidcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X3RpbWVzMiddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbm1heCA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW5tYXgnXG4gICAgXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW5tYXggPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbm1heCdcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbm1heCddKShhMCwgYTEpKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NHB0ciA9IChNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRwdHInXSA9XG4gICAgICAoYTApID0+XG4gICAgICAgIChfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0cHRyID0gTW9kdWxlWydfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0cHRyJ10gPVxuICAgICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRwdHInXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdyA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdydcbiAgICBdID0gKGEwKSA9PlxuICAgICAgKF9zcWxpdGUzX193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93J1xuICAgICAgXSA9XG4gICAgICAgIHdhc21FeHBvcnRzWydzcWxpdGUzX193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cnXSkoYTApKTtcbiAgICB2YXIgX3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJfaGVsbG8gPSAoTW9kdWxlW1xuICAgICAgJ19zcWxpdGUzX193YXNtX3Rlc3Rfc3RyX2hlbGxvJ1xuICAgIF0gPSAoYTApID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fdGVzdF9zdHJfaGVsbG8gPSBNb2R1bGVbJ19zcWxpdGUzX193YXNtX3Rlc3Rfc3RyX2hlbGxvJ10gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV90ZXN0X3N0cl9oZWxsbyddKShhMCkpO1xuICAgIHZhciBfc3FsaXRlM19fd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiA9IChNb2R1bGVbXG4gICAgICAnX3NxbGl0ZTNfX3dhc21fU1FMVGVzdGVyX3N0cmdsb2InXG4gICAgXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3NxbGl0ZTNfX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IgPSBNb2R1bGVbXG4gICAgICAgICdfc3FsaXRlM19fd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYidcbiAgICAgIF0gPVxuICAgICAgICB3YXNtRXhwb3J0c1snc3FsaXRlM19fd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiddKShhMCwgYTEpKTtcbiAgICB2YXIgX21hbGxvYyA9IChNb2R1bGVbJ19tYWxsb2MnXSA9IChhMCkgPT5cbiAgICAgIChfbWFsbG9jID0gTW9kdWxlWydfbWFsbG9jJ10gPSB3YXNtRXhwb3J0c1snbWFsbG9jJ10pKGEwKSk7XG4gICAgdmFyIF9mcmVlID0gKE1vZHVsZVsnX2ZyZWUnXSA9IChhMCkgPT5cbiAgICAgIChfZnJlZSA9IE1vZHVsZVsnX2ZyZWUnXSA9IHdhc21FeHBvcnRzWydmcmVlJ10pKGEwKSk7XG4gICAgdmFyIF9yZWFsbG9jID0gKE1vZHVsZVsnX3JlYWxsb2MnXSA9IChhMCwgYTEpID0+XG4gICAgICAoX3JlYWxsb2MgPSBNb2R1bGVbJ19yZWFsbG9jJ10gPSB3YXNtRXhwb3J0c1sncmVhbGxvYyddKShhMCwgYTEpKTtcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiA9IChhMCwgYTEpID0+XG4gICAgICAoX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiA9XG4gICAgICAgIHdhc21FeHBvcnRzWydlbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24nXSkoYTAsIGExKTtcbiAgICB2YXIgX19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUgPSAoYTApID0+XG4gICAgICAoX19lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUgPSB3YXNtRXhwb3J0c1snX2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZSddKShcbiAgICAgICAgYTAsXG4gICAgICApO1xuICAgIHZhciBfX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MgPSAoYTApID0+XG4gICAgICAoX19lbXNjcmlwdGVuX3N0YWNrX2FsbG9jID0gd2FzbUV4cG9ydHNbJ19lbXNjcmlwdGVuX3N0YWNrX2FsbG9jJ10pKGEwKTtcbiAgICB2YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPSAoKSA9PlxuICAgICAgKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50ID1cbiAgICAgICAgd2FzbUV4cG9ydHNbJ2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQnXSkoKTtcblxuICAgIE1vZHVsZVsnd2FzbU1lbW9yeSddID0gd2FzbU1lbW9yeTtcblxuICAgIHZhciBjYWxsZWRSdW47XG4gICAgdmFyIGNhbGxlZFByZXJ1bjtcblxuICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uIHJ1bkNhbGxlcigpIHtcbiAgICAgIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiAgICAgIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYWxsZWRQcmVydW4pIHtcbiAgICAgICAgY2FsbGVkUHJlcnVuID0gMTtcbiAgICAgICAgcHJlUnVuKCk7XG5cbiAgICAgICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgICAgIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgICAgICAgY2FsbGVkUnVuID0gMTtcbiAgICAgICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IDE7XG5cbiAgICAgICAgaWYgKEFCT1JUKSByZXR1cm47XG5cbiAgICAgICAgaW5pdFJ1bnRpbWUoKTtcblxuICAgICAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgICAgIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXT8uKCk7XG5cbiAgICAgICAgcG9zdFJ1bigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTW9kdWxlWydzZXRTdGF0dXMnXSkge1xuICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gTW9kdWxlWydzZXRTdGF0dXMnXSgnJyksIDEpO1xuICAgICAgICAgIGRvUnVuKCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9SdW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICAgICAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcbiAgICAgICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBydW4oKTtcblxuICAgIE1vZHVsZS5ydW5TUUxpdGUzUG9zdExvYWRJbml0ID0gZnVuY3Rpb24gKEVtc2NyaXB0ZW5Nb2R1bGUpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwID0gZnVuY3Rpb24gc3FsaXRlM0FwaUJvb3RzdHJhcChcbiAgICAgICAgYXBpQ29uZmlnID0gZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQ29uZmlnIHx8XG4gICAgICAgICAgc3FsaXRlM0FwaUJvb3RzdHJhcC5kZWZhdWx0Q29uZmlnLFxuICAgICAgKSB7XG4gICAgICAgIGlmIChzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTMpIHtcbiAgICAgICAgICAoc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzLmNvbmZpZyB8fCBjb25zb2xlKS53YXJuKFxuICAgICAgICAgICAgJ3NxbGl0ZTNBcGlCb290c3RyYXAoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuJyxcbiAgICAgICAgICAgICdDb25maWcgYW5kIGV4dGVybmFsIGluaXRpYWxpemVycyBhcmUgaWdub3JlZCBvbiBjYWxscyBhZnRlciB0aGUgZmlyc3QuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4cG9ydHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1lbW9yeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmlnSW50RW5hYmxlZDogKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEhTW9kdWxlLkhFQVBVNjQpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAhIWdsb2JhbFRoaXMuQmlnSW50NjRBcnJheTtcbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICBkZWJ1ZzogY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpLFxuICAgICAgICAgICAgd2FybjogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICBlcnJvcjogY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLFxuICAgICAgICAgICAgbG9nOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgICAgICAgICAgd2FzbWZzT3Bmc0RpcjogJy9vcGZzJyxcblxuICAgICAgICAgICAgdXNlU3RkQWxsb2M6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBpQ29uZmlnIHx8IHt9LFxuICAgICAgICApO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ21hbGxvYycgOiAnc3FsaXRlM19tYWxsb2MnLFxuICAgICAgICAgICAgZGVhbGxvY0V4cG9ydE5hbWU6IGNvbmZpZy51c2VTdGRBbGxvYyA/ICdmcmVlJyA6ICdzcWxpdGUzX2ZyZWUnLFxuICAgICAgICAgICAgcmVhbGxvY0V4cG9ydE5hbWU6IGNvbmZpZy51c2VTdGRBbGxvY1xuICAgICAgICAgICAgICA/ICdyZWFsbG9jJ1xuICAgICAgICAgICAgICA6ICdzcWxpdGUzX3JlYWxsb2MnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICApO1xuXG4gICAgICAgIFsnZXhwb3J0cycsICdtZW1vcnknLCAnd2FzbWZzT3Bmc0RpciddLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbmZpZ1trXSkge1xuICAgICAgICAgICAgY29uZmlnW2tdID0gY29uZmlnW2tdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQ29uZmlnO1xuICAgICAgICBkZWxldGUgc3FsaXRlM0FwaUJvb3RzdHJhcC5kZWZhdWx0Q29uZmlnO1xuXG4gICAgICAgIGNvbnN0IGNhcGkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHdhc20gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IF9fcmNTdHIgPSAocmMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGNhcGkuc3FsaXRlM19qc19yY19zdHIgJiYgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpIHx8XG4gICAgICAgICAgICAnVW5rbm93biByZXN1bHQgY29kZSAjJyArIHJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2lzSW50ID0gKG4pID0+ICdudW1iZXInID09PSB0eXBlb2YgbiAmJiBuID09PSAobiB8IDApO1xuXG4gICAgICAgIGNsYXNzIFNRTGl0ZTNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKF9faXNJbnQoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICByYyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcihfX3JjU3RyKGFyZ3NbMF0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmNTdHIgPSBfX3JjU3RyKHJjKTtcbiAgICAgICAgICAgICAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIocmNTdHIsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHJjU3RyICsgJzonO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgyID09PSBhcmdzLmxlbmd0aCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdENvZGUgPSByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTUUxpdGUzRXJyb3InO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFNRTGl0ZTNFcnJvci50b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgU1FMaXRlM0Vycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3NzMyA9IFNRTGl0ZTNFcnJvci50b3NzO1xuXG4gICAgICAgIGlmIChjb25maWcud2FzbWZzT3Bmc0RpciAmJiAhL15cXC9bXi9dKyQvLnRlc3QoY29uZmlnLndhc21mc09wZnNEaXIpKSB7XG4gICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICBcImNvbmZpZy53YXNtZnNPcGZzRGlyIG11c3QgYmUgZmFsc3kgb3IgaW4gdGhlIGZvcm0gJy9kaXItbmFtZScuXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzSW50MzIgPSAobikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnYmlnaW50JyAhPT0gdHlwZW9mIG4gJiZcbiAgICAgICAgICAgICEhKG4gPT09IChuIHwgMCkgJiYgbiA8PSAyMTQ3NDgzNjQ3ICYmIG4gPj0gLTIxNDc0ODM2NDgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaWdJbnRGaXRzNjQgPSBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBpZiAoIWYuX21heCkge1xuICAgICAgICAgICAgZi5fbWF4ID0gQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICAgICAgICAgIGYuX21pbiA9IH5mLl9tYXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiID49IGYuX21pbiAmJiBiIDw9IGYuX21heDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBiaWdJbnRGaXRzMzIgPSAoYikgPT4gYiA+PSAtMHg3ZmZmZmZmZm4gLSAxbiAmJiBiIDw9IDB4N2ZmZmZmZmZuO1xuXG4gICAgICAgIGNvbnN0IGJpZ0ludEZpdHNEb3VibGUgPSBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBpZiAoIWYuX21pbikge1xuICAgICAgICAgICAgZi5fbWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBmLl9tYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGIgPj0gZi5fbWluICYmIGIgPD0gZi5fbWF4O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzVHlwZWRBcnJheSA9ICh2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHYgJiYgdi5jb25zdHJ1Y3RvciAmJiBpc0ludDMyKHYuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQpXG4gICAgICAgICAgICA/IHZcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19TQUIgPVxuICAgICAgICAgICd1bmRlZmluZWQnID09PSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIDogU2hhcmVkQXJyYXlCdWZmZXI7XG5cbiAgICAgICAgY29uc3QgaXNTaGFyZWRUeXBlZEFycmF5ID0gKGFUeXBlZEFycmF5KSA9PlxuICAgICAgICAgIGFUeXBlZEFycmF5LmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCO1xuXG4gICAgICAgIGNvbnN0IHR5cGVkQXJyYXlQYXJ0ID0gKGFUeXBlZEFycmF5LCBiZWdpbiwgZW5kKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzU2hhcmVkVHlwZWRBcnJheShhVHlwZWRBcnJheSlcbiAgICAgICAgICAgID8gYVR5cGVkQXJyYXkuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgIDogYVR5cGVkQXJyYXkuc3ViYXJyYXkoYmVnaW4sIGVuZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaXNCaW5kYWJsZVR5cGVkQXJyYXkgPSAodikgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB2ICYmXG4gICAgICAgICAgICAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpc1NRTGFibGVUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdiAmJlxuICAgICAgICAgICAgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5ID0gKHYpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNCaW5kYWJsZVR5cGVkQXJyYXkodikgfHxcbiAgICAgICAgICAgIHRvc3MzKCdWYWx1ZSBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgVHlwZWRBcnJheSB0eXBlLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcblxuICAgICAgICBjb25zdCB0eXBlZEFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAodHlwZWRBcnJheSwgYmVnaW4sIGVuZCkge1xuICAgICAgICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodHlwZWRBcnJheVBhcnQodHlwZWRBcnJheSwgYmVnaW4sIGVuZCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZsZXhpYmxlU3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBpZiAoaXNTUUxhYmxlVHlwZWRBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlUb1N0cmluZyhcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkodikgOiB2LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiB2LmpvaW4oJycpO1xuICAgICAgICAgIGVsc2UgaWYgKHdhc20uaXNQdHIodikpIHYgPSB3YXNtLmNzdHJUb0pzKHYpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsYXNzIFdhc21BbGxvY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICgyID09PSBhcmdzLmxlbmd0aCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1cGVyKCdBbGxvY2F0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0Q29kZSA9IGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1dhc21BbGxvY0Vycm9yJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgV2FzbUFsbG9jRXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjYXBpLCB7XG4gICAgICAgICAgc3FsaXRlM19iaW5kX2Jsb2I6IHVuZGVmaW5lZCxcblxuICAgICAgICAgIHNxbGl0ZTNfYmluZF90ZXh0OiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MjogKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbjogKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uOiAoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfcHJlcGFyZV92MzogKFxuICAgICAgICAgICAgZGJQdHIsXG4gICAgICAgICAgICBzcWwsXG4gICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgc3RtdFB0clB0cixcbiAgICAgICAgICAgIHN0clB0clB0cixcbiAgICAgICAgICApID0+IHt9LFxuXG4gICAgICAgICAgc3FsaXRlM19wcmVwYXJlX3YyOiAoXG4gICAgICAgICAgICBkYlB0cixcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHNxbEJ5dGVMZW4sXG4gICAgICAgICAgICBzdG10UHRyUHRyLFxuICAgICAgICAgICAgc3RyUHRyUHRyLFxuICAgICAgICAgICkgPT4ge30sXG5cbiAgICAgICAgICBzcWxpdGUzX2V4ZWM6IChwRGIsIHNxbCwgY2FsbGJhY2ssIHBWb2lkLCBwRXJyTXNnKSA9PiB7fSxcblxuICAgICAgICAgIHNxbGl0ZTNfcmFuZG9tbmVzczogKG4sIG91dFB0cikgPT4ge30sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHV0aWwgPSB7XG4gICAgICAgICAgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5LFxuICAgICAgICAgIGZsZXhpYmxlU3RyaW5nLFxuICAgICAgICAgIGJpZ0ludEZpdHMzMixcbiAgICAgICAgICBiaWdJbnRGaXRzNjQsXG4gICAgICAgICAgYmlnSW50Rml0c0RvdWJsZSxcbiAgICAgICAgICBpc0JpbmRhYmxlVHlwZWRBcnJheSxcbiAgICAgICAgICBpc0ludDMyLFxuICAgICAgICAgIGlzU1FMYWJsZVR5cGVkQXJyYXksXG4gICAgICAgICAgaXNUeXBlZEFycmF5LFxuICAgICAgICAgIHR5cGVkQXJyYXlUb1N0cmluZyxcbiAgICAgICAgICBpc1VJVGhyZWFkOiAoKSA9PlxuICAgICAgICAgICAgZ2xvYmFsVGhpcy53aW5kb3cgPT09IGdsb2JhbFRoaXMgJiYgISFnbG9iYWxUaGlzLmRvY3VtZW50LFxuXG4gICAgICAgICAgaXNTaGFyZWRUeXBlZEFycmF5LFxuICAgICAgICAgIHRvc3M6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9zczMsXG4gICAgICAgICAgdHlwZWRBcnJheVBhcnQsXG5cbiAgICAgICAgICBhZmZpcm1EYkhlYWRlcjogZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSAnU1FMaXRlIGZvcm1hdCAzJztcbiAgICAgICAgICAgIGlmIChoZWFkZXIubGVuZ3RoID4gYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICB0b3NzMygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXIuY2hhckNvZGVBdChpKSAhPT0gYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0b3NzMygnSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhZmZpcm1Jc0RiOiBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4gPCA1MTIgfHwgbiAlIDUxMiAhPT0gMCkge1xuICAgICAgICAgICAgICB0b3NzMygnQnl0ZSBhcnJheSBzaXplJywgbiwgJ2lzIGludmFsaWQgZm9yIGFuIFNRTGl0ZTMgZGIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGJ5dGVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24od2FzbSwge1xuICAgICAgICAgIHB0clNpemVvZjogY29uZmlnLndhc21QdHJTaXplb2YgfHwgNCxcblxuICAgICAgICAgIHB0cklSOiBjb25maWcud2FzbVB0cklSIHx8ICdpMzInLFxuXG4gICAgICAgICAgYmlnSW50RW5hYmxlZDogISFjb25maWcuYmlnSW50RW5hYmxlZCxcblxuICAgICAgICAgIGV4cG9ydHM6XG4gICAgICAgICAgICBjb25maWcuZXhwb3J0cyB8fFxuICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgQVBJIGNvbmZpZy5leHBvcnRzIChXQVNNIG1vZHVsZSBleHBvcnRzKS4nKSxcblxuICAgICAgICAgIG1lbW9yeTpcbiAgICAgICAgICAgIGNvbmZpZy5tZW1vcnkgfHxcbiAgICAgICAgICAgIGNvbmZpZy5leHBvcnRzWydtZW1vcnknXSB8fFxuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICdBUEkgY29uZmlnIG9iamVjdCByZXF1aXJlcyBhIFdlYkFzc2VtYmx5Lk1lbW9yeSBvYmplY3QnLFxuICAgICAgICAgICAgICAnaW4gZWl0aGVyIGNvbmZpZy5leHBvcnRzLm1lbW9yeSAoZXhwb3J0ZWQpJyxcbiAgICAgICAgICAgICAgJ29yIGNvbmZpZy5tZW1vcnkgKGltcG9ydGVkKS4nLFxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICByZWFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICBkZWFsbG9jOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChzcmNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgaWYgKHNyY1R5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgc3JjVHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHNyY1R5cGVkQXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXkoc3JjVHlwZWRBcnJheSk7XG4gICAgICAgICAgY29uc3QgcFJldCA9IHdhc20uYWxsb2Moc3JjVHlwZWRBcnJheS5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgIHdhc21cbiAgICAgICAgICAgIC5oZWFwRm9yU2l6ZShzcmNUeXBlZEFycmF5LmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLnNldChzcmNUeXBlZEFycmF5LmJ5dGVMZW5ndGggPyBzcmNUeXBlZEFycmF5IDogWzBdLCBwUmV0KTtcbiAgICAgICAgICByZXR1cm4gcFJldDtcbiAgICAgICAgfTtcblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qga2V5QWxsb2MgPSBjb25maWcuYWxsb2NFeHBvcnROYW1lLFxuICAgICAgICAgICAga2V5RGVhbGxvYyA9IGNvbmZpZy5kZWFsbG9jRXhwb3J0TmFtZSxcbiAgICAgICAgICAgIGtleVJlYWxsb2MgPSBjb25maWcucmVhbGxvY0V4cG9ydE5hbWU7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgW2tleUFsbG9jLCBrZXlEZWFsbG9jLCBrZXlSZWFsbG9jXSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IHdhc20uZXhwb3J0c1trZXldO1xuICAgICAgICAgICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgICAgICAgICAgdG9zczMoJ01pc3NpbmcgcmVxdWlyZWQgZXhwb3J0c1snLCBrZXksICddIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhc20uYWxsb2MgPSBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGYuaW1wbChuKSB8fFxuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKCdGYWlsZWQgdG8gYWxsb2NhdGUnLCBuLCAnIGJ5dGVzLicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FzbS5hbGxvYy5pbXBsID0gd2FzbS5leHBvcnRzW2tleUFsbG9jXTtcbiAgICAgICAgICB3YXNtLnJlYWxsb2MgPSBmdW5jdGlvbiBmKG0sIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG0yID0gZi5pbXBsKG0sIG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgPyBtMiB8fCBXYXNtQWxsb2NFcnJvci50b3NzKCdGYWlsZWQgdG8gcmVhbGxvY2F0ZScsIG4sICcgYnl0ZXMuJylcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FzbS5yZWFsbG9jLmltcGwgPSB3YXNtLmV4cG9ydHNba2V5UmVhbGxvY107XG4gICAgICAgICAgd2FzbS5kZWFsbG9jID0gd2FzbS5leHBvcnRzW2tleURlYWxsb2NdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS5jb21waWxlT3B0aW9uVXNlZCA9IGZ1bmN0aW9uIGYob3B0TmFtZSkge1xuICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGYuX3Jlc3VsdCkgcmV0dXJuIGYuX3Jlc3VsdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFmLl9vcHQpIHtcbiAgICAgICAgICAgICAgZi5fcnggPSAvXihbXj1dKyk9KC4rKS87XG4gICAgICAgICAgICAgIGYuX3J4SW50ID0gL14tP1xcZCskLztcbiAgICAgICAgICAgICAgZi5fb3B0ID0gZnVuY3Rpb24gKG9wdCwgcnYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZi5fcnguZXhlYyhvcHQpO1xuICAgICAgICAgICAgICAgIHJ2WzBdID0gbSA/IG1bMV0gOiBvcHQ7XG4gICAgICAgICAgICAgICAgcnZbMV0gPSBtID8gKGYuX3J4SW50LnRlc3QobVsyXSkgPyArbVsyXSA6IG1bMl0pIDogdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJjID0ge30sXG4gICAgICAgICAgICAgIG92ID0gWzAsIDBdO1xuICAgICAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgICBrO1xuICAgICAgICAgICAgd2hpbGUgKChrID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0KGkrKykpKSB7XG4gICAgICAgICAgICAgIGYuX29wdChrLCBvdik7XG4gICAgICAgICAgICAgIHJjW292WzBdXSA9IG92WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChmLl9yZXN1bHQgPSByYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHt9O1xuICAgICAgICAgICAgb3B0TmFtZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICAgIHJjW3ZdID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBvcHROYW1lKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHROYW1lKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIG9wdE5hbWVba10gPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKGspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0TmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0TmFtZVxuICAgICAgICAgICAgPyAhIWNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQob3B0TmFtZSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2FzbS5wc3RhY2sgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICByZXN0b3JlOiB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVzdG9yZSxcblxuICAgICAgICAgIGFsbG9jOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbiAmJiAhKG4gPSB3YXNtLnNpemVvZklSKG4pKSkge1xuICAgICAgICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIHZhbHVlIGZvciBwc3RhY2suYWxsb2MoJyxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fcHN0YWNrX2FsbG9jKG4pIHx8XG4gICAgICAgICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgJ0NvdWxkIG5vdCBhbGxvY2F0ZScsXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAnYnl0ZXMgZnJvbSB0aGUgcHN0YWNrLicsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFsbG9jQ2h1bmtzOiBmdW5jdGlvbiAobiwgc3opIHtcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHN6ICYmICEoc3ogPSB3YXNtLnNpemVvZklSKHN6KSkpIHtcbiAgICAgICAgICAgICAgV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAnSW52YWxpZCBzaXplIHZhbHVlIGZvciBhbGxvY0NodW5rcygnLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZW0gPSB3YXNtLnBzdGFjay5hbGxvYyhuICogc3opO1xuICAgICAgICAgICAgY29uc3QgcmMgPSBbXTtcbiAgICAgICAgICAgIGxldCBpID0gMCxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgKytpLCBvZmZzZXQgKz0gc3opIHJjLnB1c2gobWVtICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYWxsb2NQdHI6IChuID0gMSwgc2FmZVB0clNpemUgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gMSA9PT0gblxuICAgICAgICAgICAgICA/IHdhc20ucHN0YWNrLmFsbG9jKHNhZmVQdHJTaXplID8gOCA6IHdhc20ucHRyU2l6ZW9mKVxuICAgICAgICAgICAgICA6IHdhc20ucHN0YWNrLmFsbG9jQ2h1bmtzKG4sIHNhZmVQdHJTaXplID8gOCA6IHdhc20ucHRyU2l6ZW9mKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2FsbDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrUG9zID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBmKHNxbGl0ZTMpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgd2FzbS5wc3RhY2sucmVzdG9yZShzdGFja1Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdhc20ucHN0YWNrLCB7XG4gICAgICAgICAgcG9pbnRlcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGl0ZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGVhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fcHN0YWNrX3B0cixcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcXVvdGE6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpdGVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX3BzdGFja19xdW90YSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcmVtYWluaW5nOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgaXRlcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVtYWluaW5nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19yYW5kb21uZXNzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAxID09PSBhcmdzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdXRpbC5pc1R5cGVkQXJyYXkoYXJnc1swXSkgJiZcbiAgICAgICAgICAgIDEgPT09IGFyZ3NbMF0uQllURVNfUEVSX0VMRU1FTlRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmICgwID09PSB0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3MoMCwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiB0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBuID0gdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBjb25zdCByID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcztcbiAgICAgICAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgICAgICAgIGNvbnN0IG5BbGxvYyA9IG4gPCA1MTIgPyBuIDogNTEyO1xuICAgICAgICAgICAgICBjb25zdCBwdHIgPSB3YXNtLnBzdGFjay5hbGxvYyhuQWxsb2MpO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgaiA9IG4gPiBuQWxsb2MgPyBuQWxsb2MgOiBuO1xuICAgICAgICAgICAgICAgIHIoaiwgcHRyKTtcbiAgICAgICAgICAgICAgICB0YS5zZXQodHlwZWRBcnJheVBhcnQoaGVhcCwgcHRyLCBwdHIgKyBqKSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBuIC09IGo7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGo7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKG4gPiAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnSGlnaGx5IHVuZXhwZWN0ZWQgKGFuZCBpZ25vcmVkISkgJyArXG4gICAgICAgICAgICAgICAgICAnZXhjZXB0aW9uIGluIHNxbGl0ZTNfcmFuZG9tbmVzcygpOicsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBfX3dhc21mc09wZnNEaXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3dhc21mc19vcGZzX2RpciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBfX3dhc21mc09wZnNEaXIpIHJldHVybiBfX3dhc21mc09wZnNEaXI7XG5cbiAgICAgICAgICBjb25zdCBwZGlyID0gY29uZmlnLndhc21mc09wZnNEaXI7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXBkaXIgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9fd2FzbWZzT3Bmc0RpciA9ICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcGRpciAmJlxuICAgICAgICAgICAgICAwID09PVxuICAgICAgICAgICAgICAgIHdhc20ueENhbGxXcmFwcGVkKFxuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfX3dhc21faW5pdF93YXNtZnMnLFxuICAgICAgICAgICAgICAgICAgJ2kzMicsXG4gICAgICAgICAgICAgICAgICBbJ3N0cmluZyddLFxuICAgICAgICAgICAgICAgICAgcGRpcixcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChfX3dhc21mc09wZnNEaXIgPSBwZGlyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoX193YXNtZnNPcGZzRGlyID0gJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfd2FzbWZzX2ZpbGVuYW1lX2lzX3BlcnNpc3RlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGNvbnN0IHAgPSBjYXBpLnNxbGl0ZTNfd2FzbWZzX29wZnNfZGlyKCk7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgbmFtZSA/IG5hbWUuc3RhcnRzV2l0aChwICsgJy8nKSA6IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl91c2VzX3ZmcyA9IGZ1bmN0aW9uIChwRGIsIHZmc05hbWUsIGRiTmFtZSA9IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcEsgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXBLKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICghcERiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwSyA9PT0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKDApID8gcEsgOiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBwSyA9PT0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIsIGRiTmFtZSkgPyBwSyA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3Zmc19saXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICAgICAgbGV0IHBWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoMCk7XG4gICAgICAgICAgd2hpbGUgKHBWZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9WZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwVmZzKTtcbiAgICAgICAgICAgIHJjLnB1c2god2FzbS5jc3RyVG9KcyhvVmZzLiR6TmFtZSkpO1xuICAgICAgICAgICAgcFZmcyA9IG9WZnMuJHBOZXh0O1xuICAgICAgICAgICAgb1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfZGJfZXhwb3J0ID0gZnVuY3Rpb24gKHBEYiwgc2NoZW1hID0gMCkge1xuICAgICAgICAgIHBEYiA9IHdhc20ueFdyYXAudGVzdENvbnZlcnRBcmcoJ3NxbGl0ZTMqJywgcERiKTtcbiAgICAgICAgICBpZiAoIXBEYikgdG9zczMoJ0ludmFsaWQgc3FsaXRlMyogYXJndW1lbnQuJyk7XG4gICAgICAgICAgaWYgKCF3YXNtLmJpZ0ludEVuYWJsZWQpIHRvc3MzKCdCaWdJbnQ2NCBzdXBwb3J0IGlzIG5vdCBlbmFibGVkLicpO1xuICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICBsZXQgcE91dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFNpemUgPSB3YXNtLnNjb3BlZEFsbG9jKDggKyB3YXNtLnB0clNpemVvZik7XG4gICAgICAgICAgICBjb25zdCBwcE91dCA9IHBTaXplICsgODtcblxuICAgICAgICAgICAgY29uc3QgelNjaGVtYSA9IHNjaGVtYVxuICAgICAgICAgICAgICA/IHdhc20uaXNQdHIoc2NoZW1hKVxuICAgICAgICAgICAgICAgID8gc2NoZW1hXG4gICAgICAgICAgICAgICAgOiB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZygnJyArIHNjaGVtYSlcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgbGV0IHJjID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplKFxuICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgIHpTY2hlbWEsXG4gICAgICAgICAgICAgIHBwT3V0LFxuICAgICAgICAgICAgICBwU2l6ZSxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmMpIHtcbiAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgJ0RhdGFiYXNlIHNlcmlhbGl6YXRpb24gZmFpbGVkIHdpdGggY29kZScsXG4gICAgICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBPdXQgPSB3YXNtLnBlZWtQdHIocHBPdXQpO1xuICAgICAgICAgICAgY29uc3Qgbk91dCA9IHdhc20ucGVlayhwU2l6ZSwgJ2k2NCcpO1xuICAgICAgICAgICAgcmMgPSBuT3V0XG4gICAgICAgICAgICAgID8gd2FzbS5oZWFwOHUoKS5zbGljZShwT3V0LCBwT3V0ICsgTnVtYmVyKG5PdXQpKVxuICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChwT3V0KSB3YXNtLmV4cG9ydHMuc3FsaXRlM19mcmVlKHBPdXQpO1xuICAgICAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl92ZnMgPSAoZGJQb2ludGVyLCBkYk5hbWUgPSAwKSA9PlxuICAgICAgICAgIHV0aWwuc3FsaXRlM19fd2FzbV9kYl92ZnMoZGJQb2ludGVyLCBkYk5hbWUpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19qc19hZ2dyZWdhdGVfY29udGV4dCA9IChwQ3R4LCBuKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dChwQ3R4LCBuKSB8fFxuICAgICAgICAgICAgKG5cbiAgICAgICAgICAgICAgPyBXYXNtQWxsb2NFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBhbGxvY2F0ZScsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgJ2J5dGVzIGZvciBzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0KCknLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAwKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBkYXRhLCBkYXRhTGVuKSB7XG4gICAgICAgICAgbGV0IHBEYXRhO1xuICAgICAgICAgIGlmIChkYXRhICYmIHdhc20uaXNQdHIoZGF0YSkpIHtcbiAgICAgICAgICAgIHBEYXRhID0gZGF0YTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcERhdGEgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMgfHwgIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuIDwgMCkge1xuICAgICAgICAgICAgICBkYXRhTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgMm5kIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlKCkuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuIDwgMCkge1xuICAgICAgICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAnSW52YWxpZCAzcmQgYXJndW1lbnQgZm9yIHNxbGl0ZTNfanNfcG9zaXhfY3JlYXRlX2ZpbGUoKS4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmMgPSB1dGlsLnNxbGl0ZTNfX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICBwRGF0YSxcbiAgICAgICAgICAgICAgZGF0YUxlbixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmMpXG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdDcmVhdGlvbiBvZiBmaWxlIGZhaWxlZCB3aXRoIHNxbGl0ZTMgcmVzdWx0IGNvZGUnLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHZmcyxcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRhdGFMZW4sXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbmZpZy53YXJuKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkgaXMgZGVwcmVjYXRlZCBhbmQnLFxuICAgICAgICAgICAgJ3Nob3VsZCBiZSBhdm9pZGVkIGJlY2F1c2UgaXQgY2FuIGxlYWQgdG8gQy1sZXZlbCBjcmFzaGVzLicsXG4gICAgICAgICAgICAnU2VlIGl0cyBkb2N1bWVudGF0aW9uIGZvciBhbHRlcm5hdGl2ZSBvcHRpb25zLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcERhdGE7XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGRhdGEpKSB7XG4gICAgICAgICAgICAgIHBEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICBwRGF0YSA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCA0IHx8XG4gICAgICAgICAgICAgICAgIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fFxuICAgICAgICAgICAgICAgIGRhdGFMZW4gPCAwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRhdGFMZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBEYXRhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbiA8IDApIHtcbiAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgJ0ludmFsaWQgNHRoIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSB1dGlsLnNxbGl0ZTNfX3dhc21fdmZzX2NyZWF0ZV9maWxlKFxuICAgICAgICAgICAgICB2ZnMsXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICBwRGF0YSxcbiAgICAgICAgICAgICAgZGF0YUxlbixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmMpXG4gICAgICAgICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgICdDcmVhdGlvbiBvZiBmaWxlIGZhaWxlZCB3aXRoIHNxbGl0ZTMgcmVzdWx0IGNvZGUnLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfanNfc3FsX3RvX3N0cmluZyA9IChzcWwpID0+IHtcbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBzcWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzcWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHggPSBmbGV4aWJsZVN0cmluZyh2KTtcbiAgICAgICAgICByZXR1cm4geCA9PT0gdiA/IHVuZGVmaW5lZCA6IHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHV0aWwuaXNVSVRocmVhZCgpKSB7XG4gICAgICAgICAgY29uc3QgX19rdnZmc0luZm8gPSBmdW5jdGlvbiAod2hpY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHJjID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHJjLnByZWZpeCA9ICdrdnZmcy0nICsgd2hpY2g7XG4gICAgICAgICAgICByYy5zdG9yZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICgnc2Vzc2lvbicgPT09IHdoaWNoIHx8ICcnID09PSB3aGljaClcbiAgICAgICAgICAgICAgcmMuc3RvcmVzLnB1c2goZ2xvYmFsVGhpcy5zZXNzaW9uU3RvcmFnZSk7XG4gICAgICAgICAgICBpZiAoJ2xvY2FsJyA9PT0gd2hpY2ggfHwgJycgPT09IHdoaWNoKVxuICAgICAgICAgICAgICByYy5zdG9yZXMucHVzaChnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19rdnZmc19jbGVhciA9IGZ1bmN0aW9uICh3aGljaCA9ICcnKSB7XG4gICAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgICAgY29uc3Qga3ZpbmZvID0gX19rdnZmc0luZm8od2hpY2gpO1xuICAgICAgICAgICAga3ZpbmZvLnN0b3Jlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvUm0gPSBbXTtcbiAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHMua2V5KGkpO1xuICAgICAgICAgICAgICAgIGlmIChrLnN0YXJ0c1dpdGgoa3ZpbmZvLnByZWZpeCkpIHRvUm0ucHVzaChrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b1JtLmZvckVhY2goKGtrKSA9PiBzLnJlbW92ZUl0ZW0oa2spKTtcbiAgICAgICAgICAgICAgcmMgKz0gdG9SbS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX2t2dmZzX3NpemUgPSBmdW5jdGlvbiAod2hpY2ggPSAnJykge1xuICAgICAgICAgICAgbGV0IHN6ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGt2aW5mbyA9IF9fa3Z2ZnNJbmZvKHdoaWNoKTtcbiAgICAgICAgICAgIGt2aW5mby5zdG9yZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gcy5rZXkoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGsuc3RhcnRzV2l0aChrdmluZm8ucHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgc3ogKz0gay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBzeiArPSBzLmdldEl0ZW0oaykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3ogKiAyO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfY29uZmlnID0gZnVuY3Rpb24gKHBEYiwgb3AsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9GS0VZOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfVFJJR0dFUjpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZUUzNfVE9LRU5JWkVSOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfTE9BRF9FWFRFTlNJT046XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX05PX0NLUFRfT05fQ0xPU0U6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9RUFNHOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19UUklHR0VSX0VRUDpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfUkVTRVRfREFUQUJBU0U6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0RFRkVOU0lWRTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfV1JJVEFCTEVfU0NIRU1BOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19MRUdBQ1lfQUxURVJfVEFCTEU6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0RRU19ETUw6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0RRU19EREw6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9WSUVXOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19MRUdBQ1lfRklMRV9GT1JNQVQ6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1RSVVNURURfU0NIRU1BOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19TVE1UX1NDQU5TVEFUVVM6XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1JFVkVSU0VfU0NBTk9SREVSOlxuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfQVRUQUNIX0NSRUFURTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0FUVEFDSF9XUklURTpcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0NPTU1FTlRTOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMuaXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwID0gd2FzbS54V3JhcCgnc3FsaXRlM19fd2FzbV9kYl9jb25maWdfaXAnLCAnaW50JywgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXAocERiLCBvcCwgYXJnc1swXSwgYXJnc1sxXSB8fCAwKTtcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTE9PS0FTSURFOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMucGlpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWkgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19waWknLCAnaW50JywgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5waWkocERiLCBvcCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX01BSU5EQk5BTUU6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gd2FzbS54V3JhcCgnc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcycsICdpbnQnLCBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAnc3RyaW5nOnN0YXRpYycsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucyhwRGIsIG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIHBWYWwsXG4gICAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnQgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgYXJnO1xuICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfdHlwZShwVmFsKTtcbiAgICAgICAgICBzd2l0Y2ggKHZhbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfSU5URUdFUjpcbiAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9pbnQ2NChwVmFsKTtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5iaWdJbnRGaXRzRG91YmxlKGFyZykpIGFyZyA9IE51bWJlcihhcmcpO1xuICAgICAgICAgICAgICB9IGVsc2UgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2RvdWJsZShwVmFsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0ZMT0FUOlxuICAgICAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfZG91YmxlKHBWYWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfVEVYVDpcbiAgICAgICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX3RleHQocFZhbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9CTE9COiB7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSBjYXBpLnNxbGl0ZTNfdmFsdWVfYnl0ZXMocFZhbCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBCbG9iID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2Jsb2IocFZhbCk7XG4gICAgICAgICAgICAgIGlmIChuICYmICFwQmxvYilcbiAgICAgICAgICAgICAgICBzcWxpdGUzLldhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgICAnQ2Fubm90IGFsbG9jYXRlIG1lbW9yeSBmb3IgYmxvYiBhcmd1bWVudCBvZicsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgJ2J5dGUocyknLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGFyZyA9IG4gPyB3YXNtLmhlYXA4dSgpLnNsaWNlKHBCbG9iLCBwQmxvYiArIE51bWJlcihuKSkgOiBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfTlVMTDpcbiAgICAgICAgICAgICAgYXJnID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodGhyb3dJZkNhbm5vdENvbnZlcnQpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU01BVENILFxuICAgICAgICAgICAgICAgICAgJ1VuaGFuZGxlZCBzcWxpdGUzX3ZhbHVlX3R5cGUoKTonLFxuICAgICAgICAgICAgICAgICAgdmFsVHlwZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGFyZ2MsXG4gICAgICAgICAgcEFyZ3YsXG4gICAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnQgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICBjb25zdCB0Z3QgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgKytpKSB7XG4gICAgICAgICAgICB0Z3QucHVzaChcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKFxuICAgICAgICAgICAgICAgIHdhc20ucGVla1B0cihwQXJndiArIHdhc20ucHRyU2l6ZW9mICogaSksXG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnQsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGd0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMgPSBmdW5jdGlvbiAocEN0eCwgZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgV2FzbUFsbG9jRXJyb3IpIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0ocEN0eCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3IocEN0eCwgJycgKyBlLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanMgPSBmdW5jdGlvbiAocEN0eCwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIHZhbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQocEN0eCwgdmFsID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmJpZ0ludEZpdHMzMih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludChwQ3R4LCBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmJpZ0ludEZpdHNEb3VibGUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9kb3VibGUocEN0eCwgTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodXRpbC5iaWdJbnRGaXRzNjQodmFsKSlcbiAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ2NChwQ3R4LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAnQmlnSW50IHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICB2YWwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAnaXMgdG9vIEJpZ0ludCBmb3IgaW50NjQuJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9zczMoJ0JpZ0ludCB2YWx1ZScsIHZhbC50b1N0cmluZygpLCAnaXMgdG9vIEJpZ0ludC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgICAgICBsZXQgZjtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0ludDMyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGYgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgd2FzbS5iaWdJbnRFbmFibGVkICYmXG4gICAgICAgICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgJiZcbiAgICAgICAgICAgICAgICAgIHV0aWwuYmlnSW50Rml0czY0KEJpZ0ludCh2YWwpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfaW50NjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGYgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2RvdWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZihwQ3R4LCB2YWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh2YWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfdGV4dChwQ3R4LCBwLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9udWxsKHBDdHgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBCbG9iID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KHZhbCk7XG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Jsb2IoXG4gICAgICAgICAgICAgICAgICAgIHBDdHgsXG4gICAgICAgICAgICAgICAgICAgIHBCbG9iLFxuICAgICAgICAgICAgICAgICAgICB2YWwuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgXCJEb24ndCBub3QgaG93IHRvIGhhbmRsZSB0aGlzIFVERiByZXN1bHQgdmFsdWU6XCIsXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsLFxuICAgICAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FwaS5zcWxpdGUzX2NvbHVtbl9qcyA9IGZ1bmN0aW9uIChcbiAgICAgICAgICBwU3RtdCxcbiAgICAgICAgICBpQ29sLFxuICAgICAgICAgIHRocm93SWZDYW5ub3RDb252ZXJ0ID0gdHJ1ZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgdiA9IGNhcGkuc3FsaXRlM19jb2x1bW5fdmFsdWUocFN0bXQsIGlDb2wpO1xuICAgICAgICAgIHJldHVybiAwID09PSB2XG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanModiwgdGhyb3dJZkNhbm5vdENvbnZlcnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbmV3T2xkVmFsdWUgPSBmdW5jdGlvbiAocE9iaiwgaUNvbCwgaW1wbCkge1xuICAgICAgICAgIGltcGwgPSBjYXBpW2ltcGxdO1xuICAgICAgICAgIGlmICghdGhpcy5wdHIpIHRoaXMucHRyID0gd2FzbS5hbGxvY1B0cigpO1xuICAgICAgICAgIGVsc2Ugd2FzbS5wb2tlUHRyKHRoaXMucHRyLCAwKTtcbiAgICAgICAgICBjb25zdCByYyA9IGltcGwocE9iaiwgaUNvbCwgdGhpcy5wdHIpO1xuICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgIHJldHVybiBTUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgcmMsXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1syXSArICcoKSBmYWlsZWQgd2l0aCBjb2RlICcgKyByYyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcHYgPSB3YXNtLnBlZWtQdHIodGhpcy5wdHIpO1xuICAgICAgICAgIHJldHVybiBwdiA/IGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyhwdiwgdHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfcHJldXBkYXRlX25ld19qcyA9IChwRGIsIGlDb2wpID0+XG4gICAgICAgICAgX19uZXdPbGRWYWx1ZShwRGIsIGlDb2wsICdzcWxpdGUzX3ByZXVwZGF0ZV9uZXcnKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfcHJldXBkYXRlX29sZF9qcyA9IChwRGIsIGlDb2wpID0+XG4gICAgICAgICAgX19uZXdPbGRWYWx1ZShwRGIsIGlDb2wsICdzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnKTtcblxuICAgICAgICBjYXBpLnNxbGl0ZTNjaGFuZ2VzZXRfbmV3X2pzID0gKHBDaGFuZ2VzZXRJdGVyLCBpQ29sKSA9PlxuICAgICAgICAgIF9fbmV3T2xkVmFsdWUocENoYW5nZXNldEl0ZXIsIGlDb2wsICdzcWxpdGUzY2hhbmdlc2V0X25ldycpO1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM2NoYW5nZXNldF9vbGRfanMgPSAocENoYW5nZXNldEl0ZXIsIGlDb2wpID0+XG4gICAgICAgICAgX19uZXdPbGRWYWx1ZShwQ2hhbmdlc2V0SXRlciwgaUNvbCwgJ3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJyk7XG5cbiAgICAgICAgY29uc3Qgc3FsaXRlMyA9IHtcbiAgICAgICAgICBXYXNtQWxsb2NFcnJvcjogV2FzbUFsbG9jRXJyb3IsXG4gICAgICAgICAgU1FMaXRlM0Vycm9yOiBTUUxpdGUzRXJyb3IsXG4gICAgICAgICAgY2FwaSxcbiAgICAgICAgICB1dGlsLFxuICAgICAgICAgIHdhc20sXG4gICAgICAgICAgY29uZmlnLFxuXG4gICAgICAgICAgdmVyc2lvbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgICAgICAgIGNsaWVudDogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgYXN5bmNQb3N0SW5pdDogYXN5bmMgZnVuY3Rpb24gZmYoKSB7XG4gICAgICAgICAgICBpZiAoZmYuaXNSZWFkeSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBmZi5pc1JlYWR5O1xuICAgICAgICAgICAgbGV0IGxpYSA9IHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzQXN5bmM7XG4gICAgICAgICAgICBkZWxldGUgc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYztcbiAgICAgICAgICAgIGNvbnN0IHBvc3RJbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXNxbGl0ZTMuX19pc1VuZGVyVGVzdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzLnV0aWw7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgc3FsaXRlMy5TdHJ1Y3RCaW5kZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNxbGl0ZTM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2F0Y2hlciA9IChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbmZpZy5lcnJvcignYW4gYXN5bmMgc3FsaXRlMyBpbml0aWFsaXplciBmYWlsZWQ6JywgZSk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFsaWEgfHwgIWxpYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChmZi5pc1JlYWR5ID0gcG9zdEluaXQoKS5jYXRjaChjYXRjaGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaWEgPSBsaWEubWFwKChmKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBmIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhc3luYyAoeCkgPT4gZihzcWxpdGUzKSA6IGY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpYS5wdXNoKHBvc3RJbml0KTtcbiAgICAgICAgICAgIGxldCBwID0gUHJvbWlzZS5yZXNvbHZlKHNxbGl0ZTMpO1xuICAgICAgICAgICAgd2hpbGUgKGxpYS5sZW5ndGgpIHAgPSBwLnRoZW4obGlhLnNoaWZ0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIChmZi5pc1JlYWR5ID0gcC5jYXRjaChjYXRjaGVyKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNjcmlwdEluZm86IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgICAgICBmKHNxbGl0ZTMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignc3FsaXRlMyBib290c3RyYXAgaW5pdGlhbGl6ZXIgdGhyZXc6JywgZSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnM7XG4gICAgICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gICAgICAgIHJldHVybiBzcWxpdGUzO1xuICAgICAgfTtcblxuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycyA9IFtdO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzQXN5bmMgPSBbXTtcblxuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmRlZmF1bHRDb25maWcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMyA9IHVuZGVmaW5lZDtcblxuICAgICAgZ2xvYmFsVGhpcy5XaFdhc21VdGlsSW5zdGFsbGVyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRhcmdldC5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgdGFyZ2V0LmJpZ0ludEVuYWJsZWQgPSAhIWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0YXJnZXQuZXhwb3J0cykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdleHBvcnRzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gdGFyZ2V0Lmluc3RhbmNlICYmIHRhcmdldC5pbnN0YW5jZS5leHBvcnRzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHRySVIgPSB0YXJnZXQucG9pbnRlcklSIHx8ICdpMzInO1xuICAgICAgICBjb25zdCBwdHJTaXplb2YgPSAodGFyZ2V0LnB0clNpemVvZiA9XG4gICAgICAgICAgJ2kzMicgPT09IHB0cklSXG4gICAgICAgICAgICA/IDRcbiAgICAgICAgICAgIDogJ2k2NCcgPT09IHB0cklSXG4gICAgICAgICAgICAgID8gOFxuICAgICAgICAgICAgICA6IHRvc3MoJ1VuaGFuZGxlZCBwdHJTaXplb2Y6JywgcHRySVIpKTtcblxuICAgICAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY2FjaGUuaGVhcFNpemUgPSAwO1xuXG4gICAgICAgIGNhY2hlLm1lbW9yeSA9IG51bGw7XG5cbiAgICAgICAgY2FjaGUuZnJlZUZ1bmNJbmRleGVzID0gW107XG5cbiAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2MgPSBbXTtcblxuICAgICAgICBjYWNoZS51dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBjYWNoZS51dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKTtcblxuICAgICAgICB0YXJnZXQuc2l6ZW9mSVIgPSAobikgPT4ge1xuICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgY2FzZSAnaTgnOlxuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgJ2kxNic6XG4gICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgICAgIGNhc2UgJ2YzMic6XG4gICAgICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgIGNhc2UgJ2Y2NCc6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICByZXR1cm4gcHRyU2l6ZW9mO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICgnJyArIG4pLmVuZHNXaXRoKCcqJykgPyBwdHJTaXplb2YgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhlYXBXcmFwcGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWNhY2hlLm1lbW9yeSkge1xuICAgICAgICAgICAgY2FjaGUubWVtb3J5ID1cbiAgICAgICAgICAgICAgdGFyZ2V0Lm1lbW9yeSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0Lm1lbW9yeVxuICAgICAgICAgICAgICAgIDogdGFyZ2V0LmV4cG9ydHMubWVtb3J5O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGIgPSBjYWNoZS5tZW1vcnkuYnVmZmVyO1xuICAgICAgICAgIGNhY2hlLkhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiAgICAgICAgICBjYWNoZS5IRUFQOFUgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgICAgICBjYWNoZS5IRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiAgICAgICAgICBjYWNoZS5IRUFQMTZVID0gbmV3IFVpbnQxNkFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVAzMlUgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgICAgICAgaWYgKHRhcmdldC5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICBjYWNoZS5IRUFQNjQgPSBuZXcgQmlnSW50NjRBcnJheShiKTtcbiAgICAgICAgICAgIGNhY2hlLkhFQVA2NFUgPSBuZXcgQmlnVWludDY0QXJyYXkoYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhY2hlLkhFQVAzMkYgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLkhFQVA2NEYgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xuICAgICAgICAgIGNhY2hlLmhlYXBTaXplID0gYi5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuaGVhcDggPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQODtcblxuICAgICAgICB0YXJnZXQuaGVhcDh1ID0gKCkgPT4gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuXG4gICAgICAgIHRhcmdldC5oZWFwMTYgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQMTY7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAxNnUgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQMTZVO1xuXG4gICAgICAgIHRhcmdldC5oZWFwMzIgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQMzI7XG5cbiAgICAgICAgdGFyZ2V0LmhlYXAzMnUgPSAoKSA9PiBoZWFwV3JhcHBlcnMoKS5IRUFQMzJVO1xuXG4gICAgICAgIHRhcmdldC5oZWFwRm9yU2l6ZSA9IGZ1bmN0aW9uIChuLCB1bnNpZ25lZCA9IHRydWUpIHtcbiAgICAgICAgICBsZXQgY3RvcjtcbiAgICAgICAgICBjb25zdCBjID1cbiAgICAgICAgICAgIGNhY2hlLm1lbW9yeSAmJiBjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgID8gY2FjaGVcbiAgICAgICAgICAgICAgOiBoZWFwV3JhcHBlcnMoKTtcbiAgICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQODtcbiAgICAgICAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgICAgICAgcmV0dXJuIGMuSEVBUDhVO1xuICAgICAgICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQMTY7XG4gICAgICAgICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQMTZVO1xuICAgICAgICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQMzI7XG4gICAgICAgICAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgICAgICAgICByZXR1cm4gYy5IRUFQMzJVO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVA4VSA6IGMuSEVBUDg7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVAxNlUgOiBjLkhFQVAxNjtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDMyVSA6IGMuSEVBUDMyO1xuICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgaWYgKGMuSEVBUDY0KSByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVA2NFUgOiBjLkhFQVA2NDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gZ2xvYmFsVGhpc1snQmlnVWludDY0QXJyYXknXSkgcmV0dXJuIGMuSEVBUDY0VTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuID09PSBnbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J10pIHJldHVybiBjLkhFQVA2NDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgJ0ludmFsaWQgaGVhcEZvclNpemUoKSBzaXplOiBleHBlY3RpbmcgOCwgMTYsIDMyLCcsXG4gICAgICAgICAgICAnb3IgKGlmIEJpZ0ludCBpcyBlbmFibGVkKSA2NC4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmZ1bmN0aW9uVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5leHBvcnRzLl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmZ1bmN0aW9uRW50cnkgPSBmdW5jdGlvbiAoZnB0cikge1xuICAgICAgICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICAgICAgICByZXR1cm4gZnB0ciA8IGZ0Lmxlbmd0aCA/IGZ0LmdldChmcHRyKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuanNGdW5jVG9XYXNtID0gZnVuY3Rpb24gZihmdW5jLCBzaWcpIHtcbiAgICAgICAgICBpZiAoIWYuXykge1xuICAgICAgICAgICAgZi5fID0ge1xuICAgICAgICAgICAgICBzaWdUeXBlczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICAgICAgaTogJ2kzMicsXG4gICAgICAgICAgICAgICAgcDogJ2kzMicsXG4gICAgICAgICAgICAgICAgUDogJ2kzMicsXG4gICAgICAgICAgICAgICAgczogJ2kzMicsXG4gICAgICAgICAgICAgICAgajogJ2k2NCcsXG4gICAgICAgICAgICAgICAgZjogJ2YzMicsXG4gICAgICAgICAgICAgICAgZDogJ2Y2NCcsXG4gICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgIHR5cGVDb2RlczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICAgICAgZjY0OiAweDdjLFxuICAgICAgICAgICAgICAgIGYzMjogMHg3ZCxcbiAgICAgICAgICAgICAgICBpNjQ6IDB4N2UsXG4gICAgICAgICAgICAgICAgaTMyOiAweDdmLFxuICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICB1bGViMTI4RW5jb2RlOiBmdW5jdGlvbiAodGd0LCBtZXRob2QsIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8IDEyOCkgdGd0W21ldGhvZF0obik7XG4gICAgICAgICAgICAgICAgZWxzZSB0Z3RbbWV0aG9kXShuICUgMTI4IHwgMTI4LCBuID4+IDcpO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIHJ4SlNpZzogL14oXFx3KVxcKChcXHcqKVxcKSQvLFxuXG4gICAgICAgICAgICAgIHNpZ1BhcmFtczogZnVuY3Rpb24gKHNpZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBmLl8ucnhKU2lnLmV4ZWMoc2lnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbSA/IG1bMl0gOiBzaWcuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIGxldHRlclR5cGU6ICh4KSA9PlxuICAgICAgICAgICAgICAgIGYuXy5zaWdUeXBlc1t4XSB8fCB0b3NzKCdJbnZhbGlkIHNpZ25hdHVyZSBsZXR0ZXI6JywgeCksXG5cbiAgICAgICAgICAgICAgcHVzaFNpZ1R5cGU6IChkZXN0LCBsZXR0ZXIpID0+XG4gICAgICAgICAgICAgICAgZGVzdC5wdXNoKGYuXy50eXBlQ29kZXNbZi5fLmxldHRlclR5cGUobGV0dGVyKV0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZnVuYykge1xuICAgICAgICAgICAgY29uc3QgeCA9IHNpZztcbiAgICAgICAgICAgIHNpZyA9IGZ1bmM7XG4gICAgICAgICAgICBmdW5jID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2lnUGFyYW1zID0gZi5fLnNpZ1BhcmFtcyhzaWcpO1xuICAgICAgICAgIGNvbnN0IHdhc21Db2RlID0gWzB4MDEsIDB4NjBdO1xuICAgICAgICAgIGYuXy51bGViMTI4RW5jb2RlKHdhc21Db2RlLCAncHVzaCcsIHNpZ1BhcmFtcy5sZW5ndGgpO1xuICAgICAgICAgIGZvciAoY29uc3QgeCBvZiBzaWdQYXJhbXMpIGYuXy5wdXNoU2lnVHlwZSh3YXNtQ29kZSwgeCk7XG4gICAgICAgICAgaWYgKCd2JyA9PT0gc2lnWzBdKSB3YXNtQ29kZS5wdXNoKDApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FzbUNvZGUucHVzaCgxKTtcbiAgICAgICAgICAgIGYuXy5wdXNoU2lnVHlwZSh3YXNtQ29kZSwgc2lnWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZi5fLnVsZWIxMjhFbmNvZGUod2FzbUNvZGUsICd1bnNoaWZ0Jywgd2FzbUNvZGUubGVuZ3RoKTtcbiAgICAgICAgICB3YXNtQ29kZS51bnNoaWZ0KFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4NjEsXG4gICAgICAgICAgICAweDczLFxuICAgICAgICAgICAgMHg2ZCxcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICk7XG4gICAgICAgICAgd2FzbUNvZGUucHVzaChcbiAgICAgICAgICAgIDB4MDIsXG4gICAgICAgICAgICAweDA3LFxuXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4NjUsXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHg2NixcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwNyxcbiAgICAgICAgICAgIDB4MDUsXG5cbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHg2NixcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShcbiAgICAgICAgICAgIG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkod2FzbUNvZGUpKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZTogeyBmOiBmdW5jIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICkuZXhwb3J0c1snZiddO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9faW5zdGFsbEZ1bmN0aW9uID0gZnVuY3Rpb24gZihmdW5jLCBzaWcsIHNjb3BlZCkge1xuICAgICAgICAgIGlmIChzY29wZWQgJiYgIWNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9zcygnTm8gc2NvcGVkQWxsb2NQdXNoKCkgc2NvcGUgaXMgYWN0aXZlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gc2lnO1xuICAgICAgICAgICAgc2lnID0gZnVuYztcbiAgICAgICAgICAgIGZ1bmMgPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzaWcgfHwgIShmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHM6IGV4cGVjdGluZyAoZnVuY3Rpb24sc2lnbmF0dXJlKSAnICtcbiAgICAgICAgICAgICAgICAnb3IgKHNpZ25hdHVyZSxmdW5jdGlvbikuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICAgICAgICBjb25zdCBvbGRMZW4gPSBmdC5sZW5ndGg7XG4gICAgICAgICAgbGV0IHB0cjtcbiAgICAgICAgICB3aGlsZSAoY2FjaGUuZnJlZUZ1bmNJbmRleGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHRyID0gY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGZ0LmdldChwdHIpKSB7XG4gICAgICAgICAgICAgIHB0ciA9IG51bGw7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcHRyKSB7XG4gICAgICAgICAgICBwdHIgPSBvbGRMZW47XG4gICAgICAgICAgICBmdC5ncm93KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnQuc2V0KHB0ciwgZnVuYyk7XG4gICAgICAgICAgICBpZiAoc2NvcGVkKSB7XG4gICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2gocHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcikpIHtcbiAgICAgICAgICAgICAgaWYgKHB0ciA9PT0gb2xkTGVuKSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucHVzaChvbGRMZW4pO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmcHRyID0gdGFyZ2V0LmpzRnVuY1RvV2FzbShmdW5jLCBzaWcpO1xuICAgICAgICAgICAgZnQuc2V0KHB0ciwgZnB0cik7XG4gICAgICAgICAgICBpZiAoc2NvcGVkKSB7XG4gICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2gocHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAocHRyID09PSBvbGRMZW4pIGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wdXNoKG9sZExlbik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5pbnN0YWxsRnVuY3Rpb24gPSAoZnVuYywgc2lnKSA9PlxuICAgICAgICAgIF9faW5zdGFsbEZ1bmN0aW9uKGZ1bmMsIHNpZywgZmFsc2UpO1xuXG4gICAgICAgIHRhcmdldC5zY29wZWRJbnN0YWxsRnVuY3Rpb24gPSAoZnVuYywgc2lnKSA9PlxuICAgICAgICAgIF9faW5zdGFsbEZ1bmN0aW9uKGZ1bmMsIHNpZywgdHJ1ZSk7XG5cbiAgICAgICAgdGFyZ2V0LnVuaW5zdGFsbEZ1bmN0aW9uID0gZnVuY3Rpb24gKHB0cikge1xuICAgICAgICAgIGlmICghcHRyICYmIDAgIT09IHB0cikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBmaSA9IGNhY2hlLmZyZWVGdW5jSW5kZXhlcztcbiAgICAgICAgICBjb25zdCBmdCA9IHRhcmdldC5mdW5jdGlvblRhYmxlKCk7XG4gICAgICAgICAgZmkucHVzaChwdHIpO1xuICAgICAgICAgIGNvbnN0IHJjID0gZnQuZ2V0KHB0cik7XG4gICAgICAgICAgZnQuc2V0KHB0ciwgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5wZWVrID0gZnVuY3Rpb24gZihwdHIsIHR5cGUgPSAnaTgnKSB7XG4gICAgICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9IHB0cklSO1xuICAgICAgICAgIGNvbnN0IGMgPVxuICAgICAgICAgICAgY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgPyBjYWNoZVxuICAgICAgICAgICAgICA6IGhlYXBXcmFwcGVycygpO1xuICAgICAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHB0cikgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGxpc3QpIHB0ciA9IGFyZ3VtZW50c1swXS5zaGlmdCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2kxJzpcbiAgICAgICAgICAgICAgY2FzZSAnaTgnOlxuICAgICAgICAgICAgICAgIHJjID0gYy5IRUFQOFtwdHIgPj4gMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2kxNic6XG4gICAgICAgICAgICAgICAgcmMgPSBjLkhFQVAxNltwdHIgPj4gMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2kzMic6XG4gICAgICAgICAgICAgICAgcmMgPSBjLkhFQVAzMltwdHIgPj4gMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgICAgICAgICByYyA9IGMuSEVBUDMyRltwdHIgPj4gMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Y2NCc6XG4gICAgICAgICAgICAgICAgcmMgPSBOdW1iZXIoYy5IRUFQNjRGW3B0ciA+PiAzXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2k2NCc6XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICByYyA9IEJpZ0ludChjLkhFQVA2NFtwdHIgPj4gM10pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIGZvciBwZWVrKCk6JywgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdCkgbGlzdC5wdXNoKHJjKTtcbiAgICAgICAgICB9IHdoaWxlIChsaXN0ICYmIGFyZ3VtZW50c1swXS5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBsaXN0IHx8IHJjO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5wb2tlID0gZnVuY3Rpb24gKHB0ciwgdmFsdWUsIHR5cGUgPSAnaTgnKSB7XG4gICAgICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9IHB0cklSO1xuICAgICAgICAgIGNvbnN0IGMgPVxuICAgICAgICAgICAgY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgPyBjYWNoZVxuICAgICAgICAgICAgICA6IGhlYXBXcmFwcGVycygpO1xuICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBBcnJheS5pc0FycmF5KHB0cikgPyBwdHIgOiBbcHRyXSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2kxJzpcbiAgICAgICAgICAgICAgY2FzZSAnaTgnOlxuICAgICAgICAgICAgICAgIGMuSEVBUDhbcCA+PiAwXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlICdpMTYnOlxuICAgICAgICAgICAgICAgIGMuSEVBUDE2W3AgPj4gMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSAnaTMyJzpcbiAgICAgICAgICAgICAgICBjLkhFQVAzMltwID4+IDJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgY2FzZSAnZjMyJzpcbiAgICAgICAgICAgICAgICBjLkhFQVAzMkZbcCA+PiAyXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjYXNlICdmNjQnOlxuICAgICAgICAgICAgICAgIGMuSEVBUDY0RltwID4+IDNdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgJ2k2NCc6XG4gICAgICAgICAgICAgICAgaWYgKGMuSEVBUDY0KSB7XG4gICAgICAgICAgICAgICAgICBjLkhFQVA2NFtwID4+IDNdID0gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdHlwZSBmb3IgcG9rZSgpOiAnICsgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5wZWVrUHRyID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCBwdHJJUik7XG5cbiAgICAgICAgdGFyZ2V0LnBva2VQdHIgPSAocHRyLCB2YWx1ZSA9IDApID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsIHB0cklSKTtcblxuICAgICAgICB0YXJnZXQucGVlazggPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsICdpOCcpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlOCA9IChwdHIsIHZhbHVlKSA9PiB0YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTgnKTtcblxuICAgICAgICB0YXJnZXQucGVlazE2ID0gKC4uLnB0cikgPT5cbiAgICAgICAgICB0YXJnZXQucGVlaygxID09PSBwdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyLCAnaTE2Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBva2UxNiA9IChwdHIsIHZhbHVlKSA9PiB0YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTE2Jyk7XG5cbiAgICAgICAgdGFyZ2V0LnBlZWszMiA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2kzMicpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlMzIgPSAocHRyLCB2YWx1ZSkgPT4gdGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2kzMicpO1xuXG4gICAgICAgIHRhcmdldC5wZWVrNjQgPSAoLi4ucHRyKSA9PlxuICAgICAgICAgIHRhcmdldC5wZWVrKDEgPT09IHB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIsICdpNjQnKTtcblxuICAgICAgICB0YXJnZXQucG9rZTY0ID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpNjQnKTtcblxuICAgICAgICB0YXJnZXQucGVlazMyZiA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2YzMicpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlMzJmID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdmMzInKTtcblxuICAgICAgICB0YXJnZXQucGVlazY0ZiA9ICguLi5wdHIpID0+XG4gICAgICAgICAgdGFyZ2V0LnBlZWsoMSA9PT0gcHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciwgJ2Y2NCcpO1xuXG4gICAgICAgIHRhcmdldC5wb2tlNjRmID0gKHB0ciwgdmFsdWUpID0+IHRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdmNjQnKTtcblxuICAgICAgICB0YXJnZXQuZ2V0TWVtVmFsdWUgPSB0YXJnZXQucGVlaztcblxuICAgICAgICB0YXJnZXQuZ2V0UHRyVmFsdWUgPSB0YXJnZXQucGVla1B0cjtcblxuICAgICAgICB0YXJnZXQuc2V0TWVtVmFsdWUgPSB0YXJnZXQucG9rZTtcblxuICAgICAgICB0YXJnZXQuc2V0UHRyVmFsdWUgPSB0YXJnZXQucG9rZVB0cjtcblxuICAgICAgICB0YXJnZXQuaXNQdHIzMiA9IChwdHIpID0+XG4gICAgICAgICAgJ251bWJlcicgPT09IHR5cGVvZiBwdHIgJiYgcHRyID09PSAocHRyIHwgMCkgJiYgcHRyID49IDA7XG5cbiAgICAgICAgdGFyZ2V0LmlzUHRyID0gdGFyZ2V0LmlzUHRyMzI7XG5cbiAgICAgICAgdGFyZ2V0LmNzdHJsZW4gPSBmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgICAgaWYgKCFwdHIgfHwgIXRhcmdldC5pc1B0cihwdHIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBjb25zdCBoID0gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuICAgICAgICAgIGxldCBwb3MgPSBwdHI7XG4gICAgICAgICAgZm9yICg7IGhbcG9zXSAhPT0gMDsgKytwb3MpIHt9XG4gICAgICAgICAgcmV0dXJuIHBvcyAtIHB0cjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX1NBQiA9XG4gICAgICAgICAgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgOiBTaGFyZWRBcnJheUJ1ZmZlcjtcbiAgICAgICAgY29uc3QgX191dGY4RGVjb2RlID0gZnVuY3Rpb24gKGFycmF5QnVmZmVyLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLnV0ZjhEZWNvZGVyLmRlY29kZShcbiAgICAgICAgICAgIGFycmF5QnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCXG4gICAgICAgICAgICAgID8gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgICAgICAgOiBhcnJheUJ1ZmZlci5zdWJhcnJheShiZWdpbiwgZW5kKSxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5jc3RyVG9KcyA9IGZ1bmN0aW9uIChwdHIpIHtcbiAgICAgICAgICBjb25zdCBuID0gdGFyZ2V0LmNzdHJsZW4ocHRyKTtcbiAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgPyBfX3V0ZjhEZWNvZGUoaGVhcFdyYXBwZXJzKCkuSEVBUDhVLCBwdHIsIHB0ciArIG4pXG4gICAgICAgICAgICA6IG51bGwgPT09IG5cbiAgICAgICAgICAgICAgPyBuXG4gICAgICAgICAgICAgIDogJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmpzdHJsZW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3RyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBjb25zdCBuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgbGV0IHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICh1ID49IDB4ZDgwMCAmJiB1IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICB1ID1cbiAgICAgICAgICAgICAgICAoMHgxMDAwMCArICgodSAmIDB4M2ZmKSA8PCAxMCkpIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodSA8PSAweDdmKSArK2xlbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHUgPD0gMHg3ZmYpIGxlbiArPSAyO1xuICAgICAgICAgICAgZWxzZSBpZiAodSA8PSAweGZmZmYpIGxlbiArPSAzO1xuICAgICAgICAgICAgZWxzZSBsZW4gKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQuanN0cmNweSA9IGZ1bmN0aW9uIChcbiAgICAgICAgICBqc3RyLFxuICAgICAgICAgIHRndCxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIG1heEJ5dGVzID0gLTEsXG4gICAgICAgICAgYWRkTnVsID0gdHJ1ZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRndCB8fFxuICAgICAgICAgICAgKCEodGd0IGluc3RhbmNlb2YgSW50OEFycmF5KSAmJiAhKHRndCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdG9zcygnanN0cmNweSgpIHRhcmdldCBtdXN0IGJlIGFuIEludDhBcnJheSBvciBVaW50OEFycmF5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4Qnl0ZXMgPCAwKSBtYXhCeXRlcyA9IHRndC5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKCEobWF4Qnl0ZXMgPiAwKSB8fCAhKG9mZnNldCA+PSAwKSkgcmV0dXJuIDA7XG4gICAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgbWF4ID0ganN0ci5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgYmVnaW4gPSBvZmZzZXQsXG4gICAgICAgICAgICBlbmQgPSBvZmZzZXQgKyBtYXhCeXRlcyAtIChhZGROdWwgPyAxIDogMCk7XG4gICAgICAgICAgZm9yICg7IGkgPCBtYXggJiYgb2Zmc2V0IDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIGxldCB1ID0ganN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKHUgPj0gMHhkODAwICYmIHUgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIHUgPVxuICAgICAgICAgICAgICAgICgweDEwMDAwICsgKCh1ICYgMHgzZmYpIDw8IDEwKSkgfFxuICAgICAgICAgICAgICAgIChqc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1IDw9IDB4N2YpIHtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA+PSBlbmQpIGJyZWFrO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gdTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodSA8PSAweDdmZikge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgMSA+PSBlbmQpIGJyZWFrO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHhjMCB8ICh1ID4+IDYpO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICh1ICYgMHgzZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAyID49IGVuZCkgYnJlYWs7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweGUwIHwgKHUgPj4gMTIpO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDB4M2YpO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICh1ICYgMHgzZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgMyA+PSBlbmQpIGJyZWFrO1xuICAgICAgICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHhmMCB8ICh1ID4+IDE4KTtcbiAgICAgICAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gMTIpICYgMHgzZik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFkZE51bCkgdGd0W29mZnNldCsrXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCAtIGJlZ2luO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5jc3RybmNweSA9IGZ1bmN0aW9uICh0Z3RQdHIsIHNyY1B0ciwgbikge1xuICAgICAgICAgIGlmICghdGd0UHRyIHx8ICFzcmNQdHIpXG4gICAgICAgICAgICB0b3NzKCdjc3RybmNweSgpIGRvZXMgbm90IGFjY2VwdCBOVUxMIHN0cmluZ3MuJyk7XG4gICAgICAgICAgaWYgKG4gPCAwKSBuID0gdGFyZ2V0LmNzdHJsZW4oc3RyUHRyKSArIDE7XG4gICAgICAgICAgZWxzZSBpZiAoIShuID4gMCkpIHJldHVybiAwO1xuICAgICAgICAgIGNvbnN0IGhlYXAgPSB0YXJnZXQuaGVhcDh1KCk7XG4gICAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgY2g7XG4gICAgICAgICAgZm9yICg7IGkgPCBuICYmIChjaCA9IGhlYXBbc3JjUHRyICsgaV0pOyArK2kpIHtcbiAgICAgICAgICAgIGhlYXBbdGd0UHRyICsgaV0gPSBjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPCBuKSBoZWFwW3RndFB0ciArIGkrK10gPSAwO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5qc3RyVG9VaW50QXJyYXkgPSAoc3RyLCBhZGROdWwgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWNoZS51dGY4RW5jb2Rlci5lbmNvZGUoYWRkTnVsID8gc3RyICsgJ1xcMCcgOiBzdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWZmaXJtQWxsb2MgPSAob2JqLCBmdW5jTmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEob2JqLmFsbG9jIGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICAhKG9iai5kZWFsbG9jIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnT2JqZWN0IGlzIG1pc3NpbmcgYWxsb2MoKSBhbmQvb3IgZGVhbGxvYygpIGZ1bmN0aW9uKHMpJyxcbiAgICAgICAgICAgICAgJ3JlcXVpcmVkIGJ5JyxcbiAgICAgICAgICAgICAgZnVuY05hbWUgKyAnKCkuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWxsb2NDU3RyID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGpzdHIsXG4gICAgICAgICAgcmV0dXJuV2l0aExlbmd0aCxcbiAgICAgICAgICBhbGxvY2F0b3IsXG4gICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICkge1xuICAgICAgICAgIF9fYWZmaXJtQWxsb2ModGFyZ2V0LCBmdW5jTmFtZSk7XG4gICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YganN0cikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKDApIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0YXJnZXQuanN0cmxlbihqc3RyKSxcbiAgICAgICAgICAgICAgcHRyID0gYWxsb2NhdG9yKG4gKyAxKTtcbiAgICAgICAgICAgIHRhcmdldC5qc3RyY3B5KGpzdHIsIHRhcmdldC5oZWFwOHUoKSwgcHRyLCBuICsgMSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuV2l0aExlbmd0aCA/IFtwdHIsIG5dIDogcHRyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gY2FjaGUudXRmOEVuY29kZXIuZW5jb2RlKGpzdHIpLFxuICAgICAgICAgICAgICBwdHIgPSBhbGxvY2F0b3IodS5sZW5ndGggKyAxKSxcbiAgICAgICAgICAgICAgaGVhcCA9IGhlYXBXcmFwcGVycygpLkhFQVA4VTtcbiAgICAgICAgICAgIGhlYXAuc2V0KHUsIHB0cik7XG4gICAgICAgICAgICBoZWFwW3B0ciArIHUubGVuZ3RoXSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuV2l0aExlbmd0aCA/IFtwdHIsIHUubGVuZ3RoXSA6IHB0cjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LmFsbG9jQ1N0cmluZyA9IChqc3RyLCByZXR1cm5XaXRoTGVuZ3RoID0gZmFsc2UpID0+XG4gICAgICAgICAgX19hbGxvY0NTdHIoanN0ciwgcmV0dXJuV2l0aExlbmd0aCwgdGFyZ2V0LmFsbG9jLCAnYWxsb2NDU3RyaW5nKCknKTtcblxuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF9fYWZmaXJtQWxsb2ModGFyZ2V0LCAnc2NvcGVkQWxsb2NQdXNoJyk7XG4gICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jLnB1c2goYSk7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUG9wID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsICdzY29wZWRBbGxvY1BvcCcpO1xuICAgICAgICAgIGNvbnN0IG4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICA/IGNhY2hlLnNjb3BlZEFsbG9jLmluZGV4T2Yoc3RhdGUpXG4gICAgICAgICAgICA6IGNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKG4gPCAwKSB0b3NzKCdJbnZhbGlkIHN0YXRlIG9iamVjdCBmb3Igc2NvcGVkQWxsb2NQb3AoKS4nKTtcbiAgICAgICAgICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgc3RhdGUgPSBjYWNoZS5zY29wZWRBbGxvY1tuXTtcbiAgICAgICAgICBjYWNoZS5zY29wZWRBbGxvYy5zcGxpY2UobiwgMSk7XG4gICAgICAgICAgZm9yIChsZXQgcDsgKHAgPSBzdGF0ZS5wb3AoKSk7ICkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5mdW5jdGlvbkVudHJ5KHApKSB7XG4gICAgICAgICAgICAgIHRhcmdldC51bmluc3RhbGxGdW5jdGlvbihwKTtcbiAgICAgICAgICAgIH0gZWxzZSB0YXJnZXQuZGVhbGxvYyhwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICBpZiAoIWNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9zcygnTm8gc2NvcGVkQWxsb2NQdXNoKCkgc2NvcGUgaXMgYWN0aXZlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwID0gdGFyZ2V0LmFsbG9jKG4pO1xuICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCAtIDFdLnB1c2gocCk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldC5zY29wZWRBbGxvYywgJ2xldmVsJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiAoKSA9PiBjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgsXG4gICAgICAgICAgc2V0OiAoKSA9PiB0b3NzKFwiVGhlICdhY3RpdmUnIHByb3BlcnR5IGlzIHJlYWQtb25seS5cIiksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRhcmdldC5zY29wZWRBbGxvY0NTdHJpbmcgPSAoanN0ciwgcmV0dXJuV2l0aExlbmd0aCA9IGZhbHNlKSA9PlxuICAgICAgICAgIF9fYWxsb2NDU3RyKFxuICAgICAgICAgICAganN0cixcbiAgICAgICAgICAgIHJldHVybldpdGhMZW5ndGgsXG4gICAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2MsXG4gICAgICAgICAgICAnc2NvcGVkQWxsb2NDU3RyaW5nKCknLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgX19hbGxvY01haW5Bcmd2ID0gZnVuY3Rpb24gKGlzU2NvcGVkLCBsaXN0KSB7XG4gICAgICAgICAgY29uc3QgcExpc3QgPSB0YXJnZXRbaXNTY29wZWQgPyAnc2NvcGVkQWxsb2MnIDogJ2FsbG9jJ10oXG4gICAgICAgICAgICAobGlzdC5sZW5ndGggKyAxKSAqIHRhcmdldC5wdHJTaXplb2YsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgbGlzdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQucG9rZVB0cihcbiAgICAgICAgICAgICAgcExpc3QgKyB0YXJnZXQucHRyU2l6ZW9mICogaSsrLFxuICAgICAgICAgICAgICB0YXJnZXRbaXNTY29wZWQgPyAnc2NvcGVkQWxsb2NDU3RyaW5nJyA6ICdhbGxvY0NTdHJpbmcnXSgnJyArIGUpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXQucG9rZVB0cihwTGlzdCArIHRhcmdldC5wdHJTaXplb2YgKiBpLCAwKTtcbiAgICAgICAgICByZXR1cm4gcExpc3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jTWFpbkFyZ3YgPSAobGlzdCkgPT4gX19hbGxvY01haW5Bcmd2KHRydWUsIGxpc3QpO1xuXG4gICAgICAgIHRhcmdldC5hbGxvY01haW5Bcmd2ID0gKGxpc3QpID0+IF9fYWxsb2NNYWluQXJndihmYWxzZSwgbGlzdCk7XG5cbiAgICAgICAgdGFyZ2V0LmNBcmd2VG9KcyA9IChhcmdjLCBwQXJndikgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gdGFyZ2V0LnBlZWtQdHIocEFyZ3YgKyB0YXJnZXQucHRyU2l6ZW9mICogaSk7XG4gICAgICAgICAgICBsaXN0LnB1c2goYXJnID8gdGFyZ2V0LmNzdHJUb0pzKGFyZykgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jQ2FsbCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYygpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hbGxvY1B0ciA9IGZ1bmN0aW9uIChob3dNYW55LCBzYWZlUHRyU2l6ZSwgbWV0aG9kKSB7XG4gICAgICAgICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsIG1ldGhvZCk7XG4gICAgICAgICAgY29uc3QgcElyID0gc2FmZVB0clNpemUgPyAnaTY0JyA6IHB0cklSO1xuICAgICAgICAgIGxldCBtID0gdGFyZ2V0W21ldGhvZF0oaG93TWFueSAqIChzYWZlUHRyU2l6ZSA/IDggOiBwdHJTaXplb2YpKTtcbiAgICAgICAgICB0YXJnZXQucG9rZShtLCAwLCBwSXIpO1xuICAgICAgICAgIGlmICgxID09PSBob3dNYW55KSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYSA9IFttXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhvd01hbnk7ICsraSkge1xuICAgICAgICAgICAgbSArPSBzYWZlUHRyU2l6ZSA/IDggOiBwdHJTaXplb2Y7XG4gICAgICAgICAgICBhW2ldID0gbTtcbiAgICAgICAgICAgIHRhcmdldC5wb2tlKG0sIDAsIHBJcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5hbGxvY1B0ciA9IChob3dNYW55ID0gMSwgc2FmZVB0clNpemUgPSB0cnVlKSA9PlxuICAgICAgICAgIF9fYWxsb2NQdHIoaG93TWFueSwgc2FmZVB0clNpemUsICdhbGxvYycpO1xuXG4gICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1B0ciA9IChob3dNYW55ID0gMSwgc2FmZVB0clNpemUgPSB0cnVlKSA9PlxuICAgICAgICAgIF9fYWxsb2NQdHIoaG93TWFueSwgc2FmZVB0clNpemUsICdzY29wZWRBbGxvYycpO1xuXG4gICAgICAgIHRhcmdldC54R2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGFyZ2V0LmV4cG9ydHNbbmFtZV0gfHwgdG9zcygnQ2Fubm90IGZpbmQgZXhwb3J0ZWQgc3ltYm9sOicsIG5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FyZ2NNaXNtYXRjaCA9IChmLCBuKSA9PlxuICAgICAgICAgIHRvc3MoZiArICcoKSByZXF1aXJlcycsIG4sICdhcmd1bWVudChzKS4nKTtcblxuICAgICAgICB0YXJnZXQueENhbGwgPSBmdW5jdGlvbiAoZm5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBjb25zdCBmID0gZm5hbWUgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZuYW1lIDogdGFyZ2V0LnhHZXQoZm5hbWUpO1xuICAgICAgICAgIGlmICghKGYgaW5zdGFuY2VvZiBGdW5jdGlvbikpXG4gICAgICAgICAgICB0b3NzKCdFeHBvcnRlZCBzeW1ib2wnLCBmbmFtZSwgJ2lzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIGlmIChmLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpXG4gICAgICAgICAgICBfX2FyZ2NNaXNtYXRjaChmID09PSBmbmFtZSA/IGYubmFtZSA6IGZuYW1lLCBmLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIDIgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pXG4gICAgICAgICAgICA/IGYuYXBwbHkobnVsbCwgYXJndW1lbnRzWzFdKVxuICAgICAgICAgICAgOiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhY2hlLnhXcmFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY2FjaGUueFdyYXAuY29udmVydCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY2FjaGUueFdyYXAuY29udmVydC5hcmcgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgY2FjaGUueFdyYXAuY29udmVydC5yZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHhBcmcgPSBjYWNoZS54V3JhcC5jb252ZXJ0LmFyZyxcbiAgICAgICAgICB4UmVzdWx0ID0gY2FjaGUueFdyYXAuY29udmVydC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHRhcmdldC5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgeEFyZy5zZXQoJ2k2NCcsIChpKSA9PiBCaWdJbnQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9feEFyZ1B0ciA9XG4gICAgICAgICAgJ2kzMicgPT09IHB0cklSID8gKGkpID0+IGkgfCAwIDogKGkpID0+IEJpZ0ludChpKSB8IEJpZ0ludCgwKTtcbiAgICAgICAgeEFyZ1xuICAgICAgICAgIC5zZXQoJ2kzMicsIF9feEFyZ1B0cilcbiAgICAgICAgICAuc2V0KCdpMTYnLCAoaSkgPT4gKGkgfCAwKSAmIDB4ZmZmZilcbiAgICAgICAgICAuc2V0KCdpOCcsIChpKSA9PiAoaSB8IDApICYgMHhmZilcbiAgICAgICAgICAuc2V0KCdmMzInLCAoaSkgPT4gTnVtYmVyKGkpLnZhbHVlT2YoKSlcbiAgICAgICAgICAuc2V0KCdmbG9hdCcsIHhBcmcuZ2V0KCdmMzInKSlcbiAgICAgICAgICAuc2V0KCdmNjQnLCB4QXJnLmdldCgnZjMyJykpXG4gICAgICAgICAgLnNldCgnZG91YmxlJywgeEFyZy5nZXQoJ2Y2NCcpKVxuICAgICAgICAgIC5zZXQoJ2ludCcsIHhBcmcuZ2V0KCdpMzInKSlcbiAgICAgICAgICAuc2V0KCdudWxsJywgKGkpID0+IGkpXG4gICAgICAgICAgLnNldChudWxsLCB4QXJnLmdldCgnbnVsbCcpKVxuICAgICAgICAgIC5zZXQoJyoqJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJyonLCBfX3hBcmdQdHIpO1xuICAgICAgICB4UmVzdWx0XG4gICAgICAgICAgLnNldCgnKicsIF9feEFyZ1B0cilcbiAgICAgICAgICAuc2V0KCdwb2ludGVyJywgX194QXJnUHRyKVxuICAgICAgICAgIC5zZXQoJ251bWJlcicsICh2KSA9PiBOdW1iZXIodikpXG4gICAgICAgICAgLnNldCgndm9pZCcsICh2KSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgLnNldCgnbnVsbCcsICh2KSA9PiB2KVxuICAgICAgICAgIC5zZXQobnVsbCwgeFJlc3VsdC5nZXQoJ251bGwnKSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvcHlUb1Jlc3VsdCA9IFtcbiAgICAgICAgICAgICdpOCcsXG4gICAgICAgICAgICAnaTE2JyxcbiAgICAgICAgICAgICdpMzInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnZjMyJyxcbiAgICAgICAgICAgICdmbG9hdCcsXG4gICAgICAgICAgICAnZjY0JyxcbiAgICAgICAgICAgICdkb3VibGUnLFxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKHRhcmdldC5iaWdJbnRFbmFibGVkKSBjb3B5VG9SZXN1bHQucHVzaCgnaTY0Jyk7XG4gICAgICAgICAgY29uc3QgYWRhcHRQdHIgPSB4QXJnLmdldChwdHJJUik7XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIGNvcHlUb1Jlc3VsdCkge1xuICAgICAgICAgICAgeEFyZy5zZXQodCArICcqJywgYWRhcHRQdHIpO1xuICAgICAgICAgICAgeFJlc3VsdC5zZXQodCArICcqJywgYWRhcHRQdHIpO1xuICAgICAgICAgICAgeFJlc3VsdC5zZXQodCwgeEFyZy5nZXQodCkgfHwgdG9zcygnTWlzc2luZyBhcmcgY29udmVydGVyOicsIHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfX3hBcmdTdHJpbmcgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHJldHVybiB0YXJnZXQuc2NvcGVkQWxsb2NDU3RyaW5nKHYpO1xuICAgICAgICAgIHJldHVybiB2ID8gX194QXJnUHRyKHYpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgeEFyZ1xuICAgICAgICAgIC5zZXQoJ3N0cmluZycsIF9feEFyZ1N0cmluZylcbiAgICAgICAgICAuc2V0KCd1dGY4JywgX194QXJnU3RyaW5nKVxuICAgICAgICAgIC5zZXQoJ3BvaW50ZXInLCBfX3hBcmdTdHJpbmcpO1xuXG4gICAgICAgIHhSZXN1bHRcbiAgICAgICAgICAuc2V0KCdzdHJpbmcnLCAoaSkgPT4gdGFyZ2V0LmNzdHJUb0pzKGkpKVxuICAgICAgICAgIC5zZXQoJ3V0ZjgnLCB4UmVzdWx0LmdldCgnc3RyaW5nJykpXG4gICAgICAgICAgLnNldCgnc3RyaW5nOmRlYWxsb2MnLCAoaSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkgPyB0YXJnZXQuY3N0clRvSnMoaSkgOiBudWxsO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0LmRlYWxsb2MoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2V0KCd1dGY4OmRlYWxsb2MnLCB4UmVzdWx0LmdldCgnc3RyaW5nOmRlYWxsb2MnKSlcbiAgICAgICAgICAuc2V0KCdqc29uJywgKGkpID0+IEpTT04ucGFyc2UodGFyZ2V0LmNzdHJUb0pzKGkpKSlcbiAgICAgICAgICAuc2V0KCdqc29uOmRlYWxsb2MnLCAoaSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkgPyBKU09OLnBhcnNlKHRhcmdldC5jc3RyVG9KcyhpKSkgOiBudWxsO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0LmRlYWxsb2MoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgQWJzdHJhY3RBcmdBZGFwdGVyID0gY2xhc3Mge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgJ3VubmFtZWQgYWRhcHRlcic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udmVydEFyZyh2LCBhcmd2LCBhcmdJbmRleCkge1xuICAgICAgICAgICAgdG9zcygnQWJzdHJhY3RBcmdBZGFwdGVyIG11c3QgYmUgc3ViY2xhc3NlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeEFyZy5GdW5jUHRyQWRhcHRlciA9IGNsYXNzIEZ1bmNQdHJBZGFwdGVyIGV4dGVuZHMgQWJzdHJhY3RBcmdBZGFwdGVyIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihvcHQpIHtcbiAgICAgICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgICAgICBpZiAoeEFyZy5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICd4QXJnLkZ1bmNQdHJBZGFwdGVyIGlzIGFuIGludGVybmFsLW9ubHkgQVBJJyxcbiAgICAgICAgICAgICAgICAnYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBpbnZva2VkIGZyb20nLFxuICAgICAgICAgICAgICAgICdjbGllbnQtbGV2ZWwgY29kZS4gSW52b2tlZCB3aXRoOicsXG4gICAgICAgICAgICAgICAgb3B0LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgJ3VubmFtZWQnO1xuICAgICAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBvcHQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgaWYgKG9wdC5jb250ZXh0S2V5IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5ID0gb3B0LmNvbnRleHRLZXk7XG4gICAgICAgICAgICAgIGlmICghb3B0LmJpbmRTY29wZSkgb3B0LmJpbmRTY29wZSA9ICdjb250ZXh0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmluZFNjb3BlID1cbiAgICAgICAgICAgICAgb3B0LmJpbmRTY29wZSB8fFxuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdGdW5jUHRyQWRhcHRlciBvcHRpb25zIHJlcXVpcmVzIGEgYmluZFNjb3BlIChleHBsaWNpdCBvciBpbXBsaWVkKS4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKEZ1bmNQdHJBZGFwdGVyLmJpbmRTY29wZXMuaW5kZXhPZihvcHQuYmluZFNjb3BlKSA8IDApIHtcbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAnSW52YWxpZCBvcHRpb25zLmJpbmRTY29wZSAoJyArXG4gICAgICAgICAgICAgICAgICBvcHQuYmluZE1vZCArXG4gICAgICAgICAgICAgICAgICAnKSBmb3IgRnVuY1B0ckFkYXB0ZXIuICcgK1xuICAgICAgICAgICAgICAgICAgJ0V4cGVjdGluZyBvbmUgb2Y6ICgnICtcbiAgICAgICAgICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmJpbmRTY29wZXMuam9pbignLCAnKSArXG4gICAgICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNpZW50ID0gJ3RyYW5zaWVudCcgPT09IHRoaXMuYmluZFNjb3BlO1xuICAgICAgICAgICAgdGhpcy5pc0NvbnRleHQgPSAnY29udGV4dCcgPT09IHRoaXMuYmluZFNjb3BlO1xuICAgICAgICAgICAgdGhpcy5pc1Blcm1hbmVudCA9ICdwZXJtYW5lbnQnID09PSB0aGlzLmJpbmRTY29wZTtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uID0gJ3NpbmdsZXRvbicgPT09IHRoaXMuYmluZFNjb3BlID8gW10gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbFByb3h5ID1cbiAgICAgICAgICAgICAgb3B0LmNhbGxQcm94eSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gb3B0LmNhbGxQcm94eSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0S2V5KGFyZ3YsIGFyZ0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0TWFwKGtleSkge1xuICAgICAgICAgICAgY29uc3QgY20gPSB0aGlzLl9fY21hcCB8fCAodGhpcy5fX2NtYXAgPSBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgbGV0IHJjID0gY20uZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSByYykgY20uc2V0KGtleSwgKHJjID0gW10pKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb252ZXJ0QXJnKHYsIGFyZ3YsIGFyZ0luZGV4KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IHRoaXMuc2luZ2xldG9uO1xuICAgICAgICAgICAgaWYgKCFwYWlyICYmIHRoaXMuaXNDb250ZXh0KSB7XG4gICAgICAgICAgICAgIHBhaXIgPSB0aGlzLmNvbnRleHRNYXAodGhpcy5jb250ZXh0S2V5KGFyZ3YsIGFyZ0luZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpciAmJiBwYWlyWzBdID09PSB2KSByZXR1cm4gcGFpclsxXTtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFByb3h5KSB2ID0gdGhpcy5jYWxsUHJveHkodik7XG4gICAgICAgICAgICAgIGNvbnN0IGZwID0gX19pbnN0YWxsRnVuY3Rpb24odiwgdGhpcy5zaWduYXR1cmUsIHRoaXMuaXNUcmFuc2llbnQpO1xuICAgICAgICAgICAgICBpZiAoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCkge1xuICAgICAgICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0KFxuICAgICAgICAgICAgICAgICAgJ0Z1bmNQdHJBZGFwdGVyIGluc3RhbGxlZCcsXG4gICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5KGFyZ3YsIGFyZ0luZGV4KSxcbiAgICAgICAgICAgICAgICAgICdAJyArIGZwLFxuICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhaXJbMV0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0KFxuICAgICAgICAgICAgICAgICAgICAgICdGdW5jUHRyQWRhcHRlciB1bmluc3RhbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5KGFyZ3YsIGFyZ0luZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAnQCcgKyBwYWlyWzFdLFxuICAgICAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGggLSAxXS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHBhaXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYWlyWzBdID0gdjtcbiAgICAgICAgICAgICAgICBwYWlyWzFdID0gZnA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuaXNQdHIodikgfHwgbnVsbCA9PT0gdiB8fCB1bmRlZmluZWQgPT09IHYpIHtcbiAgICAgICAgICAgICAgaWYgKHBhaXIgJiYgcGFpclsxXSAmJiBwYWlyWzFdICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgaWYgKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0KFxuICAgICAgICAgICAgICAgICAgICAnRnVuY1B0ckFkYXB0ZXIgdW5pbnN0YWxsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5KGFyZ3YsIGFyZ0luZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgJ0AnICsgcGFpclsxXSxcbiAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGggLSAxXS5wdXNoKHBhaXJbMV0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgcGFpclswXSA9IHBhaXJbMV0gPSB2IHwgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdiB8fCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnSW52YWxpZCBGdW5jUHRyQWRhcHRlciBhcmd1bWVudCB0eXBlLiAnICtcbiAgICAgICAgICAgICAgICAgICdFeHBlY3RpbmcgYSBmdW5jdGlvbiBwb2ludGVyIG9yIGEgJyArXG4gICAgICAgICAgICAgICAgICAodGhpcy5uYW1lID8gdGhpcy5uYW1lICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICdmdW5jdGlvbiBtYXRjaGluZyBzaWduYXR1cmUgJyArXG4gICAgICAgICAgICAgICAgICB0aGlzLnNpZ25hdHVyZSArXG4gICAgICAgICAgICAgICAgICAnLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHhBcmcuRnVuY1B0ckFkYXB0ZXIud2Fybk9uVXNlID0gZmFsc2U7XG5cbiAgICAgICAgeEFyZy5GdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsID0gZmFsc2U7XG5cbiAgICAgICAgeEFyZy5GdW5jUHRyQWRhcHRlci5kZWJ1Z091dCA9IGNvbnNvbGUuZGVidWcuYmluZChjb25zb2xlKTtcblxuICAgICAgICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmJpbmRTY29wZXMgPSBbXG4gICAgICAgICAgJ3RyYW5zaWVudCcsXG4gICAgICAgICAgJ2NvbnRleHQnLFxuICAgICAgICAgICdzaW5nbGV0b24nLFxuICAgICAgICAgICdwZXJtYW5lbnQnLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IF9feEFyZ0FkYXB0ZXJDaGVjayA9ICh0KSA9PlxuICAgICAgICAgIHhBcmcuZ2V0KHQpIHx8IHRvc3MoJ0FyZ3VtZW50IGFkYXB0ZXIgbm90IGZvdW5kOicsIHQpO1xuXG4gICAgICAgIGNvbnN0IF9feFJlc3VsdEFkYXB0ZXJDaGVjayA9ICh0KSA9PlxuICAgICAgICAgIHhSZXN1bHQuZ2V0KHQpIHx8IHRvc3MoJ1Jlc3VsdCBhZGFwdGVyIG5vdCBmb3VuZDonLCB0KTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0QXJnID0gKHQsIC4uLmFyZ3MpID0+IF9feEFyZ0FkYXB0ZXJDaGVjayh0KSguLi5hcmdzKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0QXJnTm9DaGVjayA9ICh0LCAuLi5hcmdzKSA9PiB4QXJnLmdldCh0KSguLi5hcmdzKTtcblxuICAgICAgICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0ID0gKHQsIHYpID0+XG4gICAgICAgICAgbnVsbCA9PT0gdCA/IHYgOiB0ID8gX194UmVzdWx0QWRhcHRlckNoZWNrKHQpKHYpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHROb0NoZWNrID0gKHQsIHYpID0+XG4gICAgICAgICAgbnVsbCA9PT0gdCA/IHYgOiB0ID8geFJlc3VsdC5nZXQodCkodikgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGFyZ2V0LnhXcmFwID0gZnVuY3Rpb24gKGZBcmcsIHJlc3VsdFR5cGUsIC4uLmFyZ1R5cGVzKSB7XG4gICAgICAgICAgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pKSB7XG4gICAgICAgICAgICBhcmdUeXBlcyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhcmdldC5pc1B0cihmQXJnKSkge1xuICAgICAgICAgICAgZkFyZyA9XG4gICAgICAgICAgICAgIHRhcmdldC5mdW5jdGlvbkVudHJ5KGZBcmcpIHx8XG4gICAgICAgICAgICAgIHRvc3MoJ0Z1bmN0aW9uIHBvaW50ZXIgbm90IGZvdW5kIGluIFdBU00gZnVuY3Rpb24gdGFibGUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZJc0Z1bmMgPSBmQXJnIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gICAgICAgICAgY29uc3QgeGYgPSBmSXNGdW5jID8gZkFyZyA6IHRhcmdldC54R2V0KGZBcmcpO1xuICAgICAgICAgIGlmIChmSXNGdW5jKSBmQXJnID0geGYubmFtZSB8fCAndW5uYW1lZCBmdW5jdGlvbic7XG4gICAgICAgICAgaWYgKGFyZ1R5cGVzLmxlbmd0aCAhPT0geGYubGVuZ3RoKSBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXN1bHRUeXBlICYmIDAgPT09IHhmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHhmO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSByZXN1bHRUeXBlICYmIG51bGwgIT09IHJlc3VsdFR5cGUpXG4gICAgICAgICAgICBfX3hSZXN1bHRBZGFwdGVyQ2hlY2socmVzdWx0VHlwZSk7XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIGFyZ1R5cGVzKSB7XG4gICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIEFic3RyYWN0QXJnQWRhcHRlcilcbiAgICAgICAgICAgICAgeEFyZy5zZXQodCwgKC4uLmFyZ3MpID0+IHQuY29udmVydEFyZyguLi5hcmdzKSk7XG4gICAgICAgICAgICBlbHNlIF9feEFyZ0FkYXB0ZXJDaGVjayh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3h3ID0gY2FjaGUueFdyYXA7XG4gICAgICAgICAgaWYgKDAgPT09IHhmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PlxuICAgICAgICAgICAgICBhcmdzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogY3h3LmNvbnZlcnRSZXN1bHQocmVzdWx0VHlwZSwgeGYuY2FsbChudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSB4Zi5sZW5ndGgpIF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBzY29wZSA9IHRhcmdldC5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjeHcuY29udmVydEFyZ05vQ2hlY2soYXJnVHlwZXNbaV0sIGFyZ3NbaV0sIGFyZ3MsIGkpO1xuICAgICAgICAgICAgICByZXR1cm4gY3h3LmNvbnZlcnRSZXN1bHROb0NoZWNrKHJlc3VsdFR5cGUsIHhmLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3hBZGFwdGVyID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgYXJnYyxcbiAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICBhZGFwdGVyLFxuICAgICAgICAgIG1vZGVOYW1lLFxuICAgICAgICAgIHhjdlBhcnQsXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHR5cGVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoMSA9PT0gYXJnYykgcmV0dXJuIHhjdlBhcnQuZ2V0KHR5cGVOYW1lKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDIgPT09IGFyZ2MpIHtcbiAgICAgICAgICAgICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgICAgICAgICAgeGN2UGFydC5kZWxldGUodHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCEoYWRhcHRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRvc3MobW9kZU5hbWUsICdyZXF1aXJlcyBhIGZ1bmN0aW9uIGFyZ3VtZW50LicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHhjdlBhcnQuc2V0KHR5cGVOYW1lLCBhZGFwdGVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoJ0ludmFsaWQgYXJndW1lbnRzIHRvJywgbW9kZU5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC54V3JhcC5yZXN1bHRBZGFwdGVyID0gZnVuY3Rpb24gZih0eXBlTmFtZSwgYWRhcHRlcikge1xuICAgICAgICAgIHJldHVybiBfX3hBZGFwdGVyKFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICAncmVzdWx0QWRhcHRlcigpJyxcbiAgICAgICAgICAgIHhSZXN1bHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQueFdyYXAuYXJnQWRhcHRlciA9IGZ1bmN0aW9uIGYodHlwZU5hbWUsIGFkYXB0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gX194QWRhcHRlcihcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgICAgICBhZGFwdGVyLFxuICAgICAgICAgICAgJ2FyZ0FkYXB0ZXIoKScsXG4gICAgICAgICAgICB4QXJnLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnhXcmFwLkZ1bmNQdHJBZGFwdGVyID0geEFyZy5GdW5jUHRyQWRhcHRlcjtcblxuICAgICAgICB0YXJnZXQueENhbGxXcmFwcGVkID0gZnVuY3Rpb24gKGZBcmcsIHJlc3VsdFR5cGUsIGFyZ1R5cGVzLCAuLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzNdKSkgYXJncyA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgICAgICAueFdyYXAoZkFyZywgcmVzdWx0VHlwZSwgYXJnVHlwZXMgfHwgW10pXG4gICAgICAgICAgICAuYXBwbHkobnVsbCwgYXJncyB8fCBbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGFyZ2V0LnhXcmFwLnRlc3RDb252ZXJ0QXJnID0gY2FjaGUueFdyYXAuY29udmVydEFyZztcblxuICAgICAgICB0YXJnZXQueFdyYXAudGVzdENvbnZlcnRSZXN1bHQgPSBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0O1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIueWF3bCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgY29uc3Qgd2ZldGNoID0gKCkgPT4gZmV0Y2goY29uZmlnLnVyaSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KTtcbiAgICAgICAgY29uc3Qgd3VpID0gdGhpcztcbiAgICAgICAgY29uc3QgZmluYWxUaGVuID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgIGlmIChjb25maWcud2FzbVV0aWxUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRndCA9IGNvbmZpZy53YXNtVXRpbFRhcmdldDtcbiAgICAgICAgICAgIHRndC5tb2R1bGUgPSBhcmcubW9kdWxlO1xuICAgICAgICAgICAgdGd0Lmluc3RhbmNlID0gYXJnLmluc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoIXRndC5pbnN0YW5jZS5leHBvcnRzLm1lbW9yeSkge1xuICAgICAgICAgICAgICB0Z3QubWVtb3J5ID1cbiAgICAgICAgICAgICAgICAoY29uZmlnLmltcG9ydHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5pbXBvcnRzLmVudiAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydHMuZW52Lm1lbW9yeSkgfHxcbiAgICAgICAgICAgICAgICB0b3NzKFwiTWlzc2luZyAnbWVtb3J5JyBvYmplY3QhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0Z3QuYWxsb2MgJiYgYXJnLmluc3RhbmNlLmV4cG9ydHMubWFsbG9jKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cG9ydHMgPSBhcmcuaW5zdGFuY2UuZXhwb3J0cztcbiAgICAgICAgICAgICAgdGd0LmFsbG9jID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgZXhwb3J0cy5tYWxsb2MobikgfHwgdG9zcygnQWxsb2NhdGlvbiBvZicsIG4sICdieXRlcyBmYWlsZWQuJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0Z3QuZGVhbGxvYyA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5mcmVlKG0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3VpKHRndCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25maWcub25sb2FkKSBjb25maWcub25sb2FkKGFyZywgY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2FkV2FzbSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nXG4gICAgICAgICAgPyBmdW5jdGlvbiBsb2FkV2FzbVN0cmVhbWluZygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKFxuICAgICAgICAgICAgICAgIHdmZXRjaCgpLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5pbXBvcnRzIHx8IHt9LFxuICAgICAgICAgICAgICApLnRoZW4oZmluYWxUaGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uIGxvYWRXYXNtT2xkU2Nob29sKCkge1xuICAgICAgICAgICAgICByZXR1cm4gd2ZldGNoKClcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGJ5dGVzKSA9PlxuICAgICAgICAgICAgICAgICAgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGNvbmZpZy5pbXBvcnRzIHx8IHt9KSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLnRoZW4oZmluYWxUaGVuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBsb2FkV2FzbTtcbiAgICAgIH0uYmluZChnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIpO1xuXG4gICAgICAoJ3VzZSBzdHJpY3QnKTtcbiAgICAgIGdsb2JhbFRoaXMuSmFjY3dhYnl0ID0gZnVuY3Rpb24gU3RydWN0QmluZGVyRmFjdG9yeShjb25maWcpIHtcbiAgICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIShjb25maWcuaGVhcCBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkgJiZcbiAgICAgICAgICAhKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICkge1xuICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAnY29uZmlnLmhlYXAgbXVzdCBiZSBXZWJBc3NlbWJseS5NZW1vcnkgaW5zdGFuY2Ugb3IgYSBmdW5jdGlvbi4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgWydhbGxvYycsICdkZWFsbG9jJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIGNvbmZpZ1trXSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICB0b3NzKFwiQ29uZmlnIG9wdGlvbiAnXCIgKyBrICsgXCInIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBTQkYgPSBTdHJ1Y3RCaW5kZXJGYWN0b3J5O1xuICAgICAgICBjb25zdCBoZWFwID1cbiAgICAgICAgICAgIGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgPyBjb25maWcuaGVhcFxuICAgICAgICAgICAgICA6ICgpID0+IG5ldyBVaW50OEFycmF5KGNvbmZpZy5oZWFwLmJ1ZmZlciksXG4gICAgICAgICAgYWxsb2MgPSBjb25maWcuYWxsb2MsXG4gICAgICAgICAgZGVhbGxvYyA9IGNvbmZpZy5kZWFsbG9jLFxuICAgICAgICAgIGxvZyA9IGNvbmZpZy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICAgICAgICBtZW1iZXJQcmVmaXggPSBjb25maWcubWVtYmVyUHJlZml4IHx8ICcnLFxuICAgICAgICAgIG1lbWJlclN1ZmZpeCA9IGNvbmZpZy5tZW1iZXJTdWZmaXggfHwgJycsXG4gICAgICAgICAgYmlnSW50RW5hYmxlZCA9XG4gICAgICAgICAgICB1bmRlZmluZWQgPT09IGNvbmZpZy5iaWdJbnRFbmFibGVkXG4gICAgICAgICAgICAgID8gISFnbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J11cbiAgICAgICAgICAgICAgOiAhIWNvbmZpZy5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgIEJpZ0ludCA9IGdsb2JhbFRoaXNbJ0JpZ0ludCddLFxuICAgICAgICAgIEJpZ0ludDY0QXJyYXkgPSBnbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J10sXG4gICAgICAgICAgcHRyU2l6ZW9mID0gY29uZmlnLnB0clNpemVvZiB8fCA0LFxuICAgICAgICAgIHB0cklSID0gY29uZmlnLnB0cklSIHx8ICdpMzInO1xuICAgICAgICBpZiAoIVNCRi5kZWJ1Z0ZsYWdzKSB7XG4gICAgICAgICAgU0JGLl9fbWFrZURlYnVnRmxhZ3MgPSBmdW5jdGlvbiAoZGVyaXZlRnJvbSA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkZXJpdmVGcm9tICYmIGRlcml2ZUZyb20uX19mbGFncylcbiAgICAgICAgICAgICAgZGVyaXZlRnJvbSA9IGRlcml2ZUZyb20uX19mbGFncztcbiAgICAgICAgICAgIGNvbnN0IGYgPSBmdW5jdGlvbiBmKGZsYWdzKSB7XG4gICAgICAgICAgICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYuX19mbGFncztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGYuX19mbGFncy5nZXR0ZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGYuX19mbGFncy5zZXR0ZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGYuX19mbGFncy5hbGxvYztcbiAgICAgICAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmRlYWxsb2M7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZi5fX2ZsYWdzLmdldHRlciA9IDAgIT09ICgweDAxICYgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGYuX19mbGFncy5zZXR0ZXIgPSAwICE9PSAoMHgwMiAmIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBmLl9fZmxhZ3MuYWxsb2MgPSAwICE9PSAoMHgwNCAmIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBmLl9fZmxhZ3MuZGVhbGxvYyA9IDAgIT09ICgweDA4ICYgZmxhZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmLl9mbGFncztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgJ19fZmxhZ3MnLCB7XG4gICAgICAgICAgICAgIGl0ZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmNyZWF0ZShkZXJpdmVGcm9tKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkZXJpdmVGcm9tKSBmKDApO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTQkYuZGVidWdGbGFncyA9IFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0xpdHRsZUVuZGlhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIpO1xuICAgICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSk7XG5cbiAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKVswXSA9PT0gMjU2O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGNvbnN0IGlzRnVuY1NpZyA9IChzKSA9PiAnKCcgPT09IHNbMV07XG5cbiAgICAgICAgY29uc3QgaXNQdHJTaWcgPSAocykgPT4gJ3AnID09PSBzIHx8ICdQJyA9PT0gcztcbiAgICAgICAgY29uc3QgaXNBdXRvUHRyU2lnID0gKHMpID0+ICdQJyA9PT0gcztcbiAgICAgICAgY29uc3Qgc2lnTGV0dGVyID0gKHMpID0+IChpc0Z1bmNTaWcocykgPyAncCcgOiBzWzBdKTtcblxuICAgICAgICBjb25zdCBzaWdJUiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgc3dpdGNoIChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgIHJldHVybiAnaTgnO1xuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgIHJldHVybiAnaTMyJztcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHB0cklSO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgIHJldHVybiAnaTY0JztcbiAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2Zsb2F0JztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2RvdWJsZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoJ1VuaGFuZGxlZCBzaWduYXR1cmUgSVI6Jywgcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtQmlnSW50QXJyYXkgPSBCaWdJbnQ2NEFycmF5XG4gICAgICAgICAgPyAoKSA9PiB0cnVlXG4gICAgICAgICAgOiAoKSA9PiB0b3NzKCdCaWdJbnQ2NEFycmF5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cbiAgICAgICAgY29uc3Qgc2lnRFZHZXR0ZXIgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgIHN3aXRjaCAoc2lnTGV0dGVyKHMpKSB7XG4gICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgY2FzZSAncyc6IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwdHJTaXplb2YpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ2dldEludDMyJztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnZ2V0QmlnSW50NjQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2V0SW50MzInO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2V0SW50OCc7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdnZXRVaW50OCc7XG4gICAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ2dldEJpZ0ludDY0JztcbiAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2dldEZsb2F0MzInO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2V0RmxvYXQ2NCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoJ1VuaGFuZGxlZCBEYXRhVmlldyBnZXR0ZXIgZm9yIHNpZ25hdHVyZTonLCBzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzaWdEVlNldHRlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgc3dpdGNoIChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICBjYXNlICdzJzoge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHB0clNpemVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnc2V0SW50MzInO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdzZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdzZXRJbnQzMic7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdzZXRJbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3NldFVpbnQ4JztcbiAgICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgICByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnc2V0QmlnSW50NjQnO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgIHJldHVybiAnc2V0RmxvYXQzMic7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgcmV0dXJuICdzZXRGbG9hdDY0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcygnVW5oYW5kbGVkIERhdGFWaWV3IHNldHRlciBmb3Igc2lnbmF0dXJlOicsIHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNpZ0RWU2V0V3JhcHBlciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgc3dpdGNoIChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXI7XG4gICAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgQmlnSW50O1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICBzd2l0Y2ggKHB0clNpemVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXI7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgQmlnSW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3NzKCdVbmhhbmRsZWQgRGF0YVZpZXcgc2V0IHdyYXBwZXIgZm9yIHNpZ25hdHVyZTonLCBzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzUHJvcE5hbWUgPSAocywgaykgPT4gcyArICc6OicgKyBrO1xuXG4gICAgICAgIGNvbnN0IF9fcHJvcFRocm93T25TZXQgPSBmdW5jdGlvbiAoc3RydWN0TmFtZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gdG9zcyhzUHJvcE5hbWUoc3RydWN0TmFtZSwgcHJvcE5hbWUpLCAnaXMgcmVhZC1vbmx5LicpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9faW5zdGFuY2VQb2ludGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgICBjb25zdCB4UHRyUHJvcE5hbWUgPSAnKHBvaW50ZXItaXMtZXh0ZXJuYWwpJztcblxuICAgICAgICBjb25zdCBfX2ZyZWVTdHJ1Y3QgPSBmdW5jdGlvbiAoY3Rvciwgb2JqLCBtKSB7XG4gICAgICAgICAgaWYgKCFtKSBtID0gX19pbnN0YW5jZVBvaW50ZXJNYXAuZ2V0KG9iaik7XG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIF9faW5zdGFuY2VQb2ludGVyTWFwLmRlbGV0ZShvYmopO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLm9uZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICAgIHdoaWxlICgoeCA9IG9iai5vbmRpc3Bvc2Uuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgeC5jYWxsKG9iaik7XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICh4IGluc3RhbmNlb2YgU3RydWN0VHlwZSkgeC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHgpIGRlYWxsb2MoeCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAnb25kaXNwb3NlKCkgZm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgICAgICd0aHJldy4gTk9UIHByb3BhZ2F0aW5nIGl0LicsXG4gICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmoub25kaXNwb3NlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmoub25kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnb25kaXNwb3NlKCkgZm9yJyxcbiAgICAgICAgICAgICAgICAgIGN0b3Iuc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgICAndGhyZXcuIE5PVCBwcm9wYWdhdGluZyBpdC4nLFxuICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgb2JqLm9uZGlzcG9zZTtcbiAgICAgICAgICAgIGlmIChjdG9yLmRlYnVnRmxhZ3MuX19mbGFncy5kZWFsbG9jKSB7XG4gICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAnZGVidWcuZGVhbGxvYzonLFxuICAgICAgICAgICAgICAgIG9ialt4UHRyUHJvcE5hbWVdID8gJ0VYVEVSTkFMJyA6ICcnLFxuICAgICAgICAgICAgICAgIGN0b3Iuc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgICAnaW5zdGFuY2U6JyxcbiAgICAgICAgICAgICAgICBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mLFxuICAgICAgICAgICAgICAgICdieXRlcyBAJyArIG0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9ialt4UHRyUHJvcE5hbWVdKSBkZWFsbG9jKG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByb3AgPSAodikgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgaXRlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FsbG9jU3RydWN0ID0gZnVuY3Rpb24gKGN0b3IsIG9iaiwgbSkge1xuICAgICAgICAgIGxldCBmaWxsID0gIW07XG4gICAgICAgICAgaWYgKG0pIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHhQdHJQcm9wTmFtZSwgcm9wKG0pKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBhbGxvYyhjdG9yLnN0cnVjdEluZm8uc2l6ZW9mKTtcbiAgICAgICAgICAgIGlmICghbSkgdG9zcygnQWxsb2NhdGlvbiBvZicsIGN0b3Iuc3RydWN0TmFtZSwgJ3N0cnVjdHVyZSBmYWlsZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY3Rvci5kZWJ1Z0ZsYWdzLl9fZmxhZ3MuYWxsb2MpIHtcbiAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICdkZWJ1Zy5hbGxvYzonLFxuICAgICAgICAgICAgICAgIGZpbGwgPyAnJyA6ICdFWFRFUk5BTCcsXG4gICAgICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICdpbnN0YW5jZTonLFxuICAgICAgICAgICAgICAgIGN0b3Iuc3RydWN0SW5mby5zaXplb2YsXG4gICAgICAgICAgICAgICAgJ2J5dGVzIEAnICsgbSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsKSBoZWFwKCkuZmlsbCgwLCBtLCBtICsgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZik7XG4gICAgICAgICAgICBfX2luc3RhbmNlUG9pbnRlck1hcC5zZXQob2JqLCBtKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfX2ZyZWVTdHJ1Y3QoY3Rvciwgb2JqLCBtKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWVtb3J5RHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBwID0gdGhpcy5wb2ludGVyO1xuICAgICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICA/IG5ldyBVaW50OEFycmF5KGhlYXAoKS5zbGljZShwLCBwICsgdGhpcy5zdHJ1Y3RJbmZvLnNpemVvZikpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1iZXJLZXkgPSAoaykgPT4gbWVtYmVyUHJlZml4ICsgayArIG1lbWJlclN1ZmZpeDtcbiAgICAgICAgY29uc3QgX19tZW1iZXJLZXlQcm9wID0gcm9wKF9fbWVtYmVyS2V5KTtcblxuICAgICAgICBjb25zdCBfX2xvb2t1cE1lbWJlciA9IGZ1bmN0aW9uIChcbiAgICAgICAgICBzdHJ1Y3RJbmZvLFxuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgdG9zc0lmTm90Rm91bmQgPSB0cnVlLFxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgbSA9IHN0cnVjdEluZm8ubWVtYmVyc1ttZW1iZXJOYW1lXTtcbiAgICAgICAgICBpZiAoIW0gJiYgKG1lbWJlclByZWZpeCB8fCBtZW1iZXJTdWZmaXgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyhzdHJ1Y3RJbmZvLm1lbWJlcnMpKSB7XG4gICAgICAgICAgICAgIGlmICh2LmtleSA9PT0gbWVtYmVyTmFtZSkge1xuICAgICAgICAgICAgICAgIG0gPSB2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW0gJiYgdG9zc0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICBzUHJvcE5hbWUoc3RydWN0SW5mby5uYW1lLCBtZW1iZXJOYW1lKSxcbiAgICAgICAgICAgICAgICAnaXMgbm90IGEgbWFwcGVkIHN0cnVjdCBtZW1iZXIuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19tZW1iZXJTaWduYXR1cmUgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgIG9iaixcbiAgICAgICAgICBtZW1iZXJOYW1lLFxuICAgICAgICAgIGVtc2NyaXB0ZW5Gb3JtYXQgPSBmYWxzZSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCFmLl8pXG4gICAgICAgICAgICBmLl8gPSAoeCkgPT5cbiAgICAgICAgICAgICAgeC5yZXBsYWNlKC9bXnZpcFBzanJkY0NdL2csICcnKS5yZXBsYWNlKC9bcFBzY0NdL2csICdpJyk7XG4gICAgICAgICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gZW1zY3JpcHRlbkZvcm1hdCA/IGYuXyhtLnNpZ25hdHVyZSkgOiBtLnNpZ25hdHVyZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3B0clByb3BEZXNjcmlwdG9yID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19pbnN0YW5jZVBvaW50ZXJNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiAoKSA9PiB0b3NzKFwiQ2Fubm90IGFzc2lnbiB0aGUgJ3BvaW50ZXInIHByb3BlcnR5IG9mIGEgc3RydWN0LlwiKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3N0cnVjdE1lbWJlcktleXMgPSByb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy5zdHJ1Y3RJbmZvLm1lbWJlcnMpKSB7XG4gICAgICAgICAgICBhLnB1c2godGhpcy5tZW1iZXJLZXkoaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgX191dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICAgICAgY29uc3QgX191dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIGNvbnN0IF9fU0FCID1cbiAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICAgICAgICBjb25zdCBfX3V0ZjhEZWNvZGUgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gX191dGY4RGVjb2Rlci5kZWNvZGUoXG4gICAgICAgICAgICBhcnJheUJ1ZmZlci5idWZmZXIgaW5zdGFuY2VvZiBfX1NBQlxuICAgICAgICAgICAgICA/IGFycmF5QnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpXG4gICAgICAgICAgICAgIDogYXJyYXlCdWZmZXIuc3ViYXJyYXkoYmVnaW4sIGVuZCksXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX21lbWJlcklzU3RyaW5nID0gZnVuY3Rpb24gKFxuICAgICAgICAgIG9iaixcbiAgICAgICAgICBtZW1iZXJOYW1lLFxuICAgICAgICAgIHRvc3NJZk5vdEZvdW5kID0gZmFsc2UsXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQpO1xuICAgICAgICAgIHJldHVybiBtICYmIDEgPT09IG0uc2lnbmF0dXJlLmxlbmd0aCAmJiAncycgPT09IG0uc2lnbmF0dXJlWzBdXG4gICAgICAgICAgICA/IG1cbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlID0gZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICAgIGlmICgncycgPT09IG1lbWJlci5zaWduYXR1cmUpIHJldHVybjtcbiAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgJ0ludmFsaWQgbWVtYmVyIHR5cGUgc2lnbmF0dXJlIGZvciBDLXN0cmluZyB2YWx1ZTonLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWVtYmVyKSxcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWVtYmVyVG9Kc1N0cmluZyA9IGZ1bmN0aW9uIGYob2JqLCBtZW1iZXJOYW1lKSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0cnVlKTtcbiAgICAgICAgICBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUobSk7XG4gICAgICAgICAgY29uc3QgYWRkciA9IG9ialttLmtleV07XG5cbiAgICAgICAgICBpZiAoIWFkZHIpIHJldHVybiBudWxsO1xuICAgICAgICAgIGxldCBwb3MgPSBhZGRyO1xuICAgICAgICAgIGNvbnN0IG1lbSA9IGhlYXAoKTtcbiAgICAgICAgICBmb3IgKDsgbWVtW3Bvc10gIT09IDA7ICsrcG9zKSB7fVxuXG4gICAgICAgICAgcmV0dXJuIGFkZHIgPT09IHBvcyA/ICcnIDogX191dGY4RGVjb2RlKG1lbSwgYWRkciwgcG9zKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2FkZE9uRGlzcG9zZSA9IGZ1bmN0aW9uIChvYmosIC4uLnYpIHtcbiAgICAgICAgICBpZiAob2JqLm9uZGlzcG9zZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iai5vbmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgIG9iai5vbmRpc3Bvc2UgPSBbb2JqLm9uZGlzcG9zZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iai5vbmRpc3Bvc2UgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqLm9uZGlzcG9zZS5wdXNoKC4uLnYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fYWxsb2NDU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgIGNvbnN0IHUgPSBfX3V0ZjhFbmNvZGVyLmVuY29kZShzdHIpO1xuICAgICAgICAgIGNvbnN0IG1lbSA9IGFsbG9jKHUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgaWYgKCFtZW0pIHRvc3MoJ0FsbG9jYXRpb24gZXJyb3Igd2hpbGUgZHVwbGljYXRpbmcgc3RyaW5nOicsIHN0cik7XG4gICAgICAgICAgY29uc3QgaCA9IGhlYXAoKTtcblxuICAgICAgICAgIGguc2V0KHUsIG1lbSk7XG4gICAgICAgICAgaFttZW0gKyB1Lmxlbmd0aF0gPSAwO1xuXG4gICAgICAgICAgcmV0dXJuIG1lbTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NldE1lbWJlckNTdHJpbmcgPSBmdW5jdGlvbiAob2JqLCBtZW1iZXJOYW1lLCBzdHIpIHtcbiAgICAgICAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgICAgICAgIF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZShtKTtcblxuICAgICAgICAgIGNvbnN0IG1lbSA9IF9fYWxsb2NDU3RyaW5nKHN0cik7XG4gICAgICAgICAgb2JqW20ua2V5XSA9IG1lbTtcbiAgICAgICAgICBfX2FkZE9uRGlzcG9zZShvYmosIG1lbSk7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBTdHJ1Y3RUeXBlID0gZnVuY3Rpb24gY3RvcihzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1syXSAhPT0gcm9wKSB7XG4gICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAnRG8gbm90IGNhbGwgdGhlIFN0cnVjdFR5cGUgY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAnZnJvbSBjbGllbnQtbGV2ZWwgY29kZS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgc3RydWN0TmFtZTogcm9wKHN0cnVjdE5hbWUpLFxuICAgICAgICAgICAgc3RydWN0SW5mbzogcm9wKHN0cnVjdEluZm8pLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0cnVjdFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgZGlzcG9zZTogcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9fZnJlZVN0cnVjdCh0aGlzLmNvbnN0cnVjdG9yLCB0aGlzKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsb29rdXBNZW1iZXI6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19sb29rdXBNZW1iZXIodGhpcy5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtYmVyVG9Kc1N0cmluZzogcm9wKGZ1bmN0aW9uIChtZW1iZXJOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gX19tZW1iZXJUb0pzU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1lbWJlcklzU3RyaW5nOiByb3AoZnVuY3Rpb24gKG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fbWVtYmVySXNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgICAgIG1lbWJlcktleXM6IF9fc3RydWN0TWVtYmVyS2V5cyxcbiAgICAgICAgICBtZW1iZXJTaWduYXR1cmU6IHJvcChmdW5jdGlvbiAobWVtYmVyTmFtZSwgZW1zY3JpcHRlbkZvcm1hdCA9IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19tZW1iZXJTaWduYXR1cmUodGhpcywgbWVtYmVyTmFtZSwgZW1zY3JpcHRlbkZvcm1hdCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVtb3J5RHVtcDogcm9wKF9fbWVtb3J5RHVtcCksXG4gICAgICAgICAgcG9pbnRlcjogX19wdHJQcm9wRGVzY3JpcHRvcixcbiAgICAgICAgICBzZXRNZW1iZXJDU3RyaW5nOiByb3AoZnVuY3Rpb24gKG1lbWJlck5hbWUsIHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2V0TWVtYmVyQ1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lLCBzdHIpO1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKFN0cnVjdFR5cGUucHJvdG90eXBlLCB7XG4gICAgICAgICAgYWRkT25EaXNwb3NlOiBmdW5jdGlvbiAoLi4udikge1xuICAgICAgICAgICAgX19hZGRPbkRpc3Bvc2UodGhpcywgLi4udik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RUeXBlLCB7XG4gICAgICAgICAgYWxsb2NDU3RyaW5nOiByb3AoX19hbGxvY0NTdHJpbmcpLFxuICAgICAgICAgIGlzQTogcm9wKCh2KSA9PiB2IGluc3RhbmNlb2YgU3RydWN0VHlwZSksXG4gICAgICAgICAgaGFzRXh0ZXJuYWxQb2ludGVyOiByb3AoXG4gICAgICAgICAgICAodikgPT4gdiBpbnN0YW5jZW9mIFN0cnVjdFR5cGUgJiYgISF2W3hQdHJQcm9wTmFtZV0sXG4gICAgICAgICAgKSxcbiAgICAgICAgICBtZW1iZXJLZXk6IF9fbWVtYmVyS2V5UHJvcCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaXNOdW1lcmljVmFsdWUgPSAodikgPT5cbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodikgfHwgdiBpbnN0YW5jZW9mIChCaWdJbnQgfHwgTnVtYmVyKTtcblxuICAgICAgICBjb25zdCBtYWtlTWVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIGYoY3RvciwgbmFtZSwgZGVzY3IpIHtcbiAgICAgICAgICBpZiAoIWYuXykge1xuICAgICAgICAgICAgZi5fID0geyBnZXR0ZXJzOiB7fSwgc2V0dGVyczoge30sIHN3OiB7fSB9O1xuICAgICAgICAgICAgY29uc3QgYSA9IFsnaScsICdjJywgJ0MnLCAncCcsICdQJywgJ3MnLCAnZicsICdkJywgJ3YoKSddO1xuICAgICAgICAgICAgaWYgKGJpZ0ludEVuYWJsZWQpIGEucHVzaCgnaicpO1xuICAgICAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIGYuXy5nZXR0ZXJzW3ZdID0gc2lnRFZHZXR0ZXIodik7XG4gICAgICAgICAgICAgIGYuXy5zZXR0ZXJzW3ZdID0gc2lnRFZTZXR0ZXIodik7XG4gICAgICAgICAgICAgIGYuXy5zd1t2XSA9IHNpZ0RWU2V0V3JhcHBlcih2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcnhTaWcxID0gL15baXBQc2pmZGNDXSQvLFxuICAgICAgICAgICAgICByeFNpZzIgPSAvXlt2aXBQc2pmZGNDXVxcKFtpcFBzamZkY0NdKlxcKSQvO1xuICAgICAgICAgICAgZi5zaWdDaGVjayA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIGtleSwgc2lnKSB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhvYmouc3RydWN0TmFtZSwgJ2FscmVhZHkgaGFzIGEgcHJvcGVydHkgbmFtZWQnLCBrZXkgKyAnLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJ4U2lnMS50ZXN0KHNpZykgfHxcbiAgICAgICAgICAgICAgICByeFNpZzIudGVzdChzaWcpIHx8XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICdNYWxmb3JtZWQgc2lnbmF0dXJlIGZvcicsXG4gICAgICAgICAgICAgICAgICBzUHJvcE5hbWUob2JqLnN0cnVjdE5hbWUsIG5hbWUpICsgJzonLFxuICAgICAgICAgICAgICAgICAgc2lnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBrZXkgPSBjdG9yLm1lbWJlcktleShuYW1lKTtcbiAgICAgICAgICBmLnNpZ0NoZWNrKGN0b3IucHJvdG90eXBlLCBuYW1lLCBrZXksIGRlc2NyLnNpZ25hdHVyZSk7XG4gICAgICAgICAgZGVzY3Iua2V5ID0ga2V5O1xuICAgICAgICAgIGRlc2NyLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIGNvbnN0IHNpZ0dseXBoID0gc2lnTGV0dGVyKGRlc2NyLnNpZ25hdHVyZSk7XG4gICAgICAgICAgY29uc3QgeFByb3BOYW1lID0gc1Byb3BOYW1lKGN0b3IucHJvdG90eXBlLnN0cnVjdE5hbWUsIGtleSk7XG4gICAgICAgICAgY29uc3QgZGJnID0gY3Rvci5wcm90b3R5cGUuZGVidWdGbGFncy5fX2ZsYWdzO1xuXG4gICAgICAgICAgY29uc3QgcHJvcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgcHJvcC5jb25maWd1cmFibGUgPSBmYWxzZTtcbiAgICAgICAgICBwcm9wLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICBwcm9wLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkYmcuZ2V0dGVyKSB7XG4gICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAnZGVidWcuZ2V0dGVyOicsXG4gICAgICAgICAgICAgICAgZi5fLmdldHRlcnNbc2lnR2x5cGhdLFxuICAgICAgICAgICAgICAgICdmb3InLFxuICAgICAgICAgICAgICAgIHNpZ0lSKHNpZ0dseXBoKSxcbiAgICAgICAgICAgICAgICB4UHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAnKycsXG4gICAgICAgICAgICAgICAgZGVzY3Iub2Zmc2V0LFxuICAgICAgICAgICAgICAgICdzeicsXG4gICAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJjID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgICBoZWFwKCkuYnVmZmVyLFxuICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIgKyBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgIGRlc2NyLnNpemVvZixcbiAgICAgICAgICAgIClbZi5fLmdldHRlcnNbc2lnR2x5cGhdXSgwLCBpc0xpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBpZiAoZGJnLmdldHRlcikgbG9nKCdkZWJ1Zy5nZXR0ZXI6JywgeFByb3BOYW1lLCAncmVzdWx0ID0nLCByYyk7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZGVzY3IucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHByb3Auc2V0ID0gX19wcm9wVGhyb3dPblNldChjdG9yLnByb3RvdHlwZS5zdHJ1Y3ROYW1lLCBrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIGlmIChkYmcuc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgJ2RlYnVnLnNldHRlcjonLFxuICAgICAgICAgICAgICAgICAgZi5fLnNldHRlcnNbc2lnR2x5cGhdLFxuICAgICAgICAgICAgICAgICAgJ2ZvcicsXG4gICAgICAgICAgICAgICAgICBzaWdJUihzaWdHbHlwaCksXG4gICAgICAgICAgICAgICAgICB4UHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgICAnKycsXG4gICAgICAgICAgICAgICAgICBkZXNjci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAnc3onLFxuICAgICAgICAgICAgICAgICAgZGVzY3Iuc2l6ZW9mLFxuICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnQ2Fubm90IHNldCBzdHJ1Y3QgcHJvcGVydHkgb24gZGlzcG9zZWQgaW5zdGFuY2UuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHYpIHYgPSAwO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bWVyaWNWYWx1ZSh2KSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpc0F1dG9QdHJTaWcoZGVzY3Iuc2lnbmF0dXJlKSAmJlxuICAgICAgICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgU3RydWN0VHlwZVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB2LnBvaW50ZXIgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRiZy5zZXR0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgbG9nKCdkZWJ1Zy5zZXR0ZXI6JywgeFByb3BOYW1lLCAncmVzb2x2ZWQgdG8nLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0b3NzKCdJbnZhbGlkIHZhbHVlIGZvciBwb2ludGVyLXR5cGUnLCB4UHJvcE5hbWUgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgICAgIGhlYXAoKS5idWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyICsgZGVzY3Iub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGRlc2NyLnNpemVvZixcbiAgICAgICAgICAgICAgKVtmLl8uc2V0dGVyc1tzaWdHbHlwaF1dKDAsIGYuXy5zd1tzaWdHbHlwaF0odiksIGlzTGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwga2V5LCBwcm9wKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBTdHJ1Y3RCaW5kZXIgPSBmdW5jdGlvbiBTdHJ1Y3RCaW5kZXIoc3RydWN0TmFtZSwgc3RydWN0SW5mbykge1xuICAgICAgICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJ1Y3RJbmZvID0gc3RydWN0TmFtZTtcbiAgICAgICAgICAgIHN0cnVjdE5hbWUgPSBzdHJ1Y3RJbmZvLm5hbWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RydWN0SW5mby5uYW1lKSB7XG4gICAgICAgICAgICBzdHJ1Y3RJbmZvLm5hbWUgPSBzdHJ1Y3ROYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0cnVjdE5hbWUpIHRvc3MoJ1N0cnVjdCBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICAgIGxldCBsYXN0TWVtYmVyID0gZmFsc2U7XG4gICAgICAgICAgT2JqZWN0LmtleXMoc3RydWN0SW5mby5tZW1iZXJzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtID0gc3RydWN0SW5mby5tZW1iZXJzW2tdO1xuICAgICAgICAgICAgaWYgKCFtLnNpemVvZikgdG9zcyhzdHJ1Y3ROYW1lLCAnbWVtYmVyJywgaywgJ2lzIG1pc3Npbmcgc2l6ZW9mLicpO1xuICAgICAgICAgICAgZWxzZSBpZiAobS5zaXplb2YgPT09IDEpIHtcbiAgICAgICAgICAgICAgbS5zaWduYXR1cmUgPT09ICdjJyB8fFxuICAgICAgICAgICAgICAgIG0uc2lnbmF0dXJlID09PSAnQycgfHxcbiAgICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgc2l6ZW9mPT0xIG1lbWJlcicsXG4gICAgICAgICAgICAgICAgICBzUHJvcE5hbWUoc3RydWN0SW5mby5uYW1lLCBrKSxcbiAgICAgICAgICAgICAgICAgICd3aXRoIHNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgICBtLnNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKDAgIT09IG0uc2l6ZW9mICUgNCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHN0cnVjdCBtZW1iZXIgZGVzY3JpcHRpb24gPScsXG4gICAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgICAgJ2Zyb20nLFxuICAgICAgICAgICAgICAgICAgc3RydWN0SW5mbyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgJ21lbWJlcicsXG4gICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgJ3NpemVvZiBpcyBub3QgYWxpZ25lZC4gc2l6ZW9mPScgKyBtLnNpemVvZixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgwICE9PSBtLm9mZnNldCAlIDQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCBzdHJ1Y3QgbWVtYmVyIGRlc2NyaXB0aW9uID0nLFxuICAgICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICAgICdmcm9tJyxcbiAgICAgICAgICAgICAgICAgIHN0cnVjdEluZm8sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICAgc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICdtZW1iZXInLFxuICAgICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICAgICdvZmZzZXQgaXMgbm90IGFsaWduZWQuIG9mZnNldD0nICsgbS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXN0TWVtYmVyIHx8IGxhc3RNZW1iZXIub2Zmc2V0IDwgbS5vZmZzZXQpIGxhc3RNZW1iZXIgPSBtO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghbGFzdE1lbWJlcikgdG9zcygnTm8gbWVtYmVyIHByb3BlcnR5IGRlc2NyaXB0aW9ucyBmb3VuZC4nKTtcbiAgICAgICAgICBlbHNlIGlmIChzdHJ1Y3RJbmZvLnNpemVvZiA8IGxhc3RNZW1iZXIub2Zmc2V0ICsgbGFzdE1lbWJlci5zaXplb2YpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnZhbGlkIHN0cnVjdCBjb25maWc6JyxcbiAgICAgICAgICAgICAgc3RydWN0TmFtZSxcbiAgICAgICAgICAgICAgJ21heCBtZW1iZXIgb2Zmc2V0ICgnICsgbGFzdE1lbWJlci5vZmZzZXQgKyAnKSAnLFxuICAgICAgICAgICAgICAnZXh0ZW5kcyBwYXN0IGVuZCBvZiBzdHJ1Y3QgKHNpemVvZj0nICsgc3RydWN0SW5mby5zaXplb2YgKyAnKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVidWdGbGFncyA9IHJvcChTQkYuX19tYWtlRGVidWdGbGFncyhTdHJ1Y3RCaW5kZXIuZGVidWdGbGFncykpO1xuXG4gICAgICAgICAgY29uc3QgU3RydWN0Q3RvciA9IGZ1bmN0aW9uIFN0cnVjdEN0b3IoZXh0ZXJuYWxNZW1vcnkpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJ1Y3RDdG9yKSkge1xuICAgICAgICAgICAgICB0b3NzKFxuICAgICAgICAgICAgICAgICdUaGUnLFxuICAgICAgICAgICAgICAgIHN0cnVjdE5hbWUsXG4gICAgICAgICAgICAgICAgXCJjb25zdHJ1Y3RvciBtYXkgb25seSBiZSBjYWxsZWQgdmlhICduZXcnLlwiLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBleHRlcm5hbE1lbW9yeSAhPT0gKGV4dGVybmFsTWVtb3J5IHwgMCkgfHxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE1lbW9yeSA8PSAwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgcG9pbnRlciB2YWx1ZSBmb3InLCBzdHJ1Y3ROYW1lLCAnY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX19hbGxvY1N0cnVjdChTdHJ1Y3RDdG9yLCB0aGlzLCBleHRlcm5hbE1lbW9yeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfX2FsbG9jU3RydWN0KFN0cnVjdEN0b3IsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3RydWN0Q3Rvciwge1xuICAgICAgICAgICAgZGVidWdGbGFnczogZGVidWdGbGFncyxcbiAgICAgICAgICAgIGlzQTogcm9wKCh2KSA9PiB2IGluc3RhbmNlb2YgU3RydWN0Q3RvciksXG4gICAgICAgICAgICBtZW1iZXJLZXk6IF9fbWVtYmVyS2V5UHJvcCxcbiAgICAgICAgICAgIG1lbWJlcktleXM6IF9fc3RydWN0TWVtYmVyS2V5cyxcbiAgICAgICAgICAgIG1ldGhvZEluZm9Gb3JLZXk6IHJvcChmdW5jdGlvbiAobUtleSkge30pLFxuICAgICAgICAgICAgc3RydWN0SW5mbzogcm9wKHN0cnVjdEluZm8pLFxuICAgICAgICAgICAgc3RydWN0TmFtZTogcm9wKHN0cnVjdE5hbWUpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFN0cnVjdEN0b3IucHJvdG90eXBlID0gbmV3IFN0cnVjdFR5cGUoc3RydWN0TmFtZSwgc3RydWN0SW5mbywgcm9wKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgZGVidWdGbGFnczogZGVidWdGbGFncyxcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiByb3AoU3RydWN0Q3RvciksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoc3RydWN0SW5mby5tZW1iZXJzKS5mb3JFYWNoKChuYW1lKSA9PlxuICAgICAgICAgICAgbWFrZU1lbWJlcldyYXBwZXIoU3RydWN0Q3RvciwgbmFtZSwgc3RydWN0SW5mby5tZW1iZXJzW25hbWVdKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBTdHJ1Y3RDdG9yO1xuICAgICAgICB9O1xuICAgICAgICBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZSA9IFN0cnVjdFR5cGU7XG4gICAgICAgIFN0cnVjdEJpbmRlci5jb25maWcgPSBjb25maWc7XG4gICAgICAgIFN0cnVjdEJpbmRlci5hbGxvY0NTdHJpbmcgPSBfX2FsbG9jQ1N0cmluZztcbiAgICAgICAgaWYgKCFTdHJ1Y3RCaW5kZXIuZGVidWdGbGFncykge1xuICAgICAgICAgIFN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzID0gU0JGLl9fbWFrZURlYnVnRmxhZ3MoU0JGLmRlYnVnRmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJ1Y3RCaW5kZXI7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3NzMyA9IHNxbGl0ZTMuU1FMaXRlM0Vycm9yLnRvc3M7XG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGksXG4gICAgICAgICAgd2FzbSA9IHNxbGl0ZTMud2FzbSxcbiAgICAgICAgICB1dGlsID0gc3FsaXRlMy51dGlsO1xuICAgICAgICBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIod2FzbSk7XG4gICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXI7XG5cbiAgICAgICAgaWYgKDApIHtcbiAgICAgICAgICBjb25zdCBkZWFsbG9jID0gd2FzbS5leHBvcnRzW3NxbGl0ZTMuY29uZmlnLmRlYWxsb2NFeHBvcnROYW1lXTtcbiAgICAgICAgICBjb25zdCBuRnVuYyA9IHdhc20uZnVuY3Rpb25UYWJsZSgpLmxlbmd0aDtcbiAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbkZ1bmM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IHdhc20uZnVuY3Rpb25FbnRyeShpKTtcbiAgICAgICAgICAgIGlmIChkZWFsbG9jID09PSBlKSB7XG4gICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVhbGxvYyAhPT0gd2FzbS5mdW5jdGlvbkVudHJ5KGNhcGkuU1FMSVRFX1dBU01fREVBTExPQykpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdJbnRlcm5hbCBlcnJvcjogY2Fubm90IGZpbmQgZnVuY3Rpb24gcG9pbnRlciBmb3IgU1FMSVRFX1dBU01fREVBTExPQy4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzID0gW1xuICAgICAgICAgIFsnc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCcsICd2b2lkKicsICdzcWxpdGUzX2NvbnRleHQqJywgJ2ludCddLFxuXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfZG91YmxlJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdmNjQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfYmluZF9pbnQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConLCAnaW50JywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX251bGwnLCB1bmRlZmluZWQsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCcsICdpbnQnLCAnc3FsaXRlM19zdG10KicsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfbmFtZScsICdzdHJpbmcnLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19iaW5kX3BvaW50ZXInLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnc3FsaXRlM19zdG10KicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2J1c3lfaGFuZGxlcicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGkpJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX2J1c3lfdGltZW91dCcsICdpbnQnLCAnc3FsaXRlMyonLCAnaW50J10sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlcycsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCcsICdpbnQnLCAnc3FsaXRlMyonLCAnKicsICcqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl9ibG9iJywgJyonLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX2J5dGVzJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fY291bnQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX2RlY2x0eXBlJywgJ3N0cmluZycsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fZG91YmxlJywgJ2Y2NCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5faW50JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fbmFtZScsICdzdHJpbmcnLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29sdW1uX3RleHQnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbHVtbl90eXBlJywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5fdmFsdWUnLCAnc3FsaXRlM192YWx1ZSonLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NxbGl0ZTNfY29tbWl0X2hvb2snLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocCknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2KSA9PiBhcmd2WzBdLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCcsICdzdHJpbmcnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCcsICdpbnQnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2NvbXBsZXRlJywgJ2ludCcsICdzdHJpbmc6ZmxleGlibGUnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUnLCAnc3FsaXRlMyonLCAnc3FsaXRlM19jb250ZXh0KiddLFxuXG4gICAgICAgICAgWydzcWxpdGUzX2RhdGFfY291bnQnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGJfZmlsZW5hbWUnLCAnc3RyaW5nJywgJ3NxbGl0ZTMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9oYW5kbGUnLCAnc3FsaXRlMyonLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9uYW1lJywgJ3N0cmluZycsICdzcWxpdGUzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZGJfcmVhZG9ubHknLCAnaW50JywgJ3NxbGl0ZTMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19kYl9zdGF0dXMnLCAnaW50JywgJ3NxbGl0ZTMqJywgJ2ludCcsICcqJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX2VycmNvZGUnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2Vycm1zZycsICdzdHJpbmcnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0JywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19lcnJzdHInLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX2V4ZWMnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmc6ZmxleGlibGUnLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaXBwKScsXG4gICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IGFOYW1lcztcbiAgICAgICAgICAgICAgICAgIHJldHVybiAocFZvaWQsIG5Db2xzLCBwQ29sVmFscywgcENvbE5hbWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgYVZhbHMgPSB3YXNtLmNBcmd2VG9KcyhuQ29scywgcENvbFZhbHMpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghYU5hbWVzKSBhTmFtZXMgPSB3YXNtLmNBcmd2VG9KcyhuQ29scywgcENvbE5hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYVZhbHMsIGFOYW1lcykgfCAwO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19leHBhbmRlZF9zcWwnLCAnc3RyaW5nJywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZScsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzJywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZmlsZV9jb250cm9sJywgJ2ludCcsICdzcWxpdGUzKicsICdzdHJpbmcnLCAnaW50JywgJyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZmluYWxpemUnLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZnJlZScsIHVuZGVmaW5lZCwgJyonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2dldF9hdXhkYXRhJywgJyonLCAnc3FsaXRlM19jb250ZXh0KicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfaW5pdGlhbGl6ZScsIHVuZGVmaW5lZF0sXG4gICAgICAgICAgWydzcWxpdGUzX2ludGVycnVwdCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2lzX2ludGVycnVwdGVkJywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19rZXl3b3JkX2NvdW50JywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19rZXl3b3JkX25hbWUnLCAnaW50JywgWydpbnQnLCAnKionLCAnKiddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfa2V5d29yZF9jaGVjaycsICdpbnQnLCBbJ3N0cmluZycsICdpbnQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX2xpYnZlcnNpb24nLCAnc3RyaW5nJ10sXG4gICAgICAgICAgWydzcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19saW1pdCcsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ2ludCcsICdpbnQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX21hbGxvYycsICcqJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19vcGVuJywgJ2ludCcsICdzdHJpbmcnLCAnKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19vcGVuX3YyJywgJ2ludCcsICdzdHJpbmcnLCAnKicsICdpbnQnLCAnc3RyaW5nJ10sXG5cbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVhbGxvYycsICcqJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc2V0JywgJ2ludCcsICdzcWxpdGUzX3N0bXQqJ10sXG5cbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yZXN1bHRfYmxvYicsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfZG91YmxlJywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KicsICdmNjQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yZXN1bHRfZXJyb3InLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZScsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbScsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZycsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X2ludCcsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfY29udGV4dConLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9udWxsJywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KiddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Jlc3VsdF9wb2ludGVyJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19yZXN1bHRfc3VidHlwZScsIHVuZGVmaW5lZCwgJ3NxbGl0ZTNfdmFsdWUqJywgJ2ludCddLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Jlc3VsdF90ZXh0JyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iJywgdW5kZWZpbmVkLCAnc3FsaXRlM19jb250ZXh0KicsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19yb2xsYmFja19ob29rJyxcbiAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3FsaXRlM19yb2xsYmFja19ob29rJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KHApJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndikgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcblxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3NldF9hdXhkYXRhJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfY29udGV4dConLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgPyAnKidcbiAgICAgICAgICAgICAgICA6IG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hEZXN0cm95QXV4RGF0YScsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YocCknLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc2h1dGRvd24nLCB1bmRlZmluZWRdLFxuICAgICAgICAgIFsnc3FsaXRlM19zb3VyY2VpZCcsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3FsJywgJ3N0cmluZycsICdzcWxpdGUzX3N0bXQqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0YXR1cycsICdpbnQnLCAnaW50JywgJyonLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RlcCcsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdG10X2J1c3knLCAnaW50JywgJ3NxbGl0ZTNfc3RtdConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RtdF9yZWFkb25seScsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdG10X3N0YXR1cycsICdpbnQnLCAnc3FsaXRlM19zdG10KicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3N0cmdsb2InLCAnaW50JywgJ3N0cmluZycsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RyaWNtcCcsICdpbnQnLCAnc3RyaW5nJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdHJsaWtlJywgJ2ludCcsICdzdHJpbmcnLCAnc3RyaW5nJywgJ2ludCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zdHJuaWNtcCcsICdpbnQnLCAnc3RyaW5nJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdG90YWxfY2hhbmdlcycsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM190cmFjZV92MicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3FsaXRlM190cmFjZV92Mjo6Y2FsbGJhY2snLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2koaXBwcCknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdHhuX3N0YXRlJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nJ11dLFxuXG4gICAgICAgICAgWydzcWxpdGUzX3VyaV9ib29sZWFuJywgJ2ludCcsICdzcWxpdGUzX2ZpbGVuYW1lJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2tleScsICdzdHJpbmcnLCAnc3FsaXRlM19maWxlbmFtZScsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX3BhcmFtZXRlcicsICdzdHJpbmcnLCAnc3FsaXRlM19maWxlbmFtZScsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdXNlcl9kYXRhJywgJ3ZvaWQqJywgJ3NxbGl0ZTNfY29udGV4dConXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfYmxvYicsICcqJywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2J5dGVzJywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9kb3VibGUnLCAnZjY0JywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2R1cCcsICdzcWxpdGUzX3ZhbHVlKicsICdzcWxpdGUzX3ZhbHVlKiddLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9mcmVlJywgdW5kZWZpbmVkLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX2ludCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UnLCAnaW50JywgJ3NxbGl0ZTNfdmFsdWUqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZScsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfcG9pbnRlcicsICcqJywgJ3NxbGl0ZTNfdmFsdWUqJywgJ3N0cmluZzpzdGF0aWMnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfc3VidHlwZScsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfdGV4dCcsICdzdHJpbmcnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmFsdWVfdHlwZScsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmZzX2ZpbmQnLCAnKicsICdzdHJpbmcnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdmZzX3JlZ2lzdGVyJywgJ2ludCcsICdzcWxpdGUzX3ZmcyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Zmc191bnJlZ2lzdGVyJywgJ2ludCcsICdzcWxpdGUzX3ZmcyonXSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoISF3YXNtLmV4cG9ydHMuc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFtcbiAgICAgICAgICAgICdzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4UHJvZ3Jlc3NIYW5kbGVyJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHApJyxcbiAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICdjb250ZXh0JyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhd2FzbS5leHBvcnRzLnNxbGl0ZTNfc3RtdF9leHBsYWluKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFxuICAgICAgICAgICAgWydzcWxpdGUzX3N0bXRfZXhwbGFpbicsICdpbnQnLCAnc3FsaXRlM19zdG10KicsICdpbnQnXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM19zdG10X2lzZXhwbGFpbicsICdpbnQnLCAnc3FsaXRlM19zdG10KiddLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISF3YXNtLmV4cG9ydHMuc3FsaXRlM19zZXRfYXV0aG9yaXplcikge1xuICAgICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMucHVzaChbXG4gICAgICAgICAgICAnc3FsaXRlM19zZXRfYXV0aG9yaXplcicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3NldF9hdXRob3JpemVyOjp4QXV0aCcsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwaScgKyAnc3NzcyknLFxuICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChwViwgaUNvZGUsIHMwLCBzMSwgczIsIHMzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBzMCAmJiB3YXNtLmNzdHJUb0pzKHMwKTtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHMxICYmIHdhc20uY3N0clRvSnMoczEpO1xuICAgICAgICAgICAgICAgICAgICAgIHMyID0gczIgJiYgd2FzbS5jc3RyVG9KcyhzMik7XG4gICAgICAgICAgICAgICAgICAgICAgczMgPSBzMyAmJiB3YXNtLmNzdHJUb0pzKHMzKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socFYsIGlDb2RlLCBzMCwgczEsIHMyLCBzMykgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFsc2UgJiYgd2FzbS5jb21waWxlT3B0aW9uVXNlZCgnU1FMSVRFX0VOQUJMRV9OT1JNQUxJWkUnKSkge1xuICAgICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMucHVzaChbXG4gICAgICAgICAgICAnc3FsaXRlM19ub3JtYWxpemVkX3NxbCcsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQgPSBbXG4gICAgICAgICAgWydzcWxpdGUzX2JpbmRfaW50NjQnLCAnaW50JywgWydzcWxpdGUzX3N0bXQqJywgJ2ludCcsICdpNjQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXM2NCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19jb2x1bW5faW50NjQnLCAnaTY0JywgWydzcWxpdGUzX3N0bXQqJywgJ2ludCddXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnc3FsaXRlM19kZXNlcmlhbGl6ZScsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdpNjQnLFxuICAgICAgICAgICAgJ2k2NCcsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFsnc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFsnc3FsaXRlM19tYWxsb2M2NCcsICcqJywgJ2k2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19tc2l6ZScsICdpNjQnLCAnKiddLFxuICAgICAgICAgIFsnc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbicsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnXV0sXG4gICAgICAgICAgWydzcWxpdGUzX3JlYWxsb2M2NCcsICcqJywgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF9pbnQ2NCcsIHVuZGVmaW5lZCwgJyonLCAnaTY0J10sXG4gICAgICAgICAgWydzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0JywgJ2ludCcsICcqJywgJ2k2NCddLFxuICAgICAgICAgIFsnc3FsaXRlM19zZXJpYWxpemUnLCAnKicsICdzcWxpdGUzKicsICdzdHJpbmcnLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkJywgdW5kZWZpbmVkLCBbJ3NxbGl0ZTMqJywgJ2k2NCddXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfc3RhdHVzNjQnLCAnaW50JywgJ2ludCcsICcqJywgJyonLCAnaW50J10sXG4gICAgICAgICAgWydzcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCcsICdpNjQnLCBbJ3NxbGl0ZTMqJ11dLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICd2KGlpcHBqKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAocCwgb3AsIHowLCB6MSwgcm93aWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHowKSxcbiAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHoxKSxcbiAgICAgICAgICAgICAgICAgICAgICByb3dpZCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfdXJpX2ludDY0JywgJ2k2NCcsIFsnc3FsaXRlM19maWxlbmFtZScsICdzdHJpbmcnLCAnaTY0J11dLFxuICAgICAgICAgIFsnc3FsaXRlM192YWx1ZV9pbnQ2NCcsICdpNjQnLCAnc3FsaXRlM192YWx1ZSonXSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkICYmICEhd2FzbS5leHBvcnRzLnNxbGl0ZTNfZGVjbGFyZV92dGFiKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NC5wdXNoKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfbW9kdWxlJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJ3NxbGl0ZTNfbW9kdWxlKicsICcqJ10sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJ3NxbGl0ZTNfbW9kdWxlKicsICcqJywgJyonXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfZGVjbGFyZV92dGFiJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nOmZsZXhpYmxlJ11dLFxuICAgICAgICAgICAgWydzcWxpdGUzX2Ryb3BfbW9kdWxlcycsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJyoqJ11dLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfY29sbGF0aW9uJywgJ3N0cmluZycsICdzcWxpdGUzX2luZGV4X2luZm8qJywgJ2ludCddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfZGlzdGluY3QnLCAnaW50JywgJ3NxbGl0ZTNfaW5kZXhfaW5mbyonXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM192dGFiX2luJywgJ2ludCcsICdzcWxpdGUzX2luZGV4X2luZm8qJywgJ2ludCcsICdpbnQnXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM192dGFiX2luX2ZpcnN0JywgJ2ludCcsICdzcWxpdGUzX3ZhbHVlKicsICcqKiddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfaW5fbmV4dCcsICdpbnQnLCAnc3FsaXRlM192YWx1ZSonLCAnKionXSxcblxuICAgICAgICAgICAgWydzcWxpdGUzX3Z0YWJfbm9jaGFuZ2UnLCAnaW50JywgJ3NxbGl0ZTNfY29udGV4dConXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM192dGFiX29uX2NvbmZsaWN0JywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlM192dGFiX3Joc192YWx1ZScsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9pbmZvKicsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCAmJiAhIXdhc20uZXhwb3J0cy5zcWxpdGUzX3ByZXVwZGF0ZV9ob29rKSB7XG4gICAgICAgICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NC5wdXNoKFxuICAgICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgICBbJ3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50JywgJ2ludCcsICdzcWxpdGUzKiddLFxuICAgICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCcsICdpbnQnLCAnc3FsaXRlMyonXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YocHBpcHBqaiknLFxuICAgICAgICAgICAgICAgICAgY29udGV4dEtleTogKGFyZ3YpID0+IGFyZ3ZbMF0sXG4gICAgICAgICAgICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHAsIGRiLCBvcCwgekRiLCB6VGJsLCBpS2V5MSwgaUtleTIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh6RGIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh6VGJsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlLZXkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaUtleTIsXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFsnc3FsaXRlM19wcmV1cGRhdGVfbmV3JywgJ2ludCcsIFsnc3FsaXRlMyonLCAnaW50JywgJyoqJ11dLFxuICAgICAgICAgICAgWydzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnLCAnaW50JywgWydzcWxpdGUzKicsICdpbnQnLCAnKionXV0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB3YXNtLmJpZ0ludEVuYWJsZWQgJiZcbiAgICAgICAgICAhIXdhc20uZXhwb3J0cy5zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkICYmXG4gICAgICAgICAgISF3YXNtLmV4cG9ydHMuc3FsaXRlM3Nlc3Npb25fY3JlYXRlICYmXG4gICAgICAgICAgISF3YXNtLmV4cG9ydHMuc3FsaXRlM19wcmV1cGRhdGVfaG9va1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBfX2lwc1Byb3h5ID0ge1xuICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcyknLFxuICAgICAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIChwLCBzKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhwLCB3YXNtLmNzdHJUb0pzKHMpKSB8IDA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0LnB1c2goXG4gICAgICAgICAgICAuLi5bXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZWdyb3VwKicsICdpbnQnLCAndm9pZConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19jaGFuZ2Vncm91cConXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfbmV3JywgJ2ludCcsIFsnKionXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZWdyb3VwKicsICdpbnQqJywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19jaGFuZ2Vncm91cConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBpKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2FwcGx5JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9faXBzUHJveHksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9faXBzUHJveHksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9faXBzUHJveHksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgJ2ludConLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9faXBzUHJveHksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgICAgICAgJ2ludConLFxuICAgICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydpbnQnLCAndm9pZConLCAnaW50JywgJ3ZvaWQqJywgJ2ludConLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4SW5wdXRBJyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAnaShwcHApJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dEInLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBpKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cycsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnaW50JywgJ3ZvaWQqJywgJ2ludConLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneE91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBpKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X25ldycsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQnLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X25leHQnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKiddXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X29sZCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQnLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X29wJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJyoqJywgJ2ludConLCAnaW50KicsICdpbnQqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9waycsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICcqKicsICdpbnQqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9zdGFydCcsICdpbnQnLCBbJyoqJywgJ2ludCcsICcqJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyJywgJ2ludCcsIFsnKionLCAnaW50JywgJyonLCAnaW50J11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybScsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJyoqJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocHBwKScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICd2b2lkKicsXG4gICAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2F0dGFjaCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnc3RyaW5nJ11dLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCcsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludConLCAnKionXSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZScsICdpNjQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX3Nlc3Npb24qJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY29uZmlnJywgJ2ludCcsIFsnaW50JywgJ3ZvaWQqJ11dLFxuICAgICAgICAgICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZScsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICcqKiddXSxcblxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNzZXNzaW9uX2RpZmYnLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKicsICdzdHJpbmcnLCAnc3RyaW5nJywgJyoqJ10sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25fZW5hYmxlJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdpbnQnXV0sXG4gICAgICAgICAgICAgIFsnc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCddXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5JywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgICAgICAgICAgWydzcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZCcsICdpNjQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionXV0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZycsXG4gICAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICAgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCcsICd2b2lkKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnKicsICcqKiddLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0nLFxuICAgICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX3Nlc3Npb24qJyxcbiAgICAgICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdpKHBwcCknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAndm9pZConLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9faXBzUHJveHksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCkgPT4gYXJndlswXSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLndhc21JbnRlcm5hbCA9IFtcbiAgICAgICAgICBbJ3NxbGl0ZTNfX3dhc21fZGJfcmVzZXQnLCAnaW50JywgJ3NxbGl0ZTMqJ10sXG4gICAgICAgICAgWydzcWxpdGUzX193YXNtX2RiX3ZmcycsICdzcWxpdGUzX3ZmcyonLCAnc3FsaXRlMyonLCAnc3RyaW5nJ10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3NxbGl0ZTNfX3dhc21fdmZzX2NyZWF0ZV9maWxlJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfdmZzKicsXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgWydzcWxpdGUzX193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlJywgJ2ludCcsICdzdHJpbmcnLCAnKicsICdpbnQnXSxcbiAgICAgICAgICBbJ3NxbGl0ZTNfX3dhc21fdmZzX3VubGluaycsICdpbnQnLCAnc3FsaXRlM192ZnMqJywgJ3N0cmluZyddLFxuICAgICAgICAgIFsnc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuJywgJ3N0cmluZzpkZWFsbG9jJywgJ3N0cmluZycsICdpbnQnXSxcbiAgICAgICAgXTtcblxuICAgICAgICBzcWxpdGUzLlN0cnVjdEJpbmRlciA9IGdsb2JhbFRoaXMuSmFjY3dhYnl0KHtcbiAgICAgICAgICBoZWFwOiAwID8gd2FzbS5tZW1vcnkgOiB3YXNtLmhlYXA4dSxcbiAgICAgICAgICBhbGxvYzogd2FzbS5hbGxvYyxcbiAgICAgICAgICBkZWFsbG9jOiB3YXNtLmRlYWxsb2MsXG4gICAgICAgICAgYmlnSW50RW5hYmxlZDogd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgIG1lbWJlclByZWZpeDogJyQnLFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXMuSmFjY3dhYnl0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX3hTdHJpbmcgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3N0cmluZycpO1xuICAgICAgICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3RyaW5nOmZsZXhpYmxlJywgKHYpID0+XG4gICAgICAgICAgICBfX3hTdHJpbmcodXRpbC5mbGV4aWJsZVN0cmluZyh2KSksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcihcbiAgICAgICAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIGlmICh3YXNtLmlzUHRyKHYpKSByZXR1cm4gdjtcbiAgICAgICAgICAgICAgdiA9ICcnICsgdjtcbiAgICAgICAgICAgICAgbGV0IHJjID0gdGhpc1t2XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjIHx8ICh0aGlzW3ZdID0gd2FzbS5hbGxvY0NTdHJpbmcodikpO1xuICAgICAgICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBfX3hBcmdQdHIgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJyonKTtcbiAgICAgICAgICBjb25zdCBuaWxUeXBlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzX2ZpbGVuYW1lJywgX194QXJnUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NvbnRleHQqJyxcbiAgICAgICAgICAgIF9feEFyZ1B0cixcbiAgICAgICAgICApKCdzcWxpdGUzX3ZhbHVlKicsIF9feEFyZ1B0cikoJ3ZvaWQqJywgX194QXJnUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgICAgICBfX3hBcmdQdHIsXG4gICAgICAgICAgKSgnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCBfX3hBcmdQdHIpKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICAgICAgX194QXJnUHRyLFxuICAgICAgICAgICkoJ3NxbGl0ZTNfc3RtdConLCAodikgPT5cbiAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIChzcWxpdGUzPy5vbzE/LlN0bXQgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzKicsICh2KSA9PlxuICAgICAgICAgICAgX194QXJnUHRyKFxuICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKHNxbGl0ZTM/Lm9vMT8uREIgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApKCdzcWxpdGUzX3ZmcyonLCAodikgPT4ge1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM192ZnNfZmluZCh2KSB8fFxuICAgICAgICAgICAgICAgIHNxbGl0ZTMuU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9OT1RGT1VORCxcbiAgICAgICAgICAgICAgICAgICdVbmtub3duIHNxbGl0ZTNfdmZzIG5hbWU6JyxcbiAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgdiBpbnN0YW5jZW9mIChjYXBpLnNxbGl0ZTNfdmZzIHx8IG5pbFR5cGUpID8gdi5wb2ludGVyIDogdixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHdhc20uZXhwb3J0cy5zcWxpdGUzX2RlY2xhcmVfdnRhYikge1xuICAgICAgICAgICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzX2luZGV4X2luZm8qJywgKHYpID0+XG4gICAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKGNhcGkuc3FsaXRlM19pbmRleF9pbmZvIHx8IG5pbFR5cGUpXG4gICAgICAgICAgICAgICAgICA/IHYucG9pbnRlclxuICAgICAgICAgICAgICAgICAgOiB2LFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKSgnc3FsaXRlM19tb2R1bGUqJywgKHYpID0+XG4gICAgICAgICAgICAgIF9feEFyZ1B0cihcbiAgICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgKGNhcGkuc3FsaXRlM19tb2R1bGUgfHwgbmlsVHlwZSkgPyB2LnBvaW50ZXIgOiB2LFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBfX3hSY1B0ciA9IHdhc20ueFdyYXAucmVzdWx0QWRhcHRlcignKicpO1xuICAgICAgICAgIHdhc20ueFdyYXAucmVzdWx0QWRhcHRlcignc3FsaXRlMyonLCBfX3hSY1B0cikoXG4gICAgICAgICAgICAnc3FsaXRlM19jb250ZXh0KicsXG4gICAgICAgICAgICBfX3hSY1B0cixcbiAgICAgICAgICApKCdzcWxpdGUzX3N0bXQqJywgX194UmNQdHIpKCdzcWxpdGUzX3ZhbHVlKicsIF9feFJjUHRyKShcbiAgICAgICAgICAgICdzcWxpdGUzX3ZmcyonLFxuICAgICAgICAgICAgX194UmNQdHIsXG4gICAgICAgICAgKSgndm9pZConLCBfX3hSY1B0cik7XG5cbiAgICAgICAgICBpZiAoMCA9PT0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfc3RlcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdhc20ueFdyYXAuZG9BcmdjQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICdEaXNhYmxpbmcgc3FsaXRlMy53YXNtLnhXcmFwLmRvQXJnY0NoZWNrIGR1ZSB0byBlbnZpcm9ubWVudGFsIHF1aXJrcy4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIHdhc20uYmluZGluZ1NpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIGNhcGlbZVswXV0gPSB3YXNtLnhXcmFwLmFwcGx5KG51bGwsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy53YXNtSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHV0aWxbZVswXV0gPSB3YXNtLnhXcmFwLmFwcGx5KG51bGwsIGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZJNjREaXNhYmxlZCA9IGZ1bmN0aW9uIChmbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+XG4gICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgZm5hbWUgKyAnKCkgaXMgdW5hdmFpbGFibGUgZHVlIHRvIGxhY2snLFxuICAgICAgICAgICAgICAgICdvZiBCaWdJbnQgc3VwcG9ydCBpbiB0aGlzIGJ1aWxkLicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NCkge1xuICAgICAgICAgICAgY2FwaVtlWzBdXSA9IHdhc20uYmlnSW50RW5hYmxlZFxuICAgICAgICAgICAgICA/IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSlcbiAgICAgICAgICAgICAgOiBmSTY0RGlzYWJsZWQoZVswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIHdhc20uYmluZGluZ1NpZ25hdHVyZXM7XG5cbiAgICAgICAgICBpZiAod2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IF9fZGJfZXJyID0gd2FzbS54V3JhcChcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfX3dhc21fZGJfZXJyb3InLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yID0gZnVuY3Rpb24gKHBEYiwgcmVzdWx0Q29kZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Q29kZSBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRDb2RlID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Q29kZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJycgKyByZXN1bHRDb2RlO1xuICAgICAgICAgICAgICAgIHJlc3VsdENvZGUgPSByZXN1bHRDb2RlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHBEYiA/IF9fZGJfZXJyKHBEYiwgcmVzdWx0Q29kZSwgbWVzc2FnZSkgOiByZXN1bHRDb2RlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yID0gZnVuY3Rpb24gKHBEYiwgZXJyQ29kZSwgbXNnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19fd2FzbV9kYl9lcnJvcigpIGlzIG5vdCBleHBvcnRlZC4nLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjSnNvbiA9IHdhc20ueENhbGwoJ3NxbGl0ZTNfX3dhc21fZW51bV9qc29uJyk7XG4gICAgICAgICAgaWYgKCFjSnNvbikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgXCJNYWludGVuYW5jZSByZXF1aXJlZDogaW5jcmVhc2Ugc3FsaXRlM19fd2FzbV9lbnVtX2pzb24oKSdzXCIsXG4gICAgICAgICAgICAgICdzdGF0aWMgYnVmZmVyIHNpemUhJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2FzbS5jdHlwZSA9IEpTT04ucGFyc2Uod2FzbS5jc3RyVG9KcyhjSnNvbikpO1xuXG4gICAgICAgICAgY29uc3QgZGVmaW5lR3JvdXBzID0gW1xuICAgICAgICAgICAgJ2FjY2VzcycsXG4gICAgICAgICAgICAnYXV0aG9yaXplcicsXG4gICAgICAgICAgICAnYmxvYkZpbmFsaXplcnMnLFxuICAgICAgICAgICAgJ2NoYW5nZXNldCcsXG4gICAgICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgICAgICdkYXRhVHlwZXMnLFxuICAgICAgICAgICAgJ2RiQ29uZmlnJyxcbiAgICAgICAgICAgICdkYlN0YXR1cycsXG4gICAgICAgICAgICAnZW5jb2RpbmdzJyxcbiAgICAgICAgICAgICdmY250bCcsXG4gICAgICAgICAgICAnZmxvY2snLFxuICAgICAgICAgICAgJ2lvQ2FwJyxcbiAgICAgICAgICAgICdsaW1pdHMnLFxuICAgICAgICAgICAgJ29wZW5GbGFncycsXG4gICAgICAgICAgICAncHJlcGFyZUZsYWdzJyxcbiAgICAgICAgICAgICdyZXN1bHRDb2RlcycsXG4gICAgICAgICAgICAnc3FsaXRlM1N0YXR1cycsXG4gICAgICAgICAgICAnc3RtdFN0YXR1cycsXG4gICAgICAgICAgICAnc3luY0ZsYWdzJyxcbiAgICAgICAgICAgICd0cmFjZScsXG4gICAgICAgICAgICAndHhuU3RhdGUnLFxuICAgICAgICAgICAgJ3VkZkZsYWdzJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJyxcbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmICh3YXNtLmJpZ0ludEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlZmluZUdyb3Vwcy5wdXNoKCdzZXJpYWxpemUnLCAnc2Vzc2lvbicsICd2dGFiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBkZWZpbmVHcm91cHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh3YXNtLmN0eXBlW3RdKSkge1xuICAgICAgICAgICAgICBjYXBpW2VbMF1dID0gZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3YXNtLmZ1bmN0aW9uRW50cnkoY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKSkge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ0ludGVybmFsIGVycm9yOiBjYW5ub3QgcmVzb2x2ZSBleHBvcnRlZCBmdW5jdGlvbicsXG4gICAgICAgICAgICAgICdlbnRyeSBTUUxJVEVfV0FTTV9ERUFMTE9DICg9PScgKyBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MgKyAnKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgX19yY01hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIFsncmVzdWx0Q29kZXMnXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIE9iamVjdC5lbnRyaWVzKHdhc20uY3R5cGVbdF0pKSB7XG4gICAgICAgICAgICAgIF9fcmNNYXBbZVsxXV0gPSBlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIgPSAocmMpID0+IF9fcmNNYXBbcmNdO1xuXG4gICAgICAgICAgY29uc3Qgbm90VGhlc2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgIFdhc21UZXN0U3RydWN0OiB0cnVlLFxuXG4gICAgICAgICAgICBzcWxpdGUzX2t2dmZzX21ldGhvZHM6ICF1dGlsLmlzVUlUaHJlYWQoKSxcblxuICAgICAgICAgICAgc3FsaXRlM19pbmRleF9pbmZvOiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgICAgc3FsaXRlM19pbmRleF9jb25zdHJhaW50OiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgICAgc3FsaXRlM19pbmRleF9vcmRlcmJ5OiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgICAgc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlOiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB3YXNtLmN0eXBlLnN0cnVjdHMpIHtcbiAgICAgICAgICAgIGlmICghbm90VGhlc2Vbcy5uYW1lXSkge1xuICAgICAgICAgICAgICBjYXBpW3MubmFtZV0gPSBzcWxpdGUzLlN0cnVjdEJpbmRlcihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhcGkuc3FsaXRlM19pbmRleF9pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgW1xuICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9jb25zdHJhaW50JyxcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfaW5kZXhfb3JkZXJieScsXG4gICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2UnLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mb1trXSA9IGNhcGlba107XG4gICAgICAgICAgICAgIGRlbGV0ZSBjYXBpW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Z0YWJfY29uZmlnID0gd2FzbS54V3JhcChcbiAgICAgICAgICAgICAgJ3NxbGl0ZTNfX3dhc21fdnRhYl9jb25maWcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdpbnQnLCAnaW50J10sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9fZGJBcmdjTWlzbWF0Y2ggPSAocERiLCBmLCBuKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM19fd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgIGYgKyAnKCkgcmVxdWlyZXMgJyArIG4gKyAnIGFyZ3VtZW50JyArICgxID09PSBuID8gJycgOiAncycpICsgJy4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19lcnJFbmNvZGluZyA9IChwRGIpID0+IHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgY2FwaS5TUUxJVEVfRk9STUFULFxuICAgICAgICAgICAgJ1NRTElURV9VVEY4IGlzIHRoZSBvbmx5IHN1cHBvcnRlZCBlbmNvZGluZy4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX19hcmdQRGIgPSAocERiKSA9PiB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3NxbGl0ZTMqJykocERiKTtcbiAgICAgICAgY29uc3QgX19hcmdTdHIgPSAoc3RyKSA9PiAod2FzbS5pc1B0cihzdHIpID8gd2FzbS5jc3RyVG9KcyhzdHIpIDogc3RyKTtcbiAgICAgICAgY29uc3QgX19kYkNsZWFudXBNYXAgPSBmdW5jdGlvbiAocERiLCBtb2RlKSB7XG4gICAgICAgICAgcERiID0gX19hcmdQRGIocERiKTtcbiAgICAgICAgICBsZXQgbSA9IHRoaXMuZGJNYXAuZ2V0KHBEYik7XG4gICAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRiTWFwLmRlbGV0ZShwRGIpO1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgfSBlbHNlIGlmICghbSAmJiBtb2RlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kYk1hcC5zZXQocERiLCAobSA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0uYmluZChcbiAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgIGRiTWFwOiBuZXcgTWFwKCksXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkQ29sbGF0aW9uID0gZnVuY3Rpb24gKHBEYiwgbmFtZSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDEpO1xuICAgICAgICAgIGlmICghbS5jb2xsYXRpb24pIG0uY29sbGF0aW9uID0gbmV3IFNldCgpO1xuICAgICAgICAgIG0uY29sbGF0aW9uLmFkZChfX2FyZ1N0cihuYW1lKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfX2RiQ2xlYW51cE1hcC5fYWRkVURGID0gZnVuY3Rpb24gKHBEYiwgbmFtZSwgYXJpdHksIG1hcCkge1xuICAgICAgICAgIG5hbWUgPSBfX2FyZ1N0cihuYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxldCB1ID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgICBpZiAoIXUpIG1hcC5zZXQobmFtZSwgKHUgPSBuZXcgU2V0KCkpKTtcbiAgICAgICAgICB1LmFkZChhcml0eSA8IDAgPyAtMSA6IGFyaXR5KTtcbiAgICAgICAgfTtcblxuICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRGdW5jdGlvbiA9IGZ1bmN0aW9uIChwRGIsIG5hbWUsIGFyaXR5KSB7XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgICAgICAgaWYgKCFtLnVkZikgbS51ZGYgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fYWRkVURGKHBEYiwgbmFtZSwgYXJpdHksIG0udWRmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAod2FzbS5leHBvcnRzLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbikge1xuICAgICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZFdpbmRvd0Z1bmMgPSBmdW5jdGlvbiAocERiLCBuYW1lLCBhcml0eSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgICAgICAgICBpZiAoIW0ud3VkZikgbS53dWRmID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVURGKHBEYiwgbmFtZSwgYXJpdHksIG0ud3VkZik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9fZGJDbGVhbnVwTWFwLmNsZWFudXAgPSBmdW5jdGlvbiAocERiKSB7XG4gICAgICAgICAgcERiID0gX19hcmdQRGIocERiKTtcblxuICAgICAgICAgIGNvbnN0IGNsb3NlQXJncyA9IFtwRGJdO1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBbXG4gICAgICAgICAgICAnc3FsaXRlM19idXN5X2hhbmRsZXInLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY29tbWl0X2hvb2snLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snLFxuICAgICAgICAgICAgJ3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcicsXG4gICAgICAgICAgICAnc3FsaXRlM19yb2xsYmFja19ob29rJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3NldF9hdXRob3JpemVyJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3RyYWNlX3YyJyxcbiAgICAgICAgICAgICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gd2FzbS5leHBvcnRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF4KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2VBcmdzLmxlbmd0aCA9IHgubGVuZ3RoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2FwaVtuYW1lXSguLi5jbG9zZUFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICAgICAgICAgICdjbG9zZS10aW1lIGNhbGwgb2YnLFxuICAgICAgICAgICAgICAgIG5hbWUgKyAnKCcsXG4gICAgICAgICAgICAgICAgY2xvc2VBcmdzLFxuICAgICAgICAgICAgICAgICcpIHRocmV3OicsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMCk7XG4gICAgICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICAgICAgaWYgKG0uY29sbGF0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbS5jb2xsYXRpb24pIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4LFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbS5jb2xsYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtYXAgPSBpID8gbS53dWRmIDogbS51ZGY7XG4gICAgICAgICAgICBpZiAoIWZtYXApIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IGlcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblxuICAgICAgICAgICAgICA6IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjI7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZm1hcCkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZVswXSxcbiAgICAgICAgICAgICAgICBhcml0aWVzID0gZVsxXTtcbiAgICAgICAgICAgICAgY29uc3QgZmFyZ3MgPSBbcERiLCBuYW1lLCAwLCBjYXBpLlNRTElURV9VVEY4LCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgaWYgKGkpIGZhcmdzLnB1c2goMCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYXJpdHkgb2YgYXJpdGllcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmYXJnc1syXSA9IGFyaXR5O1xuICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShudWxsLCBmYXJncyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcml0aWVzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbWFwLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtLnVkZjtcbiAgICAgICAgICBkZWxldGUgbS53dWRmO1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX3NxbGl0ZTNDbG9zZVYyID0gd2FzbS54V3JhcChcbiAgICAgICAgICAgICdzcWxpdGUzX2Nsb3NlX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNhcGkuc3FsaXRlM19jbG9zZV92MiA9IGZ1bmN0aW9uIChwRGIpIHtcbiAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2Nsb3NlX3YyJywgMSk7XG4gICAgICAgICAgICBpZiAocERiKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuY2xlYW51cChwRGIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3FsaXRlM0Nsb3NlVjIocERiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhcGkuc3FsaXRlM3Nlc3Npb25fY3JlYXRlKSB7XG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzU2Vzc2lvbkRlbGV0ZSA9IHdhc20ueFdyYXAoXG4gICAgICAgICAgICAnc3FsaXRlM3Nlc3Npb25fZGVsZXRlJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFsnc3FsaXRlM19zZXNzaW9uKiddLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY2FwaS5zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBmdW5jdGlvbiAocFNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICgxICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZScsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwU2Vzc2lvbikge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcihwU2Vzc2lvbiwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX3NxbGl0ZTNTZXNzaW9uRGVsZXRlKHBTZXNzaW9uKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSAoYXJndiwgYXJnSW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICdhcmd2WycgK1xuICAgICAgICAgICAgICBhcmdJbmRleCArXG4gICAgICAgICAgICAgICddOicgK1xuICAgICAgICAgICAgICBhcmd2WzBdICtcbiAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyhhcmd2WzFdKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlQ29sbGF0aW9uVjIgPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneENvbXBhcmUnLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ2kocGlwaXApJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0S2V5LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgICAgY29udGV4dEtleSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgIHpOYW1lLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXJnLFxuICAgICAgICAgICAgeENvbXBhcmUsXG4gICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICg2ICE9PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInLCA2KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDAgPT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVDb2xsYXRpb25WMihcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgek5hbWUsXG4gICAgICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgICAgICB4Q29tcGFyZSxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHJjICYmIHhDb21wYXJlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRDb2xsYXRpb24ocERiLCB6TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKHBEYiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uID0gKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgek5hbWUsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcmcsXG4gICAgICAgICAgICB4Q29tcGFyZSxcbiAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgIHJldHVybiA1ID09PSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB6TmFtZSxcbiAgICAgICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgICAgcEFyZyxcbiAgICAgICAgICAgICAgICAgIHhDb21wYXJlLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24nLCA1KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBmdW5jdGlvbiAoYXJndiwgYXJnSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGFyZ3ZbMF0gK1xuICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAoYXJndlsyXSA8IDAgPyAtMSA6IGFyZ3ZbMl0pICtcbiAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgYXJnSW5kZXggK1xuICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKGFyZ3ZbMV0pLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IF9fY2ZQcm94eSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgeEludmVyc2VBbmRTdGVwOiB7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YocGlwKScsXG4gICAgICAgICAgICAgIGNvbnRleHRLZXksXG4gICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwQ3R4LCBhcmdjLCBwQXJndikgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socEN0eCwgLi4uY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyhhcmdjLCBwQXJndikpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEZpbmFsQW5kVmFsdWU6IHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgICAgICAgIGNvbnRleHRLZXksXG4gICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwQ3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzKHBDdHgsIGNhbGxiYWNrKHBDdHgpKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhGdW5jOiB7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YocGlwKScsXG4gICAgICAgICAgICAgIGNvbnRleHRLZXksXG4gICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwQ3R4LCBhcmdjLCBwQXJndikgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyhcbiAgICAgICAgICAgICAgICAgICAgICBwQ3R4LFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBDdHgsIC4uLmNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMoYXJnYywgcEFyZ3YpKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhEZXN0cm95OiB7XG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3YocCknLFxuICAgICAgICAgICAgICBjb250ZXh0S2V5LFxuXG4gICAgICAgICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwVm9pZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socFZvaWQpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVREYgeERlc3Ryb3kgbWV0aG9kIHRocmV3OicsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlRnVuY3Rpb24gPSB3YXNtLnhXcmFwKFxuICAgICAgICAgICAgJ3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneEZ1bmMnLFxuICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54RnVuYyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneFN0ZXAnLFxuICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54SW52ZXJzZUFuZFN0ZXAsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hGaW5hbCcsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhGaW5hbEFuZFZhbHVlLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsXG4gICAgICAgICAgICAgICAgLi4uX19jZlByb3h5LnhEZXN0cm95LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IF9fc3FsaXRlM0NyZWF0ZVdpbmRvd0Z1bmN0aW9uID0gd2FzbS5leHBvcnRzXG4gICAgICAgICAgICAuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXG4gICAgICAgICAgICA/IHdhc20ueFdyYXAoJ3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbicsICdpbnQnLCBbXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ3hTdGVwJyxcbiAgICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54SW52ZXJzZUFuZFN0ZXAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ3hGaW5hbCcsXG4gICAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ3hWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ3hJbnZlcnNlJyxcbiAgICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54SW52ZXJzZUFuZFN0ZXAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICAgIC4uLl9fY2ZQcm94eS54RGVzdHJveSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MicsXG4gICAgICAgICAgICAgICAgZi5sZW5ndGgsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKDAgPT09IChlVGV4dFJlcCAmIDB4ZikpIHtcbiAgICAgICAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSkge1xuICAgICAgICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVGdW5jdGlvbihcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICAgICAgbkFyZyxcbiAgICAgICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgICAgIHhGdW5jLFxuICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgPT09IHJjICYmXG4gICAgICAgICAgICAgICAgKHhGdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgIHhTdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgIHhGaW5hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICB4RGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRGdW5jdGlvbihwRGIsIGZ1bmNOYW1lLCBuQXJnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyKCkgc2V0dXAgdGhyZXc6JywgZSk7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIFVERiB0aHJldzogJyArIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICBuQXJnLFxuICAgICAgICAgICAgZVRleHRSZXAsXG4gICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgeEZ1bmMsXG4gICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgICB4RnVuYyxcbiAgICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbicsIGYubGVuZ3RoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKF9fc3FsaXRlM0NyZWF0ZVdpbmRvd0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgZnVuY05hbWUsXG4gICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgIGVUZXh0UmVwLFxuICAgICAgICAgICAgICBwQXBwLFxuICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgeEZpbmFsLFxuICAgICAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgZi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgwID09PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZXJyRW5jb2RpbmcocERiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICAgIG5BcmcsXG4gICAgICAgICAgICAgICAgICBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgIHBBcHAsXG4gICAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAwID09PSByYyAmJlxuICAgICAgICAgICAgICAgICAgKHhTdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgeEZpbmFsIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgeEludmVyc2UgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICB4RGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyhwRGIsIGZ1bmNOYW1lLCBuQXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24oKSBzZXR1cCB0aHJldzonLFxuICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgJ0NyZWF0aW9uIG9mIFVERiB0aHJldzogJyArIGUsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmU2V0UmVzdWx0ID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmU2V0UmVzdWx0ID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcztcbiAgICAgICAgICBpZiAoY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldFJlc3VsdCA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZDb252ZXJ0QXJncyA9XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcztcbiAgICAgICAgICBpZiAoY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZlNldEVycm9yID1cbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmU2V0RXJyb3IgPVxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzO1xuICAgICAgICAgIGlmIChjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbikge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmU2V0RXJyb3IgPVxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBfX2ZsZXhpU3RyaW5nID0gKHYsIG4pID0+IHtcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgbiA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgbiA9IHYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgdiA9IHV0aWwudHlwZWRBcnJheVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KHYpIDogdixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICB2ID0gdi5qb2luKCcnKTtcbiAgICAgICAgICAgICAgbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt2LCBuXTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgX19wcmVwYXJlID0ge1xuICAgICAgICAgICAgYmFzaWM6IHdhc20ueFdyYXAoJ3NxbGl0ZTNfcHJlcGFyZV92MycsICdpbnQnLCBbXG4gICAgICAgICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgICAgZnVsbDogd2FzbS54V3JhcCgnc3FsaXRlM19wcmVwYXJlX3YzJywgJ2ludCcsIFtcbiAgICAgICAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICAgICcqKicsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjMgPSBmdW5jdGlvbiBmKFxuICAgICAgICAgICAgcERiLFxuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgc3FsTGVuLFxuICAgICAgICAgICAgcHJlcEZsYWdzLFxuICAgICAgICAgICAgcHBTdG10LFxuICAgICAgICAgICAgcHpUYWlsLFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfcHJlcGFyZV92MycsIGYubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt4U3FsLCB4U3FsTGVuXSA9IF9fZmxleGlTdHJpbmcoc3FsLCBzcWxMZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgeFNxbCkge1xuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfX3ByZXBhcmUuYmFzaWMoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB4U3FsLFxuICAgICAgICAgICAgICAgICAgeFNxbExlbixcbiAgICAgICAgICAgICAgICAgIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX19wcmVwYXJlLmZ1bGwoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICB4U3FsLFxuICAgICAgICAgICAgICAgICAgeFNxbExlbixcbiAgICAgICAgICAgICAgICAgIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgIHBwU3RtdCxcbiAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCBTUUwgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19wcmVwYXJlX3YyL3YzKCkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MiA9IGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICBzcWwsXG4gICAgICAgICAgICBzcWxMZW4sXG4gICAgICAgICAgICBwcFN0bXQsXG4gICAgICAgICAgICBwelRhaWwsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZi5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhwRGIsIHNxbCwgc3FsTGVuLCAwLCBwcFN0bXQsIHB6VGFpbClcbiAgICAgICAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfcHJlcGFyZV92MicsIGYubGVuZ3RoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IF9fYmluZFRleHQgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX2JpbmRfdGV4dCcsICdpbnQnLCBbXG4gICAgICAgICAgICAnc3FsaXRlM19zdG10KicsXG4gICAgICAgICAgICAnaW50JyxcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgY29uc3QgX19iaW5kQmxvYiA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfYmluZF9ibG9iJywgJ2ludCcsIFtcbiAgICAgICAgICAgICdzcWxpdGUzX3N0bXQqJyxcbiAgICAgICAgICAgICdpbnQnLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJ2ludCcsXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfYmluZF90ZXh0ID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBTdG10LFxuICAgICAgICAgICAgaUNvbCxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBuVGV4dCxcbiAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgICdzcWxpdGUzX2JpbmRfdGV4dCcsXG4gICAgICAgICAgICAgICAgZi5sZW5ndGgsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdhc20uaXNQdHIodGV4dCkgfHwgbnVsbCA9PT0gdGV4dCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19iaW5kVGV4dChwU3RtdCwgaUNvbCwgdGV4dCwgblRleHQsIHhEZXN0cm95KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHRleHQgPSBuZXcgVWludDhBcnJheSh0ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwTWVtKSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gcE1lbS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwLCBuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTUUxhYmxlVHlwZWRBcnJheSh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHAgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkodGV4dCk7XG4gICAgICAgICAgICAgICAgbiA9IHRleHQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRleHQpIHtcbiAgICAgICAgICAgICAgICBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh0ZXh0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCAzcmQgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19iaW5kX3RleHQoKS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9fYmluZFRleHQocFN0bXQsIGlDb2wsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM19fd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iID0gZnVuY3Rpb24gZihcbiAgICAgICAgICAgIHBTdG10LFxuICAgICAgICAgICAgaUNvbCxcbiAgICAgICAgICAgIHBNZW0sXG4gICAgICAgICAgICBuTWVtLFxuICAgICAgICAgICAgeERlc3Ryb3ksXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goXG4gICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgJ3NxbGl0ZTNfYmluZF9ibG9iJyxcbiAgICAgICAgICAgICAgICBmLmxlbmd0aCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5pc1B0cihwTWVtKSB8fCBudWxsID09PSBwTWVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2JpbmRCbG9iKHBTdG10LCBpQ29sLCBwTWVtLCBuTWVtLCB4RGVzdHJveSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBNZW0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBwTWVtID0gbmV3IFVpbnQ4QXJyYXkocE1lbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocE1lbSkpIHtcbiAgICAgICAgICAgICAgcE1lbSA9IHBNZW0uam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcCwgbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHBNZW0pKSB7XG4gICAgICAgICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShwTWVtKTtcbiAgICAgICAgICAgICAgICBuID0gbk1lbSA+PSAwID8gbk1lbSA6IHBNZW0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBNZW0pIHtcbiAgICAgICAgICAgICAgICBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyhwTWVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCAzcmQgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19iaW5kX2Jsb2IoKS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9fYmluZEJsb2IocFN0bXQsIGlDb2wsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHdhc20uZGVhbGxvYyhwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM19fd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NvbmZpZyA9IGZ1bmN0aW9uIChvcCwgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gY2FwaS5TUUxJVEVfTUlTVVNFO1xuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19DT1ZFUklOR19JTkRFWF9TQ0FOOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NRU1TVEFUVVM6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NNQUxMX01BTExPQzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU09SVEVSUkVGX1NJWkU6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NUTVRKUk5MX1NQSUxMOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19VUkk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX2NvbmZpZ19pKG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9PS0FTSURFOlxuICAgICAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM19fd2FzbV9jb25maWdfaWkoXG4gICAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICBhcmdzWzFdLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01FTURCX01BWFNJWkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX2NvbmZpZ19qKG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUTUFMTE9DOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRNVVRFWDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUUENBQ0hFMjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUUENBQ0hFOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19IRUFQOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19MT0c6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01BTExPQzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTU1BUF9TSVpFOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NVUxUSVRIUkVBRDpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTVVURVg6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BBR0VDQUNIRTpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFMjpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQ0FDSEVfSERSU1o6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BNQVNaOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TRVJJQUxJWkVEOlxuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TSU5HTEVUSFJFQUQ6XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NRTExPRzpcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfV0lOMzJfSEVBUFNJWkU6XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgX19hdXRvRXh0RnB0ciA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgIGNhcGkuc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IGZ1bmN0aW9uIChmUHRyKSB7XG4gICAgICAgICAgICBpZiAoZlB0ciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGZQdHIgPSB3YXNtLmluc3RhbGxGdW5jdGlvbignaShwcHApJywgZlB0cik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGggfHwgIXdhc20uaXNQdHIoZlB0cikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJjID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfYXV0b19leHRlbnNpb24oZlB0cik7XG4gICAgICAgICAgICBpZiAoZlB0ciAhPT0gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgIGlmICgwID09PSByYykgX19hdXRvRXh0RnB0ci5hZGQoZlB0cik7XG4gICAgICAgICAgICAgIGVsc2Ugd2FzbS51bmluc3RhbGxGdW5jdGlvbihmUHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiA9IGZ1bmN0aW9uIChmUHRyKSB7XG4gICAgICAgICAgICBpZiAoIWZQdHIgfHwgMSAhPT0gYXJndW1lbnRzLmxlbmd0aCB8fCAhd2FzbS5pc1B0cihmUHRyKSkgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uKGZQdHIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcCBvZiBfX2F1dG9FeHRGcHRyKSB3YXNtLnVuaW5zdGFsbEZ1bmN0aW9uKGZwKTtcbiAgICAgICAgICAgIF9fYXV0b0V4dEZwdHIuY2xlYXIoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcEt2dmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKCdrdnZmcycpO1xuICAgICAgICBpZiAocEt2dmZzKSB7XG4gICAgICAgICAgaWYgKHV0aWwuaXNVSVRocmVhZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBrdnZmc01ldGhvZHMgPSBuZXcgY2FwaS5zcWxpdGUzX2t2dmZzX21ldGhvZHMoXG4gICAgICAgICAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWxldGUgY2FwaS5zcWxpdGUzX2t2dmZzX21ldGhvZHM7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzTWFrZUtleSA9XG4gICAgICAgICAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2ssXG4gICAgICAgICAgICAgIHBzdGFjayA9IHdhc20ucHN0YWNrO1xuXG4gICAgICAgICAgICBjb25zdCBrdnZmc1N0b3JhZ2UgPSAoekNsYXNzKSA9PlxuICAgICAgICAgICAgICAxMTUgPT09IHdhc20ucGVlayh6Q2xhc3MpID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGt2dmZzSW1wbHMgPSB7XG4gICAgICAgICAgICAgIHhSZWFkOiAoekNsYXNzLCB6S2V5LCB6QnVmLCBuQnVmKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIGFzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcywgektleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXpYS2V5KSByZXR1cm4gLTM7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqS2V5ID0gd2FzbS5jc3RyVG9Kcyh6WEtleSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqViA9IGt2dmZzU3RvcmFnZSh6Q2xhc3MpLmdldEl0ZW0oaktleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWpWKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuViA9IGpWLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChuQnVmIDw9IDApIHJldHVybiBuVjtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKDEgPT09IG5CdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlKHpCdWYsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCB6ViA9IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKGpWKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuQnVmID4gblYgKyAxKSBuQnVmID0gblYgKyAxO1xuICAgICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5jb3B5V2l0aGluKHpCdWYsIHpWLCB6ViArIG5CdWYgLSAxKTtcbiAgICAgICAgICAgICAgICAgIHdhc20ucG9rZSh6QnVmICsgbkJ1ZiAtIDEsIDApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5CdWYgLSAxO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZVJlYWQoKScsIGUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBwc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKGFzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6ICh6Q2xhc3MsIHpLZXksIHpEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLCB6S2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghelhLZXkpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaktleSA9IHdhc20uY3N0clRvSnMoelhLZXkpO1xuICAgICAgICAgICAgICAgICAga3Z2ZnNTdG9yYWdlKHpDbGFzcykuc2V0SXRlbShqS2V5LCB3YXNtLmNzdHJUb0pzKHpEYXRhKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdrdnN0b3JhZ2VXcml0ZSgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6ICh6Q2xhc3MsIHpLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsIHpLZXkpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF6WEtleSkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICBrdnZmc1N0b3JhZ2UoekNsYXNzKS5yZW1vdmVJdGVtKHdhc20uY3N0clRvSnMoelhLZXkpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2t2c3RvcmFnZURlbGV0ZSgpJywgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKGt2dmZzSW1wbHMpKSB7XG4gICAgICAgICAgICAgIGt2dmZzTWV0aG9kc1trdnZmc01ldGhvZHMubWVtYmVyS2V5KGspXSA9IHdhc20uaW5zdGFsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIGt2dmZzTWV0aG9kcy5tZW1iZXJTaWduYXR1cmUoayksXG4gICAgICAgICAgICAgICAga3Z2ZnNJbXBsc1trXSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHBLdnZmcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IFN0cnVjdEJpbmRlciA9IHNxbGl0ZTMuU3RydWN0QmluZGVyO1xuICAgICAgICBjb25zdCBpbnN0YWxsTWV0aG9kID0gZnVuY3Rpb24gY2FsbGVlKFxuICAgICAgICAgIHRndCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgYXBwbHlBcmdjQ2hlY2sgPSBjYWxsZWUuaW5zdGFsbE1ldGhvZEFyZ2NDaGVjayxcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCEodGd0IGluc3RhbmNlb2YgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUpKSB7XG4gICAgICAgICAgICB0b3NzKCdVc2FnZSBlcnJvcjogdGFyZ2V0IG9iamVjdCBpcy1ub3QtYSBTdHJ1Y3RUeXBlLicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIShmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pICYmICF3YXNtLmlzUHRyKGZ1bmMpKSB7XG4gICAgICAgICAgICB0b3NzKCdVc2FnZSBlcnJvcjogZXhwZWN0aW5nIGEgRnVuY3Rpb24gb3IgV0FTTSBwb2ludGVyIHRvIG9uZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAobiwgZikgPT4gY2FsbGVlKHRndCwgbiwgZiwgYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbGxlZS5hcmdjUHJveHkpIHtcbiAgICAgICAgICAgIGNhbGxlZS5hcmdjUHJveHkgPSBmdW5jdGlvbiAodGd0LCBmdW5jTmFtZSwgZnVuYywgc2lnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jLmxlbmd0aCAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0FyZ3VtZW50IG1pc21hdGNoIGZvcicsXG4gICAgICAgICAgICAgICAgICAgIHRndC5zdHJ1Y3RJbmZvLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICc6OicgK1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAnOiBOYXRpdmUgc2lnbmF0dXJlIGlzOicsXG4gICAgICAgICAgICAgICAgICAgIHNpZyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QuZm9yRWFjaCgodiwgbmR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2FzbS51bmluc3RhbGxGdW5jdGlvbih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2lnTiA9IHRndC5tZW1iZXJTaWduYXR1cmUobmFtZSk7XG4gICAgICAgICAgaWYgKHNpZ04ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ01lbWJlcicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICdkb2VzIG5vdCBoYXZlIGEgZnVuY3Rpb24gcG9pbnRlciBzaWduYXR1cmU6JyxcbiAgICAgICAgICAgICAgc2lnTixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbUtleSA9IHRndC5tZW1iZXJLZXkobmFtZSk7XG4gICAgICAgICAgY29uc3QgZlByb3h5ID1cbiAgICAgICAgICAgIGFwcGx5QXJnY0NoZWNrICYmICF3YXNtLmlzUHRyKGZ1bmMpXG4gICAgICAgICAgICAgID8gY2FsbGVlLmFyZ2NQcm94eSh0Z3QsIG1lbUtleSwgZnVuYywgc2lnTilcbiAgICAgICAgICAgICAgOiBmdW5jO1xuICAgICAgICAgIGlmICh3YXNtLmlzUHRyKGZQcm94eSkpIHtcbiAgICAgICAgICAgIGlmIChmUHJveHkgJiYgIXdhc20uZnVuY3Rpb25FbnRyeShmUHJveHkpKSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1BvaW50ZXInLCBmUHJveHksICdpcyBub3QgYSBXQVNNIGZ1bmN0aW9uIHRhYmxlIGVudHJ5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGd0W21lbUtleV0gPSBmUHJveHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBGdW5jID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgICAgIGZQcm94eSxcbiAgICAgICAgICAgICAgdGd0Lm1lbWJlclNpZ25hdHVyZShuYW1lLCB0cnVlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0Z3RbbWVtS2V5XSA9IHBGdW5jO1xuICAgICAgICAgICAgaWYgKCF0Z3Qub25kaXNwb3NlIHx8ICF0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QpIHtcbiAgICAgICAgICAgICAgdGd0LmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgICAnb25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgaGFuZGxlcicsXG4gICAgICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdC5wdXNoKG1lbUtleSwgcEZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKG4sIGYpID0+IGNhbGxlZSh0Z3QsIG4sIGYsIGFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgaW5zdGFsbE1ldGhvZHMgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgc3RydWN0SW5zdGFuY2UsXG4gICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVjayxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobWV0aG9kcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgICAgY29uc3QgcHJpb3IgPSBzZWVuLmdldChtKTtcbiAgICAgICAgICAgIGlmIChwcmlvcikge1xuICAgICAgICAgICAgICBjb25zdCBta2V5ID0gc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KGspO1xuICAgICAgICAgICAgICBzdHJ1Y3RJbnN0YW5jZVtta2V5XSA9XG4gICAgICAgICAgICAgICAgc3RydWN0SW5zdGFuY2Vbc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KHByaW9yKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YWxsTWV0aG9kKHN0cnVjdEluc3RhbmNlLCBrLCBtLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgICAgICAgIHNlZW4uc2V0KG0sIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RydWN0SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmdW5jLFxuICAgICAgICAgIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrLFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgbmFtZSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG5hbWVcbiAgICAgICAgICAgID8gaW5zdGFsbE1ldGhvZHModGhpcywgLi4uYXJndW1lbnRzKVxuICAgICAgICAgICAgOiBpbnN0YWxsTWV0aG9kKHRoaXMsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2RzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgICAgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2ssXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBpbnN0YWxsTWV0aG9kcyh0aGlzLCBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChzcWxpdGUzKSB7XG4gICAgICAgIHNxbGl0ZTMudmVyc2lvbiA9IHtcbiAgICAgICAgICBsaWJWZXJzaW9uOiAnMy41MC40JyxcbiAgICAgICAgICBsaWJWZXJzaW9uTnVtYmVyOiAzMDUwMDA0LFxuICAgICAgICAgIHNvdXJjZUlkOlxuICAgICAgICAgICAgJzIwMjUtMDctMzAgMTk6MzM6NTMgNGQ4YWRmYjMwZTAzZjljZjI3ZjgwMGEyYzFiYTNjNDhmYjRjYTFiMDhiMGY1ZWQ1OWE0ZDVlY2JmNDVlMjBhMycsXG4gICAgICAgICAgZG93bmxvYWRWZXJzaW9uOiAzNTAwNDAwLFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3NzMyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNxbGl0ZTMuU1FMaXRlM0Vycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGksXG4gICAgICAgICAgd2FzbSA9IHNxbGl0ZTMud2FzbSxcbiAgICAgICAgICB1dGlsID0gc3FsaXRlMy51dGlsO1xuXG4gICAgICAgIGNvbnN0IF9fcHRyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgICBjb25zdCBfX3N0bXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICAgIGNvbnN0IGdldE93bk9wdGlvbiA9IChvcHRzLCBwLCBkZmx0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3B0cywgcCk7XG4gICAgICAgICAgcmV0dXJuIGQgPyBkLnZhbHVlIDogZGZsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjaGVja1NxbGl0ZTNSYyA9IGZ1bmN0aW9uIChkYlB0ciwgc3FsaXRlUmVzdWx0Q29kZSkge1xuICAgICAgICAgIGlmIChzcWxpdGVSZXN1bHRDb2RlKSB7XG4gICAgICAgICAgICBpZiAoZGJQdHIgaW5zdGFuY2VvZiBEQikgZGJQdHIgPSBkYlB0ci5wb2ludGVyO1xuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgIHNxbGl0ZVJlc3VsdENvZGUsXG4gICAgICAgICAgICAgICdzcWxpdGUzIHJlc3VsdCBjb2RlJyxcbiAgICAgICAgICAgICAgc3FsaXRlUmVzdWx0Q29kZSArICc6JyxcbiAgICAgICAgICAgICAgZGJQdHJcbiAgICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19lcnJtc2coZGJQdHIpXG4gICAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfZXJyc3RyKHNxbGl0ZVJlc3VsdENvZGUpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX2RiVHJhY2VUb0NvbnNvbGUgPSB3YXNtLmluc3RhbGxGdW5jdGlvbihcbiAgICAgICAgICAnaShpcHBwKScsXG4gICAgICAgICAgZnVuY3Rpb24gKHQsIGMsIHAsIHgpIHtcbiAgICAgICAgICAgIGlmIChjYXBpLlNRTElURV9UUkFDRV9TVE1UID09PSB0KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdTUUwgVFJBQ0UgIycgKyArK3RoaXMuY291bnRlciArICcgdmlhIHNxbGl0ZTNAJyArIGMgKyAnOicsXG4gICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh4KSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQoeyBjb3VudGVyOiAwIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IF9fdmZzUG9zdE9wZW5DYWxsYmFjayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgZGJDdG9ySGVscGVyID0gZnVuY3Rpb24gY3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKCFjdG9yLl9uYW1lMnZmcykge1xuICAgICAgICAgICAgY3Rvci5fbmFtZTJ2ZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgaXNXb3JrZXJUaHJlYWQgPVxuICAgICAgICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgaW1wb3J0U2NyaXB0c1xuICAgICAgICAgICAgICAgID8gKG4pID0+XG4gICAgICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgICAgICdUaGUgVkZTIGZvcicsXG4gICAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgICAnaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIG1haW4gd2luZG93IHRocmVhZC4nLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIGN0b3IuX25hbWUydmZzWyc6bG9jYWxTdG9yYWdlOiddID0ge1xuICAgICAgICAgICAgICB2ZnM6ICdrdnZmcycsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBpc1dvcmtlclRocmVhZCB8fCAoKCkgPT4gJ2xvY2FsJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3Rvci5fbmFtZTJ2ZnNbJzpzZXNzaW9uU3RvcmFnZTonXSA9IHtcbiAgICAgICAgICAgICAgdmZzOiAna3Z2ZnMnLFxuICAgICAgICAgICAgICBmaWxlbmFtZTogaXNXb3JrZXJUaHJlYWQgfHwgKCgpID0+ICdzZXNzaW9uJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvcHQgPSBjdG9yLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgICAgbGV0IGZuID0gb3B0LmZpbGVuYW1lLFxuICAgICAgICAgICAgdmZzTmFtZSA9IG9wdC52ZnMsXG4gICAgICAgICAgICBmbGFnc1N0ciA9IG9wdC5mbGFncztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoJ3N0cmluZycgIT09IHR5cGVvZiBmbiAmJiAnbnVtYmVyJyAhPT0gdHlwZW9mIGZuKSB8fFxuICAgICAgICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBmbGFnc1N0ciB8fFxuICAgICAgICAgICAgKHZmc05hbWUgJiZcbiAgICAgICAgICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiB2ZnNOYW1lICYmXG4gICAgICAgICAgICAgICdudW1iZXInICE9PSB0eXBlb2YgdmZzTmFtZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yKCdJbnZhbGlkIERCIGN0b3IgYXJncycsIG9wdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgREIgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBmbkpzID0gJ251bWJlcicgPT09IHR5cGVvZiBmbiA/IHdhc20uY3N0clRvSnMoZm4pIDogZm47XG4gICAgICAgICAgY29uc3QgdmZzQ2hlY2sgPSBjdG9yLl9uYW1lMnZmc1tmbkpzXTtcbiAgICAgICAgICBpZiAodmZzQ2hlY2spIHtcbiAgICAgICAgICAgIHZmc05hbWUgPSB2ZnNDaGVjay52ZnM7XG4gICAgICAgICAgICBmbiA9IGZuSnMgPSB2ZnNDaGVjay5maWxlbmFtZShmbkpzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBEYixcbiAgICAgICAgICAgIG9mbGFncyA9IDA7XG4gICAgICAgICAgaWYgKGZsYWdzU3RyLmluZGV4T2YoJ2MnKSA+PSAwKSB7XG4gICAgICAgICAgICBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEUgfCBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZsYWdzU3RyLmluZGV4T2YoJ3cnKSA+PSAwKSBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9SRUFEV1JJVEU7XG4gICAgICAgICAgaWYgKDAgPT09IG9mbGFncykgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFk7XG4gICAgICAgICAgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fRVhSRVNDT0RFO1xuICAgICAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFB0ciA9IHdhc20ucHN0YWNrLmFsbG9jUHRyKCk7XG4gICAgICAgICAgICBsZXQgcmMgPSBjYXBpLnNxbGl0ZTNfb3Blbl92MihmbiwgcFB0ciwgb2ZsYWdzLCB2ZnNOYW1lIHx8IDApO1xuICAgICAgICAgICAgcERiID0gd2FzbS5wZWVrUHRyKHBQdHIpO1xuICAgICAgICAgICAgY2hlY2tTcWxpdGUzUmMocERiLCByYyk7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzKHBEYiwgMSk7XG4gICAgICAgICAgICBpZiAoZmxhZ3NTdHIuaW5kZXhPZigndCcpID49IDApIHtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3RyYWNlX3YyKFxuICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9UUkFDRV9TVE1ULFxuICAgICAgICAgICAgICAgIF9fZGJUcmFjZVRvQ29uc29sZSxcbiAgICAgICAgICAgICAgICBwRGIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHBEYikgY2FwaS5zcWxpdGUzX2Nsb3NlX3YyKHBEYik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZuSnM7XG4gICAgICAgICAgX19wdHJNYXAuc2V0KHRoaXMsIHBEYik7XG4gICAgICAgICAgX19zdG10TWFwLnNldCh0aGlzLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcFZmcyA9XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19kYl92ZnMocERiKSB8fFxuICAgICAgICAgICAgICB0b3NzMygnSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBnZXQgVkZTIGZvciBuZXcgZGIgaGFuZGxlLicpO1xuICAgICAgICAgICAgY29uc3QgcG9zdEluaXRTcWwgPSBfX3Zmc1Bvc3RPcGVuQ2FsbGJhY2tbcFZmc107XG4gICAgICAgICAgICBpZiAocG9zdEluaXRTcWwpIHtcbiAgICAgICAgICAgICAgaWYgKHBvc3RJbml0U3FsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwb3N0SW5pdFNxbCh0aGlzLCBzcWxpdGUzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja1NxbGl0ZTNSYyhcbiAgICAgICAgICAgICAgICAgIHBEYixcbiAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19leGVjKHBEYiwgcG9zdEluaXRTcWwsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkYkN0b3JIZWxwZXIuc2V0VmZzUG9zdE9wZW5DYWxsYmFjayA9IGZ1bmN0aW9uIChwVmZzLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgJ2RiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlbkNhbGxiYWNrKCkgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ2Egbm9uLWZ1bmN0aW9uIGFyZ3VtZW50LicsXG4gICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9fdmZzUG9zdE9wZW5DYWxsYmFja1twVmZzXSA9IGNhbGxiYWNrO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbGVuYW1lID0gJzptZW1vcnk6JyxcbiAgICAgICAgICBmbGFncyA9ICdjJyxcbiAgICAgICAgICB2ZnMgPSBudWxsLFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSB7fTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAxID09PSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gJiZcbiAgICAgICAgICAgICdvYmplY3QnID09PSB0eXBlb2YgYXJndW1lbnRzWzBdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGFyZywgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGFyZy5mbGFncykgYXJnLmZsYWdzID0gJ2MnO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnLnZmcykgYXJnLnZmcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhcmcuZmlsZW5hbWUpIGFyZy5maWxlbmFtZSA9ICc6bWVtb3J5Oic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgYXJnLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICBhcmcudmZzID0gdmZzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IERCID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBkYkN0b3JIZWxwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIERCLmRiQ3RvckhlbHBlciA9IGRiQ3RvckhlbHBlcjtcblxuICAgICAgICBjb25zdCBCaW5kVHlwZXMgPSB7XG4gICAgICAgICAgbnVsbDogMSxcbiAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgc3RyaW5nOiAzLFxuICAgICAgICAgIGJvb2xlYW46IDQsXG4gICAgICAgICAgYmxvYjogNSxcbiAgICAgICAgfTtcbiAgICAgICAgQmluZFR5cGVzWyd1bmRlZmluZWQnXSA9PSBCaW5kVHlwZXMubnVsbDtcbiAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgIEJpbmRUeXBlcy5iaWdpbnQgPSBCaW5kVHlwZXMubnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgU3RtdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoQmluZFR5cGVzICE9PSBhcmd1bWVudHNbMl0pIHtcbiAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICdEbyBub3QgY2FsbCB0aGUgU3RtdCBjb25zdHJ1Y3RvciBkaXJlY3RseS4gVXNlIERCLnByZXBhcmUoKS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kYiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBfX3B0ck1hcC5zZXQodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlckNvdW50ID0gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50KHRoaXMucG9pbnRlcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtRGJPcGVuID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgaWYgKCFkYi5wb2ludGVyKSB0b3NzMygnREIgaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1Db2xJbmRleCA9IGZ1bmN0aW9uIChzdG10LCBuZHgpIHtcbiAgICAgICAgICBpZiAobmR4ICE9PSAobmR4IHwgMCkgfHwgbmR4IDwgMCB8fCBuZHggPj0gc3RtdC5jb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgdG9zczMoJ0NvbHVtbiBpbmRleCcsIG5keCwgJ2lzIG91dCBvZiByYW5nZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcGFyc2VFeGVjQXJncyA9IGZ1bmN0aW9uIChkYiwgYXJncykge1xuICAgICAgICAgIGNvbnN0IG91dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgb3V0Lm9wdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBhcmdzWzBdIHx8XG4gICAgICAgICAgICAgICAgdXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KGFyZ3NbMF0pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzWzBdICYmICdvYmplY3QnID09PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIG91dC5zcWwgPSBvdXQub3B0LnNxbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50IGNvdW50IGZvciBleGVjKCkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC5zcWwgPSB1dGlsLmZsZXhpYmxlU3RyaW5nKG91dC5zcWwpO1xuICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG91dC5zcWwpIHtcbiAgICAgICAgICAgIHRvc3MzKCdNaXNzaW5nIFNRTCBhcmd1bWVudCBvciB1bnN1cHBvcnRlZCBTUUwgdmFsdWUgdHlwZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3B0ID0gb3V0Lm9wdDtcbiAgICAgICAgICBzd2l0Y2ggKG9wdC5yZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAncmVzdWx0Um93cyc6XG4gICAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBvcHQucmVzdWx0Um93cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYXZlU3FsJzpcbiAgICAgICAgICAgICAgaWYgKCFvcHQuc2F2ZVNxbCkgb3B0LnNhdmVTcWwgPSBbXTtcbiAgICAgICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpID0+IG9wdC5zYXZlU3FsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAndGhpcyc6XG4gICAgICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKSA9PiBkYjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByZXR1cm5WYWx1ZSB2YWx1ZTonLCBvcHQucmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdC5jYWxsYmFjayAmJiAhb3B0LnJldHVyblZhbHVlICYmIHVuZGVmaW5lZCAhPT0gb3B0LnJvd01vZGUpIHtcbiAgICAgICAgICAgIGlmICghb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCkgPT4gb3B0LnJlc3VsdFJvd3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHQuY2FsbGJhY2sgfHwgb3B0LnJlc3VsdFJvd3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodW5kZWZpbmVkID09PSBvcHQucm93TW9kZSA/ICdhcnJheScgOiBvcHQucm93TW9kZSkge1xuICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10LCBjYWNoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5jb2x1bW5OYW1lcylcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuY29sdW1uTmFtZXMgPSBzdG10LmdldENvbHVtbk5hbWVzKFtdKTtcblxuICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gc3RtdC5nZXQoW10pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGNhY2hlLmNvbHVtbk5hbWVzKVxuICAgICAgICAgICAgICAgICAgICBydltjYWNoZS5jb2x1bW5OYW1lc1tpXV0gPSByb3dbaV07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10LmdldChbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0bXQnOlxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKSkge1xuICAgICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAgICdleGVjKCk6IGludmFsaWQgcm93TW9kZSBmb3IgYSByZXN1bHRSb3dzIGFycmF5OiBtdXN0JyxcbiAgICAgICAgICAgICAgICAgICAgXCJiZSBvbmUgb2YgJ2FycmF5JywgJ29iamVjdCcsXCIsXG4gICAgICAgICAgICAgICAgICAgICdhIHJlc3VsdCBjb2x1bW4gbnVtYmVyLCBvciBjb2x1bW4gbmFtZSByZWZlcmVuY2UuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KSA9PiBzdG10O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIob3B0LnJvd01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCkgPT4gc3RtdC5nZXQob3B0LnJvd01vZGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICdzdHJpbmcnID09PSB0eXBlb2Ygb3B0LnJvd01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG9wdC5yb3dNb2RlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICckJyA9PT0gb3B0LnJvd01vZGVbMF1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0ICRjb2xOYW1lID0gb3B0LnJvd01vZGUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKVskY29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQgPT09IHJjXG4gICAgICAgICAgICAgICAgICAgICAgPyB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdleGVjKCk6IHVua25vd24gcmVzdWx0IGNvbHVtbjonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAkY29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IHJjO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3NzMygnSW52YWxpZCByb3dNb2RlOicsIG9wdC5yb3dNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEZpcnN0Um93ID0gKGRiLCBzcWwsIGJpbmQsIC4uLmdldEFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG10ID0gZGIucHJlcGFyZShzcWwpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHN0bXQuYmluZChiaW5kKS5zdGVwKClcbiAgICAgICAgICAgICAgPyBzdG10LmdldCguLi5nZXRBcmdzKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfX3NlbGVjdEFsbCA9IChkYiwgc3FsLCBiaW5kLCByb3dNb2RlKSA9PlxuICAgICAgICAgIGRiLmV4ZWMoe1xuICAgICAgICAgICAgc3FsLFxuICAgICAgICAgICAgYmluZCxcbiAgICAgICAgICAgIHJvd01vZGUsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTogJ3Jlc3VsdFJvd3MnLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIERCLmNoZWNrUmMgPSAoZGIsIHJlc3VsdENvZGUpID0+IGNoZWNrU3FsaXRlM1JjKGRiLCByZXN1bHRDb2RlKTtcblxuICAgICAgICBEQi5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgaXNPcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFmZmlybU9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9uY2xvc2UgJiYgdGhpcy5vbmNsb3NlLmJlZm9yZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZS5iZWZvcmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwRGIgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9fc3RtdE1hcC5nZXQodGhpcykpLmZvckVhY2goKGssIHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocyAmJiBzLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHMuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBfX3N0bXRNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSAmJiB0aGlzLm9uY2xvc2UuYWZ0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UuYWZ0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hhbmdlczogZnVuY3Rpb24gKHRvdGFsID0gZmFsc2UsIHNpeHR5Rm91ciA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXI7XG4gICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpeHR5Rm91clxuICAgICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NChwKVxuICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXMocCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc2l4dHlGb3VyXG4gICAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY2hhbmdlczY0KHApXG4gICAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfY2hhbmdlcyhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJGaWxlbmFtZTogZnVuY3Rpb24gKGRiTmFtZSA9ICdtYWluJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19kYl9maWxlbmFtZShhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOYW1lKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJOYW1lOiBmdW5jdGlvbiAoZGJOdW1iZXIgPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2RiX25hbWUoYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTnVtYmVyKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGJWZnNOYW1lOiBmdW5jdGlvbiAoZGJOYW1lID0gMCkge1xuICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgY29uc3QgcFZmcyA9IGNhcGkuc3FsaXRlM19qc19kYl92ZnMoXG4gICAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLFxuICAgICAgICAgICAgICBkYk5hbWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHBWZnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJjID0gd2FzbS5jc3RyVG9Kcyh2LiR6TmFtZSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcHJlcGFyZTogZnVuY3Rpb24gKHNxbCkge1xuICAgICAgICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgICAgICAgbGV0IHBwU3RtdCwgcFN0bXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcFN0bXQgPSB3YXNtLnBzdGFjay5hbGxvYyg4KTtcbiAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyKHRoaXMucG9pbnRlciwgc3FsLCAtMSwgcHBTdG10LCBudWxsKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcFN0bXQgPSB3YXNtLnBlZWtQdHIocHBTdG10KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwU3RtdCkgdG9zczMoJ0Nhbm5vdCBwcmVwYXJlIGVtcHR5IFNRTC4nKTtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgIF9fc3RtdE1hcC5nZXQodGhpcylbcFN0bXRdID0gc3RtdDtcbiAgICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBleGVjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXJzZUV4ZWNBcmdzKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIWFyZy5zcWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvc3MzKCdleGVjKCkgcmVxdWlyZXMgYW4gU1FMIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGFyZy5vcHQ7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9wdC5jYWxsYmFjaztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFJvd3MgPSBBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKVxuICAgICAgICAgICAgICA/IG9wdC5yZXN1bHRSb3dzXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN0bXQ7XG4gICAgICAgICAgICBsZXQgYmluZCA9IG9wdC5iaW5kO1xuICAgICAgICAgICAgbGV0IGV2YWxGaXJzdFJlc3VsdCA9ICEhKFxuICAgICAgICAgICAgICBhcmcuY2JBcmcgfHxcbiAgICAgICAgICAgICAgb3B0LmNvbHVtbk5hbWVzIHx8XG4gICAgICAgICAgICAgIHJlc3VsdFJvd3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzYXZlU3FsID0gQXJyYXkuaXNBcnJheShvcHQuc2F2ZVNxbClcbiAgICAgICAgICAgICAgPyBvcHQuc2F2ZVNxbFxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzVEEgPSB1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkoYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGxldCBzcWxCeXRlTGVuID0gaXNUQVxuICAgICAgICAgICAgICAgID8gYXJnLnNxbC5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgOiB3YXNtLmpzdHJsZW4oYXJnLnNxbCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBwU3RtdCA9IHdhc20uc2NvcGVkQWxsb2MoXG4gICAgICAgICAgICAgICAgMiAqIHdhc20ucHRyU2l6ZW9mICsgKHNxbEJ5dGVMZW4gKyAxKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgcHpUYWlsID0gcHBTdG10ICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGxldCBwU3FsID0gcHpUYWlsICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgICAgICAgIGNvbnN0IHBTcWxFbmQgPSBwU3FsICsgc3FsQnl0ZUxlbjtcbiAgICAgICAgICAgICAgaWYgKGlzVEEpIHdhc20uaGVhcDgoKS5zZXQoYXJnLnNxbCwgcFNxbCk7XG4gICAgICAgICAgICAgIGVsc2Ugd2FzbS5qc3RyY3B5KGFyZy5zcWwsIHdhc20uaGVhcDgoKSwgcFNxbCwgc3FsQnl0ZUxlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UocFNxbCArIHNxbEJ5dGVMZW4sIDApO1xuICAgICAgICAgICAgICB3aGlsZSAocFNxbCAmJiB3YXNtLnBlZWsocFNxbCwgJ2k4JykpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIoW3BwU3RtdCwgcHpUYWlsXSwgMCk7XG4gICAgICAgICAgICAgICAgREIuY2hlY2tSYyhcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgICAgICBwU3FsLFxuICAgICAgICAgICAgICAgICAgICBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBwcFN0bXQsXG4gICAgICAgICAgICAgICAgICAgIHB6VGFpbCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RtdCA9IHdhc20ucGVla1B0cihwcFN0bXQpO1xuICAgICAgICAgICAgICAgIHBTcWwgPSB3YXNtLnBlZWtQdHIocHpUYWlsKTtcbiAgICAgICAgICAgICAgICBzcWxCeXRlTGVuID0gcFNxbEVuZCAtIHBTcWw7XG4gICAgICAgICAgICAgICAgaWYgKCFwU3RtdCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVTcWwpIHNhdmVTcWwucHVzaChjYXBpLnNxbGl0ZTNfc3FsKHBTdG10KS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZCAmJiBzdG10LnBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICAgICAgICBiaW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2YWxGaXJzdFJlc3VsdCAmJiBzdG10LmNvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ290Q29sTmFtZXMgPSBBcnJheS5pc0FycmF5KG9wdC5jb2x1bW5OYW1lcykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgIGV2YWxGaXJzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFyZy5jYkFyZyB8fCByZXN1bHRSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNiQXJnQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgc3RtdC5zdGVwKCk7IHN0bXQuX2xvY2tlZEJ5RXhlYyA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGdvdENvbE5hbWVzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjYkFyZ0NhY2hlLmNvbHVtbk5hbWVzID0gb3B0LmNvbHVtbk5hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN0bXQuX2xvY2tlZEJ5RXhlYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gYXJnLmNiQXJnKHN0bXQsIGNiQXJnQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRSb3dzKSByZXN1bHRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgZmFsc2UgPT09IGNhbGxiYWNrLmNhbGwob3B0LCByb3csIHN0bXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RtdC5fbG9ja2VkQnlFeGVjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gZ290Q29sTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RtdC5nZXRDb2x1bW5OYW1lcyhvcHQuY29sdW1uTmFtZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdG10LnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RtdC5yZXNldCgpLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgc3RtdCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc3RhY2spO1xuICAgICAgICAgICAgICBpZiAoc3RtdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG10Ll9sb2NrZWRCeUV4ZWM7XG4gICAgICAgICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnLnJldHVyblZhbCgpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gZihuYW1lLCB4RnVuYywgb3B0KSB7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSAoZikgPT4gZiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvcHQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBvcHQubmFtZTtcbiAgICAgICAgICAgICAgICB4RnVuYyA9IG9wdC54RnVuYyB8fCAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmMoeEZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgICBvcHQgPSB4RnVuYztcbiAgICAgICAgICAgICAgICAgIHhGdW5jID0gb3B0LnhGdW5jIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdCkgb3B0ID0ge307XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBuYW1lKSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGFyZ3VtZW50czogbWlzc2luZyBmdW5jdGlvbiBuYW1lLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHhTdGVwID0gb3B0LnhTdGVwIHx8IDA7XG4gICAgICAgICAgICBsZXQgeEZpbmFsID0gb3B0LnhGaW5hbCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgeFZhbHVlID0gb3B0LnhWYWx1ZSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgeEludmVyc2UgPSBvcHQueEludmVyc2UgfHwgMDtcbiAgICAgICAgICAgIGxldCBpc1dpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpc0Z1bmMoeEZ1bmMpKSB7XG4gICAgICAgICAgICAgIGlzV2luZG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmMoeFN0ZXApIHx8IGlzRnVuYyh4RmluYWwpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoJ0FtYmlndW91cyBhcmd1bWVudHM6IHNjYWxhciBvciBhZ2dyZWdhdGU/Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeFN0ZXAgPSB4RmluYWwgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeFN0ZXApKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGdW5jKHhGaW5hbCkpIHtcbiAgICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyB4RmluYWwoKSBjYWxsYmFjayBmb3IgYWdncmVnYXRlIG9yIHdpbmRvdyBVREYuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeEZ1bmMgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmMoeEZpbmFsKSkge1xuICAgICAgICAgICAgICB0b3NzMygnTWlzc2luZyB4U3RlcCgpIGNhbGxiYWNrIGZvciBhZ2dyZWdhdGUgb3Igd2luZG93IFVERi4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdNaXNzaW5nIGZ1bmN0aW9uLXR5cGUgcHJvcGVydGllcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gaXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRnVuYyh4VmFsdWUpIHx8IGlzRnVuYyh4SW52ZXJzZSkpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICd4VmFsdWUgYW5kIHhJbnZlcnNlIGFyZSBub3QgcGVybWl0dGVkIGZvciBub24td2luZG93IFVERnMuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuYyh4VmFsdWUpKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGdW5jKHhJbnZlcnNlKSkge1xuICAgICAgICAgICAgICAgIHRvc3MzKCd4SW52ZXJzZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHhWYWx1ZSBpcy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc1dpbmRvdyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuYyh4SW52ZXJzZSkpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ3hWYWx1ZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHhJbnZlcnNlIGlzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcEFwcCA9IG9wdC5wQXBwO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB1bmRlZmluZWQgIT09IHBBcHAgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcEFwcCAmJlxuICAgICAgICAgICAgICAoJ251bWJlcicgIT09IHR5cGVvZiBwQXBwIHx8ICF1dGlsLmlzSW50MzIocEFwcCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUgZm9yIHBBcHAgcHJvcGVydHkuIE11c3QgYmUgYSBsZWdhbCBXQVNNIHBvaW50ZXIgdmFsdWUuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHhEZXN0cm95ID0gb3B0LnhEZXN0cm95IHx8IDA7XG4gICAgICAgICAgICBpZiAoeERlc3Ryb3kgJiYgIWlzRnVuYyh4RGVzdHJveSkpIHtcbiAgICAgICAgICAgICAgdG9zczMoJ3hEZXN0cm95IHByb3BlcnR5IG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmRmxhZ3MgPSAwO1xuICAgICAgICAgICAgaWYgKGdldE93bk9wdGlvbihvcHQsICdkZXRlcm1pbmlzdGljJykpXG4gICAgICAgICAgICAgIGZGbGFncyB8PSBjYXBpLlNRTElURV9ERVRFUk1JTklTVElDO1xuICAgICAgICAgICAgaWYgKGdldE93bk9wdGlvbihvcHQsICdkaXJlY3RPbmx5JykpXG4gICAgICAgICAgICAgIGZGbGFncyB8PSBjYXBpLlNRTElURV9ESVJFQ1RPTkxZO1xuICAgICAgICAgICAgaWYgKGdldE93bk9wdGlvbihvcHQsICdpbm5vY3VvdXMnKSkgZkZsYWdzIHw9IGNhcGkuU1FMSVRFX0lOTk9DVU9VUztcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCB4QXJpdHkgPSB4RnVuYyB8fCB4U3RlcDtcbiAgICAgICAgICAgIGNvbnN0IGFyaXR5ID0gZ2V0T3duT3B0aW9uKG9wdCwgJ2FyaXR5Jyk7XG4gICAgICAgICAgICBjb25zdCBhcml0eUFyZyA9XG4gICAgICAgICAgICAgICdudW1iZXInID09PSB0eXBlb2YgYXJpdHlcbiAgICAgICAgICAgICAgICA/IGFyaXR5XG4gICAgICAgICAgICAgICAgOiB4QXJpdHkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IHhBcml0eS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgICBpZiAoaXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhcml0eUFyZyxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9VVEY4IHwgZkZsYWdzLFxuICAgICAgICAgICAgICAgIHBBcHAgfHwgMCxcbiAgICAgICAgICAgICAgICB4U3RlcCxcbiAgICAgICAgICAgICAgICB4RmluYWwsXG4gICAgICAgICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgICAgICAgIHhJbnZlcnNlLFxuICAgICAgICAgICAgICAgIHhEZXN0cm95LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyKFxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGFyaXR5QXJnLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1VURjggfCBmRmxhZ3MsXG4gICAgICAgICAgICAgICAgcEFwcCB8fCAwLFxuICAgICAgICAgICAgICAgIHhGdW5jLFxuICAgICAgICAgICAgICAgIHhTdGVwLFxuICAgICAgICAgICAgICAgIHhGaW5hbCxcbiAgICAgICAgICAgICAgICB4RGVzdHJveSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERCLmNoZWNrUmModGhpcywgcmMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdFZhbHVlOiBmdW5jdGlvbiAoc3FsLCBiaW5kLCBhc1R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NlbGVjdEZpcnN0Um93KHRoaXMsIHNxbCwgYmluZCwgMCwgYXNUeXBlKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0VmFsdWVzOiBmdW5jdGlvbiAoc3FsLCBiaW5kLCBhc1R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0bXQgPSB0aGlzLnByZXBhcmUoc3FsKSxcbiAgICAgICAgICAgICAgcmMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0bXQuYmluZChiaW5kKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0bXQuc3RlcCgpKSByYy5wdXNoKHN0bXQuZ2V0KDAsIGFzVHlwZSkpO1xuICAgICAgICAgICAgICBzdG10LnJlc2V0KCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBzdG10LmZpbmFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNlbGVjdEFycmF5OiBmdW5jdGlvbiAoc3FsLCBiaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIFtdKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0T2JqZWN0OiBmdW5jdGlvbiAoc3FsLCBiaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIHt9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0QXJyYXlzOiBmdW5jdGlvbiAoc3FsLCBiaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zZWxlY3RBbGwodGhpcywgc3FsLCBiaW5kLCAnYXJyYXknKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0T2JqZWN0czogZnVuY3Rpb24gKHNxbCwgYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc2VsZWN0QWxsKHRoaXMsIHNxbCwgYmluZCwgJ29iamVjdCcpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBvcGVuU3RhdGVtZW50Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50ZXIgPyBPYmplY3Qua2V5cyhfX3N0bXRNYXAuZ2V0KHRoaXMpKS5sZW5ndGggOiAwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgb3BlbmVyID0gJ0JFR0lOJztcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBpZiAoL1teYS16QS1aXS8udGVzdChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBmb3IgQkVHSU4gcXVhbGlmaWVyLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVuZXIgKz0gJyAnICsgYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5leGVjKG9wZW5lcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ0NPTU1JVCcpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhlYygnUk9MTEJBQ0snKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2F2ZXBvaW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5leGVjKCdTQVZFUE9JTlQgb28xJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ1JFTEVBU0Ugb28xJyk7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5leGVjKCdST0xMQkFDSyB0byBTQVZFUE9JTlQgb28xOyBSRUxFQVNFIFNBVkVQT0lOVCBvbzEnKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hlY2tSYzogZnVuY3Rpb24gKHJlc3VsdENvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1NxbGl0ZTNSYyh0aGlzLCByZXN1bHRDb2RlKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFmZmlybVN0bXRPcGVuID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgICBpZiAoIXN0bXQucG9pbnRlcikgdG9zczMoJ1N0bXQgaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzU3VwcG9ydGVkQmluZFR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGxldCB0ID0gQmluZFR5cGVzW251bGwgPT09IHYgfHwgdW5kZWZpbmVkID09PSB2ID8gJ251bGwnIDogdHlwZW9mIHZdO1xuICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLm51bGw6XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udW1iZXI6XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuYmlnaW50OlxuICAgICAgICAgICAgICBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSByZXR1cm4gdDtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodikgPyBCaW5kVHlwZXMuYmxvYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1N1cHBvcnRlZEJpbmRUeXBlKHYpIHx8XG4gICAgICAgICAgICB0b3NzMygnVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6JywgdHlwZW9mIHYpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhZmZpcm1QYXJhbUluZGV4ID0gZnVuY3Rpb24gKHN0bXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IG4gPVxuICAgICAgICAgICAgJ251bWJlcicgPT09IHR5cGVvZiBrZXlcbiAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgoc3RtdC5wb2ludGVyLCBrZXkpO1xuICAgICAgICAgIGlmICgwID09PSBuIHx8ICF1dGlsLmlzSW50MzIobikpIHtcbiAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGJpbmQoKSBwYXJhbWV0ZXIgbmFtZTogJyArIGtleSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuIDwgMSB8fCBuID4gc3RtdC5wYXJhbWV0ZXJDb3VudClcbiAgICAgICAgICAgIHRvc3MzKCdCaW5kIGluZGV4Jywga2V5LCAnaXMgb3V0IG9mIHJhbmdlLicpO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFmZmlybU5vdExvY2tlZEJ5RXhlYyA9IGZ1bmN0aW9uIChzdG10LCBjdXJyZW50T3BOYW1lKSB7XG4gICAgICAgICAgaWYgKHN0bXQuX2xvY2tlZEJ5RXhlYykge1xuICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICdPcGVyYXRpb24gaXMgaWxsZWdhbCB3aGVuIHN0YXRlbWVudCBpcyBsb2NrZWQ6JyxcbiAgICAgICAgICAgICAgY3VycmVudE9wTmFtZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGJpbmRPbmUgPSBmdW5jdGlvbiBmKHN0bXQsIG5keCwgYmluZFR5cGUsIHZhbCkge1xuICAgICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyhhZmZpcm1TdG10T3BlbihzdG10KSwgJ2JpbmQoKScpO1xuICAgICAgICAgIGlmICghZi5fKSB7XG4gICAgICAgICAgICBmLl90b29CaWdJbnQgPSAodikgPT5cbiAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgJ0JpZ0ludCB2YWx1ZSBpcyB0b28gYmlnIHRvIHN0b3JlIHdpdGhvdXQgcHJlY2lzaW9uIGxvc3M6JyxcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZi5fID0ge1xuICAgICAgICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChzdG10LCBuZHgsIHZhbCwgYXNCbG9iKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BTdHIsIG5dID0gd2FzbS5hbGxvY0NTdHJpbmcodmFsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gYXNCbG9iXG4gICAgICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19iaW5kX2Jsb2JcbiAgICAgICAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2JpbmRfdGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihzdG10LnBvaW50ZXIsIG5keCwgcFN0ciwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKHZhbCk7XG4gICAgICAgICAgbmR4ID0gYWZmaXJtUGFyYW1JbmRleChzdG10LCBuZHgpO1xuICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgIG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCA/IEJpbmRUeXBlcy5udWxsIDogYmluZFR5cGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLm51bGw6XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfbnVsbChzdG10LnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgICAgICByYyA9IGYuXy5zdHJpbmcoc3RtdCwgbmR4LCB2YWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmRUeXBlcy5udW1iZXI6IHtcbiAgICAgICAgICAgICAgbGV0IG07XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzSW50MzIodmFsKSkgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoJ2JpZ2ludCcgPT09IHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuYmlnSW50Rml0czY0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGYuX3Rvb0JpZ0ludCh2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzbS5iaWdJbnRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50NjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmJpZ0ludEZpdHNEb3VibGUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfZG91YmxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmLl90b29CaWdJbnQodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ2NDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2RvdWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmMgPSBtKHN0bXQucG9pbnRlciwgbmR4LCB2YWwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQmluZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50KHN0bXQucG9pbnRlciwgbmR4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5kVHlwZXMuYmxvYjoge1xuICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICByYyA9IGYuXy5zdHJpbmcoc3RtdCwgbmR4LCB2YWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdG9zczMoXG4gICAgICAgICAgICAgICAgICAnQmluZGluZyBhIHZhbHVlIGFzIGEgYmxvYiByZXF1aXJlcycsXG4gICAgICAgICAgICAgICAgICAndGhhdCBpdCBiZSBhIHN0cmluZywgVWludDhBcnJheSwgSW50OEFycmF5LCBvciBBcnJheUJ1ZmZlci4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jKHZhbC5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgICAgICB3YXNtLmhlYXA4KCkuc2V0KHZhbC5ieXRlTGVuZ3RoID8gdmFsIDogWzBdLCBwQmxvYik7XG4gICAgICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfYmxvYihcbiAgICAgICAgICAgICAgICBzdG10LnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgbmR4LFxuICAgICAgICAgICAgICAgIHBCbG9iLFxuICAgICAgICAgICAgICAgIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKCdVbnN1cHBvcnRlZCBiaW5kKCkgYXJndW1lbnQgdHlwZTonLCB2YWwpO1xuICAgICAgICAgICAgICB0b3NzMygnVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJjKSBEQi5jaGVja1JjKHN0bXQuZGIucG9pbnRlciwgcmMpO1xuICAgICAgICAgIHN0bXQuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0bXQucHJvdG90eXBlID0ge1xuICAgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyKSB7XG4gICAgICAgICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCAnZmluYWxpemUoKScpO1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19maW5hbGl6ZSh0aGlzLnBvaW50ZXIpO1xuICAgICAgICAgICAgICBkZWxldGUgX19zdG10TWFwLmdldCh0aGlzLmRiKVt0aGlzLnBvaW50ZXJdO1xuICAgICAgICAgICAgICBfX3B0ck1hcC5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXlHZXQ7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlckNvdW50O1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9ja2VkQnlFeGVjO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjbGVhckJpbmRpbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMoYWZmaXJtU3RtdE9wZW4odGhpcyksICdjbGVhckJpbmRpbmdzKCknKTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19jbGVhcl9iaW5kaW5ncyh0aGlzLnBvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIChhbHNvQ2xlYXJCaW5kcykge1xuICAgICAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsICdyZXNldCgpJyk7XG4gICAgICAgICAgICBpZiAoYWxzb0NsZWFyQmluZHMpIHRoaXMuY2xlYXJCaW5kaW5ncygpO1xuICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfcmVzZXQoYWZmaXJtU3RtdE9wZW4odGhpcykucG9pbnRlcik7XG4gICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNoZWNrU3FsaXRlM1JjKHRoaXMuZGIsIHJjKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1TdG10T3Blbih0aGlzKTtcbiAgICAgICAgICAgIGxldCBuZHgsIGFyZztcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbmR4ID0gMTtcbiAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBuZHggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRvc3MzKCdJbnZhbGlkIGJpbmQoKSBhcmd1bWVudHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgICAgICAgIHRvc3MzKCdUaGlzIHN0YXRlbWVudCBoYXMgbm8gYmluZGFibGUgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGFyZykge1xuICAgICAgICAgICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIEJpbmRUeXBlcy5udWxsLCBhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICdXaGVuIGJpbmRpbmcgYW4gYXJyYXksIGFuIGluZGV4IGFyZ3VtZW50IGlzIG5vdCBwZXJtaXR0ZWQuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZy5mb3JFYWNoKCh2LCBpKSA9PlxuICAgICAgICAgICAgICAgIGJpbmRPbmUodGhpcywgaSArIDEsIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKHYpLCB2KSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIGFyZyA9IG5ldyBVaW50OEFycmF5KGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBhcmcgJiYgIXV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvc3MzKFxuICAgICAgICAgICAgICAgICAgJ1doZW4gYmluZGluZyBhbiBvYmplY3QsIGFuIGluZGV4IGFyZ3VtZW50IGlzIG5vdCBwZXJtaXR0ZWQuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaCgoaykgPT5cbiAgICAgICAgICAgICAgICBiaW5kT25lKHRoaXMsIGssIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKGFyZ1trXSksIGFyZ1trXSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmcpLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9zczMoJ1Nob3VsZCBub3QgcmVhY2ggdGhpcyBwb2ludC4nKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYmluZEFzQmxvYjogZnVuY3Rpb24gKG5keCwgYXJnKSB7XG4gICAgICAgICAgICBhZmZpcm1TdG10T3Blbih0aGlzKTtcbiAgICAgICAgICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFyZyA9IG5keDtcbiAgICAgICAgICAgICAgbmR4ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmcpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBCaW5kVHlwZXMuc3RyaW5nICE9PSB0ICYmXG4gICAgICAgICAgICAgIEJpbmRUeXBlcy5ibG9iICE9PSB0ICYmXG4gICAgICAgICAgICAgIEJpbmRUeXBlcy5udWxsICE9PSB0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdG9zczMoJ0ludmFsaWQgdmFsdWUgdHlwZSBmb3IgYmluZEFzQmxvYigpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIEJpbmRUeXBlcy5ibG9iLCBhcmcpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywgJ3N0ZXAoKScpO1xuICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfc3RlcChhZmZpcm1TdG10T3Blbih0aGlzKS5wb2ludGVyKTtcbiAgICAgICAgICAgIHN3aXRjaCAocmMpIHtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9ET05FOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fbWF5R2V0ID0gZmFsc2UpO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1JPVzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX21heUdldCA9IHRydWUpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgICAnc3FsaXRlM19zdGVwKCkgcmM9JyxcbiAgICAgICAgICAgICAgICAgIHJjLFxuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICAgICAnU1FMID0nLFxuICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3NxbCh0aGlzLnBvaW50ZXIpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgREIuY2hlY2tSYyh0aGlzLmRiLnBvaW50ZXIsIHJjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3RlcFJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHN0ZXBGaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAobmR4LCBhc1R5cGUpIHtcbiAgICAgICAgICAgIGlmICghYWZmaXJtU3RtdE9wZW4odGhpcykuX21heUdldCkge1xuICAgICAgICAgICAgICB0b3NzMygnU3RtdC5zdGVwKCkgaGFzIG5vdCAocmVjZW50bHkpIHJldHVybmVkIHRydWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZHgpKSB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIG5keFtpXSA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5keDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmR4ICYmICdvYmplY3QnID09PSB0eXBlb2YgbmR4KSB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIG5keFtjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUodGhpcy5wb2ludGVyLCBpKV0gPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZmZpcm1Db2xJbmRleCh0aGlzLCBuZHgpO1xuICAgICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgICAgdW5kZWZpbmVkID09PSBhc1R5cGVcbiAgICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jb2x1bW5fdHlwZSh0aGlzLnBvaW50ZXIsIG5keClcbiAgICAgICAgICAgICAgICA6IGFzVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfTlVMTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOiB7XG4gICAgICAgICAgICAgICAgaWYgKHdhc20uYmlnSW50RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2ludDY0KHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcmMgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmMgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHJjKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9kb3VibGUodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICByYyA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4gICAgICAgICAgICAgICAgICAgIHJjIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgICAgICAnSW50ZWdlciBpcyBvdXQgb2YgcmFuZ2UgZm9yIEpTIGludGVnZXIgcmFuZ2U6ICcgKyByYyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuaXNJbnQzMihyYykgPyByYyB8IDAgOiByYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9GTE9BVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9kb3VibGUodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1RFWFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fdGV4dCh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQkxPQjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2J5dGVzKHRoaXMucG9pbnRlciwgbmR4KSxcbiAgICAgICAgICAgICAgICAgIHB0ciA9IGNhcGkuc3FsaXRlM19jb2x1bW5fYmxvYih0aGlzLnBvaW50ZXIsIG5keCksXG4gICAgICAgICAgICAgICAgICByYyA9IG5ldyBVaW50OEFycmF5KG4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4pIHJjLnNldCh3YXNtLmhlYXA4dSgpLnNsaWNlKHB0ciwgcHRyICsgbiksIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gJiYgdGhpcy5kYi5fYmxvYlhmZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYi5fYmxvYlhmZXIucHVzaChyYy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0b3NzMyhcbiAgICAgICAgICAgICAgICAgIFwiRG9uJ3Qga25vdyBob3cgdG8gdHJhbnNsYXRlXCIsXG4gICAgICAgICAgICAgICAgICAndHlwZSBvZiByZXN1bHQgY29sdW1uICMnICsgbmR4ICsgJy4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3NzMygnTm90IHJlYWNoZWQuJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldEludDogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfSU5URUdFUik7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldEZsb2F0OiBmdW5jdGlvbiAobmR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9GTE9BVCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldFN0cmluZzogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfVEVYVCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldEJsb2I6IGZ1bmN0aW9uIChuZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX0JMT0IpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRKU09OOiBmdW5jdGlvbiAobmR4KSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9TVFJJTkcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT09IHMgPyBzIDogSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0Q29sdW1uTmFtZTogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fbmFtZShcbiAgICAgICAgICAgICAgYWZmaXJtQ29sSW5kZXgoYWZmaXJtU3RtdE9wZW4odGhpcyksIG5keCkucG9pbnRlcixcbiAgICAgICAgICAgICAgbmR4LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0Q29sdW1uTmFtZXM6IGZ1bmN0aW9uICh0Z3QgPSBbXSkge1xuICAgICAgICAgICAgYWZmaXJtQ29sSW5kZXgoYWZmaXJtU3RtdE9wZW4odGhpcyksIDApO1xuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICB0Z3QucHVzaChjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUodGhpcy5wb2ludGVyLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGd0O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRQYXJhbUluZGV4OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFmZmlybVN0bXRPcGVuKHRoaXMpLnBhcmFtZXRlckNvdW50XG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4KHRoaXMucG9pbnRlciwgbmFtZSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldFBhcmFtTmFtZTogZnVuY3Rpb24gKG5keCkge1xuICAgICAgICAgICAgcmV0dXJuIGFmZmlybVN0bXRPcGVuKHRoaXMpLnBhcmFtZXRlckNvdW50XG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUodGhpcy5wb2ludGVyLCBuZHgpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpc0J1c3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAwICE9PSBjYXBpLnNxbGl0ZTNfc3RtdF9idXN5KGFmZmlybVN0bXRPcGVuKHRoaXMpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNSZWFkT25seTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDAgIT09IGNhcGkuc3FsaXRlM19zdG10X3JlYWRvbmx5KGFmZmlybVN0bXRPcGVuKHRoaXMpKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwcm9wID0ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19wdHJNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogKCkgPT4gdG9zczMoJ1RoZSBwb2ludGVyIHByb3BlcnR5IGlzIHJlYWQtb25seS4nKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG10LnByb3RvdHlwZSwgJ3BvaW50ZXInLCBwcm9wKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoREIucHJvdG90eXBlLCAncG9pbnRlcicsIHByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0bXQucHJvdG90eXBlLCAnY29sdW1uQ291bnQnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9jb3VudCh0aGlzLnBvaW50ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiAoKSA9PiB0b3NzMygnVGhlIGNvbHVtbkNvdW50IHByb3BlcnR5IGlzIHJlYWQtb25seS4nKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3FsaXRlMy5vbzEgPSB7XG4gICAgICAgICAgREIsXG4gICAgICAgICAgU3RtdCxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXRpbC5pc1VJVGhyZWFkKCkpIHtcbiAgICAgICAgICBzcWxpdGUzLm9vMS5Kc1N0b3JhZ2VEYiA9IGZ1bmN0aW9uIChzdG9yYWdlTmFtZSA9ICdzZXNzaW9uJykge1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lID0gb3B0LmZpbGVuYW1lO1xuICAgICAgICAgICAgaWYgKCdzZXNzaW9uJyAhPT0gc3RvcmFnZU5hbWUgJiYgJ2xvY2FsJyAhPT0gc3RvcmFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgdG9zczMoXCJKc1N0b3JhZ2VEYiBkYiBuYW1lIG11c3QgYmUgb25lIG9mICdzZXNzaW9uJyBvciAnbG9jYWwnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdC52ZnMgPSAna3Z2ZnMnO1xuICAgICAgICAgICAgZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGpkYiA9IHNxbGl0ZTMub28xLkpzU3RvcmFnZURiO1xuICAgICAgICAgIGpkYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERCLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICBqZGIuY2xlYXJTdG9yYWdlID0gY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyO1xuXG4gICAgICAgICAgamRiLnByb3RvdHlwZS5jbGVhclN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gamRiLmNsZWFyU3RvcmFnZShhZmZpcm1EYk9wZW4odGhpcykuZmlsZW5hbWUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBqZGIuc3RvcmFnZVNpemUgPSBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZTtcblxuICAgICAgICAgIGpkYi5wcm90b3R5cGUuc3RvcmFnZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gamRiLnN0b3JhZ2VTaXplKGFmZmlybURiT3Blbih0aGlzKS5maWxlbmFtZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBjb25zdCB1dGlsID0gc3FsaXRlMy51dGlsO1xuICAgICAgICBzcWxpdGUzLmluaXRXb3JrZXIxQVBJID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIShnbG9iYWxUaGlzLldvcmtlckdsb2JhbFNjb3BlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0b3NzKCdpbml0V29ya2VyMUFQSSgpIG11c3QgYmUgcnVuIGZyb20gYSBXb3JrZXIgdGhyZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzcWxpdGUzID0gdGhpcy5zcWxpdGUzIHx8IHRvc3MoJ01pc3NpbmcgdGhpcy5zcWxpdGUzIG9iamVjdC4nKTtcbiAgICAgICAgICBjb25zdCBEQiA9IHNxbGl0ZTMub28xLkRCO1xuXG4gICAgICAgICAgY29uc3QgZ2V0RGJJZCA9IGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgbGV0IGlkID0gd1N0YXRlLmlkTWFwLmdldChkYik7XG4gICAgICAgICAgICBpZiAoaWQpIHJldHVybiBpZDtcbiAgICAgICAgICAgIGlkID0gJ2RiIycgKyArK3dTdGF0ZS5pZFNlcSArICdAJyArIGRiLnBvaW50ZXI7XG5cbiAgICAgICAgICAgIHdTdGF0ZS5pZE1hcC5zZXQoZGIsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgd1N0YXRlID0ge1xuICAgICAgICAgICAgZGJMaXN0OiBbXSxcblxuICAgICAgICAgICAgaWRTZXE6IDAsXG5cbiAgICAgICAgICAgIGlkTWFwOiBuZXcgV2Vha01hcCgpLFxuXG4gICAgICAgICAgICB4ZmVyOiBbXSxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBuZXcgREIob3B0KTtcbiAgICAgICAgICAgICAgdGhpcy5kYnNbZ2V0RGJJZChkYildID0gZGI7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmRiTGlzdC5pbmRleE9mKGRiKSA8IDApIHRoaXMuZGJMaXN0LnB1c2goZGIpO1xuICAgICAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChkYiwgYWxzb1VubGluaykge1xuICAgICAgICAgICAgICBpZiAoZGIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYnNbZ2V0RGJJZChkYildO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZGIuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcFZmcyA9IHV0aWwuc3FsaXRlM19fd2FzbV9kYl92ZnMoZGIucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZE5keCA9IHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpO1xuICAgICAgICAgICAgICAgIGlmIChkZE5keCA+PSAwKSB0aGlzLmRiTGlzdC5zcGxpY2UoZGROZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhbHNvVW5saW5rICYmIGZpbGVuYW1lICYmIHBWZnMpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwuc3FsaXRlM19fd2FzbV92ZnNfdW5saW5rKHBWZnMsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIChtc2csIHhmZXJMaXN0KSB7XG4gICAgICAgICAgICAgIGlmICh4ZmVyTGlzdCAmJiB4ZmVyTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKG1zZywgQXJyYXkuZnJvbSh4ZmVyTGlzdCkpO1xuICAgICAgICAgICAgICAgIHhmZXJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkYnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgICAgICAgIGdldERiOiBmdW5jdGlvbiAoaWQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5kYnNbaWRdIHx8XG4gICAgICAgICAgICAgICAgKHJlcXVpcmUgPyB0b3NzKCdVbmtub3duIChvciBjbG9zZWQpIERCIElEOicsIGlkKSA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGFmZmlybURiT3BlbiA9IGZ1bmN0aW9uIChkYiA9IHdTdGF0ZS5kYkxpc3RbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYiAmJiBkYi5wb2ludGVyID8gZGIgOiB0b3NzKCdEQiBpcyBub3Qgb3BlbmVkLicpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBnZXRNc2dEYiA9IGZ1bmN0aW9uIChtc2dEYXRhLCBhZmZpcm1FeGlzdHMgPSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBkYiA9IHdTdGF0ZS5nZXREYihtc2dEYXRhLmRiSWQsIGZhbHNlKSB8fCB3U3RhdGUuZGJMaXN0WzBdO1xuICAgICAgICAgICAgcmV0dXJuIGFmZmlybUV4aXN0cyA/IGFmZmlybURiT3BlbihkYikgOiBkYjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZ2V0RGVmYXVsdERiSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd1N0YXRlLmRiTGlzdFswXSAmJiBnZXREYklkKHdTdGF0ZS5kYkxpc3RbMF0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBpc1NwZWNpYWxEYkZpbGVuYW1lID0gKG4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAnJyA9PT0gbiB8fCAnOicgPT09IG5bMF07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IHdNc2dIYW5kbGVyID0ge1xuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9hcmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBhcmdzID0gZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBpZiAoYXJncy5zaW11bGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnVGhyb3dpbmcgYmVjYXVzZSBvZiBzaW11bGF0ZUVycm9yIGZsYWcuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBvYXJncy52ZnMgPSBhcmdzLnZmcztcbiAgICAgICAgICAgICAgb2FyZ3MuZmlsZW5hbWUgPSBhcmdzLmZpbGVuYW1lIHx8ICcnO1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IHdTdGF0ZS5vcGVuKG9hcmdzKTtcbiAgICAgICAgICAgICAgcmMuZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgICAgICAgcmMucGVyc2lzdGVudCA9ICEhc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfdXNlc192ZnMoXG4gICAgICAgICAgICAgICAgZGIucG9pbnRlcixcbiAgICAgICAgICAgICAgICAnb3BmcycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJjLmRiSWQgPSBnZXREYklkKGRiKTtcbiAgICAgICAgICAgICAgcmMudmZzID0gZGIuZGJWZnNOYW1lKCk7XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldiwgZmFsc2UpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZGIgJiYgZGIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvVW5saW5rID1cbiAgICAgICAgICAgICAgICAgIGV2LmFyZ3MgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICAgID8gISFldi5hcmdzLnVubGlua1xuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdTdGF0ZS5jbG9zZShkYiwgZG9VbmxpbmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCByYyA9XG4gICAgICAgICAgICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBldi5hcmdzXG4gICAgICAgICAgICAgICAgICA/IHsgc3FsOiBldi5hcmdzIH1cbiAgICAgICAgICAgICAgICAgIDogZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBpZiAoJ3N0bXQnID09PSByYy5yb3dNb2RlKSB7XG4gICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCByb3dNb2RlIGZvciAnZXhlYyc6IHN0bXQgbW9kZVwiLFxuICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IHdvcmsgaW4gdGhlIFdvcmtlciBBUEkuJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyYy5zcWwpIHtcbiAgICAgICAgICAgICAgICB0b3NzKFwiJ2V4ZWMnIHJlcXVpcmVzIGlucHV0IFNRTC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldik7XG4gICAgICAgICAgICAgIGlmIChyYy5jYWxsYmFjayB8fCBBcnJheS5pc0FycmF5KHJjLnJlc3VsdFJvd3MpKSB7XG4gICAgICAgICAgICAgICAgZGIuX2Jsb2JYZmVyID0gd1N0YXRlLnhmZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGhlQ2FsbGJhY2sgPSByYy5jYWxsYmFjaztcbiAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGhhZENvbE5hbWVzID0gISFyYy5jb2x1bW5OYW1lcztcbiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhZENvbE5hbWVzKSByYy5jb2x1bW5OYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSBmdW5jdGlvbiAocm93LCBzdG10KSB7XG4gICAgICAgICAgICAgICAgICB3U3RhdGUucG9zdChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoZUNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzOiByYy5jb2x1bW5OYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6ICsrcm93TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3U3RhdGUueGZlcixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUNvdW50ID0gISFyYy5jb3VudENoYW5nZXNcbiAgICAgICAgICAgICAgICAgID8gZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKVxuICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGIuZXhlYyhyYyk7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gY2hhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHJjLmNoYW5nZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgZGIuY2hhbmdlcyh0cnVlLCA2NCA9PT0gcmMuY291bnRDaGFuZ2VzKSAtIGNoYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5zZXJ0Um93SWQgPSAhIXJjLmxhc3RJbnNlcnRSb3dJZFxuICAgICAgICAgICAgICAgICAgPyBzcWxpdGUzLmNhcGkuc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZChkYilcbiAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGxhc3RJbnNlcnRSb3dJZCkge1xuICAgICAgICAgICAgICAgICAgcmMubGFzdEluc2VydFJvd0lkID0gbGFzdEluc2VydFJvd0lkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmMuY2FsbGJhY2sgPSB0aGVDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGVDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZXM6IHJjLmNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgICAgICAgICByb3dOdW1iZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYi5fYmxvYlhmZXI7XG4gICAgICAgICAgICAgICAgaWYgKHJjLmNhbGxiYWNrKSByYy5jYWxsYmFjayA9IHRoZUNhbGxiYWNrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdjb25maWctZ2V0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgc3JjID0gc3FsaXRlMy5jb25maWc7XG4gICAgICAgICAgICAgIFsnYmlnSW50RW5hYmxlZCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGspKSByY1trXSA9IHNyY1trXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJjLnZlcnNpb24gPSBzcWxpdGUzLnZlcnNpb247XG4gICAgICAgICAgICAgIHJjLnZmc0xpc3QgPSBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc192ZnNfbGlzdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBleHBvcnQ6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5OiBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQoZGIucG9pbnRlciksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGRiLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1pbWV0eXBlOiAnYXBwbGljYXRpb24veC1zcWxpdGUzJyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgd1N0YXRlLnhmZXIucHVzaChyZXNwb25zZS5ieXRlQXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9zczogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIHRvc3MoJ1Rlc3Rpbmcgd29ya2VyIGV4Y2VwdGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGV2ID0gZXYuZGF0YTtcbiAgICAgICAgICAgIGxldCByZXN1bHQsXG4gICAgICAgICAgICAgIGRiSWQgPSBldi5kYklkLFxuICAgICAgICAgICAgICBldlR5cGUgPSBldi50eXBlO1xuICAgICAgICAgICAgY29uc3QgYXJyaXZhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3TXNnSGFuZGxlci5oYXNPd25Qcm9wZXJ0eShldlR5cGUpICYmXG4gICAgICAgICAgICAgICAgd01zZ0hhbmRsZXJbZXZUeXBlXSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHdNc2dIYW5kbGVyW2V2VHlwZV0oZXYpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvc3MoJ1Vua25vd24gZGIgd29ya2VyIG1lc3NhZ2UgdHlwZTonLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGV2VHlwZSA9ICdlcnJvcic7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGV2LnR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3JDbGFzczogZXJyLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGV2LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YWNrID1cbiAgICAgICAgICAgICAgICAgICdzdHJpbmcnID09PSB0eXBlb2YgZXJyLnN0YWNrXG4gICAgICAgICAgICAgICAgICAgID8gZXJyLnN0YWNrLnNwbGl0KC9cXG5cXHMqLylcbiAgICAgICAgICAgICAgICAgICAgOiBlcnIuc3RhY2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDApXG4gICAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybihcbiAgICAgICAgICAgICAgICAgICdXb3JrZXIgaXMgcHJvcGFnYXRpbmcgYW4gZXhjZXB0aW9uIHRvIG1haW4gdGhyZWFkLicsXG4gICAgICAgICAgICAgICAgICAnUmVwb3J0aW5nIGl0IF9oZXJlXyBmb3IgdGhlIHN0YWNrIHRyYWNlOicsXG4gICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGJJZCkge1xuICAgICAgICAgICAgICBkYklkID0gcmVzdWx0LmRiSWQgfHwgZ2V0RGVmYXVsdERiSWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd1N0YXRlLnBvc3QoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldlR5cGUsXG4gICAgICAgICAgICAgICAgZGJJZDogZGJJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGV2Lm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICB3b3JrZXJSZWNlaXZlZFRpbWU6IGFycml2YWxUaW1lLFxuICAgICAgICAgICAgICAgIHdvcmtlclJlc3BvbmRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICBkZXBhcnR1cmVUaW1lOiBldi5kZXBhcnR1cmVUaW1lLFxuXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHdTdGF0ZS54ZmVyLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3NxbGl0ZTMtYXBpJyxcbiAgICAgICAgICAgIHJlc3VsdDogJ3dvcmtlcjEtcmVhZHknLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQoeyBzcWxpdGUzIH0pO1xuICAgICAgfSk7XG5cbiAgICAgICgndXNlIHN0cmljdCcpO1xuICAgICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChzcWxpdGUzKSB7XG4gICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc20sXG4gICAgICAgICAgY2FwaSA9IHNxbGl0ZTMuY2FwaSxcbiAgICAgICAgICB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3MzO1xuICAgICAgICBjb25zdCB2ZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBzcWxpdGUzLnZmcyA9IHZmcztcblxuICAgICAgICBjYXBpLnNxbGl0ZTNfdmZzLnByb3RvdHlwZS5yZWdpc3RlclZmcyA9IGZ1bmN0aW9uIChhc0RlZmF1bHQgPSBmYWxzZSkge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBzcWxpdGUzLmNhcGkuc3FsaXRlM192ZnMpKSB7XG4gICAgICAgICAgICB0b3NzKCdFeHBlY3RpbmcgYSBzcWxpdGUzX3Zmcy10eXBlIGFyZ3VtZW50LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM192ZnNfcmVnaXN0ZXIodGhpcywgYXNEZWZhdWx0ID8gMSA6IDApO1xuICAgICAgICAgIGlmIChyYykge1xuICAgICAgICAgICAgdG9zcygnc3FsaXRlM192ZnNfcmVnaXN0ZXIoJywgdGhpcywgJykgZmFpbGVkIHdpdGggcmMnLCByYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXIgIT09IGNhcGkuc3FsaXRlM192ZnNfZmluZCh0aGlzLiR6TmFtZSkpIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdCVUc6IHNxbGl0ZTNfdmZzX2ZpbmQodmZzLiR6TmFtZSkgZmFpbGVkIGZvciBqdXN0LWluc3RhbGxlZCBWRlMnLFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmZzLmluc3RhbGxWZnMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICBjb25zdCBwcm9wTGlzdCA9IFsnaW8nLCAndmZzJ107XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcHJvcExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBvcHRba2V5XTtcbiAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICAgIG8uc3RydWN0Lmluc3RhbGxNZXRob2RzKG8ubWV0aG9kcywgISFvLmFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgICAgICAgaWYgKCd2ZnMnID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW8uc3RydWN0LiR6TmFtZSAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIG8ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgby5zdHJ1Y3QuYWRkT25EaXNwb3NlKFxuICAgICAgICAgICAgICAgICAgICAoby5zdHJ1Y3QuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcoby5uYW1lKSksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvLnN0cnVjdC5yZWdpc3RlclZmcyghIW8uYXNEZWZhdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvdW50KVxuICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgJ01pc3VzZTogaW5zdGFsbFZmcygpIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVzIGF0IGxlYXN0JyxcbiAgICAgICAgICAgICAgJ29uZSBvZjonLFxuICAgICAgICAgICAgICBwcm9wTGlzdCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKHNxbGl0ZTMpIHtcbiAgICAgICAgaWYgKCFzcWxpdGUzLndhc20uZXhwb3J0cy5zcWxpdGUzX2RlY2xhcmVfdnRhYikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtLFxuICAgICAgICAgIGNhcGkgPSBzcWxpdGUzLmNhcGksXG4gICAgICAgICAgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzMztcbiAgICAgICAgY29uc3QgdnRhYiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHNxbGl0ZTMudnRhYiA9IHZ0YWI7XG5cbiAgICAgICAgY29uc3Qgc2lpID0gY2FwaS5zcWxpdGUzX2luZGV4X2luZm87XG5cbiAgICAgICAgc2lpLnByb3RvdHlwZS5udGhDb25zdHJhaW50ID0gZnVuY3Rpb24gKG4sIGFzUHRyID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSB0aGlzLiRuQ29uc3RyYWludCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHB0ciA9XG4gICAgICAgICAgICB0aGlzLiRhQ29uc3RyYWludCArXG4gICAgICAgICAgICBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50LnN0cnVjdEluZm8uc2l6ZW9mICogbjtcbiAgICAgICAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludChwdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpaS5wcm90b3R5cGUubnRoQ29uc3RyYWludFVzYWdlID0gZnVuY3Rpb24gKG4sIGFzUHRyID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSB0aGlzLiRuQ29uc3RyYWludCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHB0ciA9XG4gICAgICAgICAgICB0aGlzLiRhQ29uc3RyYWludFVzYWdlICtcbiAgICAgICAgICAgIHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2Uuc3RydWN0SW5mby5zaXplb2YgKiBuO1xuICAgICAgICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlKHB0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lpLnByb3RvdHlwZS5udGhPcmRlckJ5ID0gZnVuY3Rpb24gKG4sIGFzUHRyID0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSB0aGlzLiRuT3JkZXJCeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHB0ciA9XG4gICAgICAgICAgICB0aGlzLiRhT3JkZXJCeSArIHNpaS5zcWxpdGUzX2luZGV4X29yZGVyYnkuc3RydWN0SW5mby5zaXplb2YgKiBuO1xuICAgICAgICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9vcmRlcmJ5KHB0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgX194V3JhcEZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgU3RydWN0VHlwZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocHRyLCByZW1vdmVNYXBwaW5nID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSBwdHIgPSBuZXcgU3RydWN0VHlwZSgpO1xuICAgICAgICAgICAgaWYgKHB0ciBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQocHRyLnBvaW50ZXIsIHB0cik7XG4gICAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3YXNtLmlzUHRyKHB0cikpIHtcbiAgICAgICAgICAgICAgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCB0bycsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSArICcoKScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmMgPSB0aGlzLmdldChwdHIpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZU1hcHBpbmcpIHRoaXMuZGVsZXRlKHB0cik7XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfS5iaW5kKG5ldyBNYXAoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgU3RydWN0UHRyTWFwcGVyID0gZnVuY3Rpb24gKG5hbWUsIFN0cnVjdFR5cGUpIHtcbiAgICAgICAgICBjb25zdCBfX3hXcmFwID0gX194V3JhcEZhY3RvcnkobmFtZSwgU3RydWN0VHlwZSk7XG5cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgICBTdHJ1Y3RUeXBlLFxuXG4gICAgICAgICAgICBjcmVhdGU6IChwcE91dCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByYyA9IF9feFdyYXAoKTtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlUHRyKHBwT3V0LCByYy5wb2ludGVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0OiAocENPYmopID0+IF9feFdyYXAocENPYmopLFxuXG4gICAgICAgICAgICB1bmdldDogKHBDT2JqKSA9PiBfX3hXcmFwKHBDT2JqLCB0cnVlKSxcblxuICAgICAgICAgICAgZGlzcG9zZTogKHBDT2JqKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG8gPSBfX3hXcmFwKHBDT2JqLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKG8pIG8uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2dGFiLnhWdGFiID0gU3RydWN0UHRyTWFwcGVyKCd4VnRhYicsIGNhcGkuc3FsaXRlM192dGFiKTtcblxuICAgICAgICB2dGFiLnhDdXJzb3IgPSBTdHJ1Y3RQdHJNYXBwZXIoJ3hDdXJzb3InLCBjYXBpLnNxbGl0ZTNfdnRhYl9jdXJzb3IpO1xuXG4gICAgICAgIHZ0YWIueEluZGV4SW5mbyA9IChwSWR4SW5mbykgPT4gbmV3IGNhcGkuc3FsaXRlM19pbmRleF9pbmZvKHBJZHhJbmZvKTtcblxuICAgICAgICB2dGFiLnhFcnJvciA9IGZ1bmN0aW9uIGYobWV0aG9kTmFtZSwgZXJyLCBkZWZhdWx0UmMpIHtcbiAgICAgICAgICBpZiAoZi5lcnJvclJlcG9ydGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGYuZXJyb3JSZXBvcnRlcihcbiAgICAgICAgICAgICAgICAnc3FsaXRlM19tb2R1bGU6OicgKyBtZXRob2ROYW1lICsgJygpOiAnICsgZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmM7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpIHJjID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHJjID0gZGVmYXVsdFJjO1xuICAgICAgICAgIGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIHNxbGl0ZTMuU1FMaXRlM0Vycm9yKSByYyA9IGVyci5yZXN1bHRDb2RlO1xuICAgICAgICAgIHJldHVybiByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgfTtcbiAgICAgICAgdnRhYi54RXJyb3IuZXJyb3JSZXBvcnRlciA9IDEgPyBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSkgOiBmYWxzZTtcblxuICAgICAgICB2dGFiLnhSb3dpZCA9IChwcFJvd2lkNjQsIHZhbHVlKSA9PiB3YXNtLnBva2UocHBSb3dpZDY0LCB2YWx1ZSwgJ2k2NCcpO1xuXG4gICAgICAgIHZ0YWIuc2V0dXBNb2R1bGUgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgbGV0IGNyZWF0ZWRNb2QgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBtb2QgPVxuICAgICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGNhcGkuc3FsaXRlM19tb2R1bGVcbiAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgIDogb3B0LnN0cnVjdCB8fCAoY3JlYXRlZE1vZCA9IG5ldyBjYXBpLnNxbGl0ZTNfbW9kdWxlKCkpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RzID0gb3B0Lm1ldGhvZHMgfHwgdG9zcyhcIk1pc3NpbmcgJ21ldGhvZHMnIG9iamVjdC5cIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgICB4Q29ubmVjdDogJ3hDcmVhdGUnLFxuICAgICAgICAgICAgICB4RGlzY29ubmVjdDogJ3hEZXN0cm95JyxcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSBlWzBdLFxuICAgICAgICAgICAgICAgIHYgPSBlWzFdO1xuICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gbWV0aG9kc1trXSkgbWV0aG9kc1trXSA9IG1ldGhvZHNbdl07XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRydWUgPT09IG1ldGhvZHNbdl0pIG1ldGhvZHNbdl0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jYXRjaEV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZndyYXAgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgZnVuYykge1xuICAgICAgICAgICAgICAgIGlmIChbJ3hDb25uZWN0JywgJ3hDcmVhdGUnXS5pbmRleE9mKG1ldGhvZE5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocERiLCBwQXV4LCBhcmdjLCBhcmd2LCBwcFZ0YWIsIHB6RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoLi4uYXJndW1lbnRzKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLmRlYWxsb2Mod2FzbS5wZWVrUHRyKHB6RXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIocHpFcnIsIHdhc20uYWxsb2NDU3RyaW5nKGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnRhYi54RXJyb3IobWV0aG9kTmFtZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3MpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnRhYi54RXJyb3IobWV0aG9kTmFtZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCBtbmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3hDcmVhdGUnLFxuICAgICAgICAgICAgICAgICd4Q29ubmVjdCcsXG4gICAgICAgICAgICAgICAgJ3hCZXN0SW5kZXgnLFxuICAgICAgICAgICAgICAgICd4RGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgJ3hEZXN0cm95JyxcbiAgICAgICAgICAgICAgICAneE9wZW4nLFxuICAgICAgICAgICAgICAgICd4Q2xvc2UnLFxuICAgICAgICAgICAgICAgICd4RmlsdGVyJyxcbiAgICAgICAgICAgICAgICAneE5leHQnLFxuICAgICAgICAgICAgICAgICd4RW9mJyxcbiAgICAgICAgICAgICAgICAneENvbHVtbicsXG4gICAgICAgICAgICAgICAgJ3hSb3dpZCcsXG4gICAgICAgICAgICAgICAgJ3hVcGRhdGUnLFxuICAgICAgICAgICAgICAgICd4QmVnaW4nLFxuICAgICAgICAgICAgICAgICd4U3luYycsXG4gICAgICAgICAgICAgICAgJ3hDb21taXQnLFxuICAgICAgICAgICAgICAgICd4Um9sbGJhY2snLFxuICAgICAgICAgICAgICAgICd4RmluZEZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAneFJlbmFtZScsXG4gICAgICAgICAgICAgICAgJ3hTYXZlcG9pbnQnLFxuICAgICAgICAgICAgICAgICd4UmVsZWFzZScsXG4gICAgICAgICAgICAgICAgJ3hSb2xsYmFja1RvJyxcbiAgICAgICAgICAgICAgICAneFNoYWRvd05hbWUnLFxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBjb25zdCByZW1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgbW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IG1ldGhvZHNba107XG4gICAgICAgICAgICAgICAgaWYgKCEobSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ3hDb25uZWN0JyA9PT0gayAmJiBtZXRob2RzLnhDcmVhdGUgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IG1ldGhvZHMueENyZWF0ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCd4Q3JlYXRlJyA9PT0gayAmJiBtZXRob2RzLnhDb25uZWN0ID09PSBtKSB7XG4gICAgICAgICAgICAgICAgICByZW1ldGhvZHNba10gPSBtZXRob2RzLnhDb25uZWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZW1ldGhvZHNba10gPSBmd3JhcChrLCBtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbW9kLmluc3RhbGxNZXRob2RzKHJlbWV0aG9kcywgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kLmluc3RhbGxNZXRob2RzKG1ldGhvZHMsICEhb3B0LmFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwID09PSBtb2QuJGlWZXJzaW9uKSB7XG4gICAgICAgICAgICAgIGxldCB2O1xuICAgICAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBvcHQuaVZlcnNpb24pIHYgPSBvcHQuaVZlcnNpb247XG4gICAgICAgICAgICAgIGVsc2UgaWYgKG1vZC4keFNoYWRvd05hbWUpIHYgPSAzO1xuICAgICAgICAgICAgICBlbHNlIGlmIChtb2QuJHhTYXZlUG9pbnQgfHwgbW9kLiR4UmVsZWFzZSB8fCBtb2QuJHhSb2xsYmFja1RvKVxuICAgICAgICAgICAgICAgIHYgPSAyO1xuICAgICAgICAgICAgICBlbHNlIHYgPSAxO1xuICAgICAgICAgICAgICBtb2QuJGlWZXJzaW9uID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZE1vZCkgY3JlYXRlZE1vZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhcGkuc3FsaXRlM19tb2R1bGUucHJvdG90eXBlLnNldHVwTW9kdWxlID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgIHJldHVybiB2dGFiLnNldHVwTW9kdWxlLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAoJ3VzZSBzdHJpY3QnKTtcbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICBjb25zdCBpbnN0YWxsT3Bmc1ZmcyA9IGZ1bmN0aW9uIGNhbGxlZShvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFnbG9iYWxUaGlzLlNoYXJlZEFycmF5QnVmZmVyIHx8ICFnbG9iYWxUaGlzLkF0b21pY3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdDYW5ub3QgaW5zdGFsbCBPUEZTOiBNaXNzaW5nIFNoYXJlZEFycmF5QnVmZmVyIGFuZC9vciBBdG9taWNzLiAnICtcbiAgICAgICAgICAgICAgICAgICdUaGUgc2VydmVyIG11c3QgZW1pdCB0aGUgQ09PUC9DT0VQIHJlc3BvbnNlIGhlYWRlcnMgdG8gZW5hYmxlIHRob3NlLiAnICtcbiAgICAgICAgICAgICAgICAgICdTZWUgaHR0cHM6Ly9zcWxpdGUub3JnL3dhc20vZG9jL3RydW5rL3BlcnNpc3RlbmNlLm1kI2Nvb3AtY29lcCcsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1RoZSBPUEZTIHNxbGl0ZTNfdmZzIGNhbm5vdCBydW4gaW4gdGhlIG1haW4gdGhyZWFkICcgK1xuICAgICAgICAgICAgICAgICAgJ2JlY2F1c2UgaXQgcmVxdWlyZXMgQXRvbWljcy53YWl0KCkuJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlIHx8XG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSB8fFxuICAgICAgICAgICAgIW5hdmlnYXRvcj8uc3RvcmFnZT8uZ2V0RGlyZWN0b3J5XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zO1xuICAgICAgICAgIGlmICh1cmxQYXJhbXMuaGFzKCdvcGZzLWRpc2FibGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzcWxpdGUzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnZlcmJvc2UgPSB1cmxQYXJhbXMuaGFzKCdvcGZzLXZlcmJvc2UnKVxuICAgICAgICAgICAgICA/ICt1cmxQYXJhbXMuZ2V0KCdvcGZzLXZlcmJvc2UnKSB8fCAyXG4gICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy5zYW5pdHlDaGVja3MpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2FuaXR5Q2hlY2tzID0gdXJsUGFyYW1zLmhhcygnb3Bmcy1zYW5pdHktY2hlY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy5wcm94eVVyaSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wcm94eVVyaSA9IGNhbGxlZS5kZWZhdWx0UHJveHlVcmk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zLnByb3h5VXJpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnByb3h5VXJpID0gb3B0aW9ucy5wcm94eVVyaSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0aGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKFxuICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVfLFxuICAgICAgICAgICAgcHJvbWlzZVJlamVjdF8sXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXJzID0gW1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcixcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybixcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcubG9nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0ltcGwgPSAobGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyYm9zZSA+IGxldmVsKVxuICAgICAgICAgICAgICAgIGxvZ2dlcnNbbGV2ZWxdKCdPUEZTIHN5bmNlcjonLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2cgPSAoLi4uYXJncykgPT4gbG9nSW1wbCgyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4gbG9nSW1wbCgxLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gKC4uLmFyZ3MpID0+IGxvZ0ltcGwoMCwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3M7XG4gICAgICAgICAgICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpO1xuICAgICAgICAgICAgY29uc3QgdXRpbCA9IHNxbGl0ZTMudXRpbDtcbiAgICAgICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG4gICAgICAgICAgICBjb25zdCBzcWxpdGUzX3ZmcyA9IGNhcGkuc3FsaXRlM192ZnM7XG4gICAgICAgICAgICBjb25zdCBzcWxpdGUzX2ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZTtcbiAgICAgICAgICAgIGNvbnN0IHNxbGl0ZTNfaW9fbWV0aG9kcyA9IGNhcGkuc3FsaXRlM19pb19tZXRob2RzO1xuXG4gICAgICAgICAgICBjb25zdCBvcGZzVXRpbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRoaXNUaHJlYWRIYXNPUEZTID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSAmJlxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSAmJlxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwubWV0cmljcyA9IHtcbiAgICAgICAgICAgICAgZHVtcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxldCBrLFxuICAgICAgICAgICAgICAgICAgbiA9IDAsXG4gICAgICAgICAgICAgICAgICB0ID0gMCxcbiAgICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoayBpbiBzdGF0ZS5vcElkcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IG1ldHJpY3Nba107XG4gICAgICAgICAgICAgICAgICBuICs9IG0uY291bnQ7XG4gICAgICAgICAgICAgICAgICB0ICs9IG0udGltZTtcbiAgICAgICAgICAgICAgICAgIHcgKz0gbS53YWl0O1xuICAgICAgICAgICAgICAgICAgbS5hdmdUaW1lID0gbS5jb3VudCAmJiBtLnRpbWUgPyBtLnRpbWUgLyBtLmNvdW50IDogMDtcbiAgICAgICAgICAgICAgICAgIG0uYXZnV2FpdCA9IG0uY291bnQgJiYgbS53YWl0ID8gbS53YWl0IC8gbS5jb3VudCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyhcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAgICdtZXRyaWNzIGZvcicsXG4gICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgICAnOicsXG4gICAgICAgICAgICAgICAgICBtZXRyaWNzLFxuICAgICAgICAgICAgICAgICAgJ1xcblRvdGFsIG9mJyxcbiAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAnb3AocykgZm9yJyxcbiAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAnbXMgKGluY2wuICcgKyB3ICsgJyBtcyBvZiB3YWl0aW5nIG9uIHRoZSBhc3luYyBzaWRlKScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2coJ1NlcmlhbGl6YXRpb24gbWV0cmljczonLCBtZXRyaWNzLnMxMW4pO1xuICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1tZXRyaWNzJyB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaztcbiAgICAgICAgICAgICAgICBjb25zdCByID0gKG0pID0+IChtLmNvdW50ID0gbS50aW1lID0gbS53YWl0ID0gMCk7XG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHN0YXRlLm9wSWRzKSB7XG4gICAgICAgICAgICAgICAgICByKChtZXRyaWNzW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcyA9IChtZXRyaWNzLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBzID0gcy5zZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHMgPSBtZXRyaWNzLnMxMW4uZGVzZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wZnNJb01ldGhvZHMgPSBuZXcgc3FsaXRlM19pb19tZXRob2RzKCk7XG4gICAgICAgICAgICBjb25zdCBvcGZzVmZzID0gbmV3IHNxbGl0ZTNfdmZzKCkuYWRkT25EaXNwb3NlKCgpID0+XG4gICAgICAgICAgICAgIG9wZnNJb01ldGhvZHMuZGlzcG9zZSgpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBwcm9taXNlV2FzUmVqZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlUmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICBwcm9taXNlV2FzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBvcGZzVmZzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RfKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVJlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHByb21pc2VXYXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVfKHNxbGl0ZTMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBuZXcgV29ya2VyKFxuICAgICAgICAgICAgICBuZXcgVVJMKCdzcWxpdGUzLW9wZnMtYXN5bmMtcHJveHkuanMnLCBpbXBvcnQubWV0YS51cmwpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBwcm9taXNlV2FzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KFxuICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnVGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBPUEZTIGFzeW5jIHByb3h5IHdvcmtlci4nLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA0MDAwKTtcbiAgICAgICAgICAgIFcuX29yaWdpbmFsT25FcnJvciA9IFcub25lcnJvcjtcbiAgICAgICAgICAgIFcub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBPUEZTIGFzeW5jZXI6JywgZXJyKTtcbiAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnTG9hZGluZyBPUEZTIGFzeW5jIFdvcmtlciBmYWlsZWQgZm9yIHVua25vd24gcmVhc29ucy4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcERWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkVmZzID0gcERWZnMgPyBuZXcgc3FsaXRlM192ZnMocERWZnMpIDogbnVsbDtcbiAgICAgICAgICAgIG9wZnNJb01ldGhvZHMuJGlWZXJzaW9uID0gMTtcbiAgICAgICAgICAgIG9wZnNWZnMuJGlWZXJzaW9uID0gMjtcbiAgICAgICAgICAgIG9wZnNWZnMuJHN6T3NGaWxlID0gY2FwaS5zcWxpdGUzX2ZpbGUuc3RydWN0SW5mby5zaXplb2Y7XG4gICAgICAgICAgICBvcGZzVmZzLiRteFBhdGhuYW1lID0gMTAyNDtcbiAgICAgICAgICAgIG9wZnNWZnMuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcoJ29wZnMnKTtcblxuICAgICAgICAgICAgb3Bmc1Zmcy4keERsT3BlbiA9XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhEbEVycm9yID1cbiAgICAgICAgICAgICAgb3Bmc1Zmcy4keERsU3ltID1cbiAgICAgICAgICAgICAgb3Bmc1Zmcy4keERsQ2xvc2UgPVxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBvcGZzVmZzLmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgJyR6TmFtZScsXG4gICAgICAgICAgICAgIG9wZnNWZnMuJHpOYW1lLFxuICAgICAgICAgICAgICAnY2xlYW51cCBkZWZhdWx0IFZGUyB3cmFwcGVyJyxcbiAgICAgICAgICAgICAgKCkgPT4gKGRWZnMgPyBkVmZzLmRpc3Bvc2UoKSA6IG51bGwpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgc3RhdGUudmVyYm9zZSA9IG9wdGlvbnMudmVyYm9zZTtcbiAgICAgICAgICAgIHN0YXRlLmxpdHRsZUVuZGlhbiA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTtcblxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKVswXSA9PT0gMjU2O1xuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgc3RhdGUuYXN5bmNJZGxlV2FpdFRpbWUgPSAxNTA7XG5cbiAgICAgICAgICAgIHN0YXRlLmFzeW5jUzExbkV4Y2VwdGlvbnMgPSAxO1xuXG4gICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSA9IDEwMjQgKiA2NDtcbiAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQgPSBzdGF0ZS5maWxlQnVmZmVyU2l6ZTtcblxuICAgICAgICAgICAgc3RhdGUuc2FiUzExblNpemUgPSBvcGZzVmZzLiRteFBhdGhuYW1lICogMjtcblxuICAgICAgICAgICAgc3RhdGUuc2FiSU8gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoXG4gICAgICAgICAgICAgIHN0YXRlLmZpbGVCdWZmZXJTaXplICsgc3RhdGUuc2FiUzExblNpemUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3RhdGUub3BJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy53aGljaE9wID0gaSsrO1xuXG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnJjID0gaSsrO1xuXG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhBY2Nlc3MgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhDbG9zZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueERlbGV0ZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueERlbGV0ZU5vV2FpdCA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueEZpbGVTaXplID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54TG9jayA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMueE9wZW4gPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhSZWFkID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54U2xlZXAgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhTeW5jID0gaSsrO1xuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy54VHJ1bmNhdGUgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhVbmxvY2sgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzLnhXcml0ZSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHMubWtkaXIgPSBpKys7XG4gICAgICAgICAgICAgIHN0YXRlLm9wSWRzWydvcGZzLWFzeW5jLW1ldHJpY3MnXSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUub3BJZHNbJ29wZnMtYXN5bmMtc2h1dGRvd24nXSA9IGkrKztcblxuICAgICAgICAgICAgICBzdGF0ZS5vcElkcy5yZXRyeSA9IGkrKztcbiAgICAgICAgICAgICAgc3RhdGUuc2FiT1AgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoaSAqIDQpO1xuICAgICAgICAgICAgICBvcGZzVXRpbC5tZXRyaWNzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLnNxM0NvZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ1NRTElURV9BQ0NFU1NfRVhJU1RTJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9BQ0NFU1NfUkVBRFdSSVRFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9CVVNZJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9DQU5UT1BFTicsXG4gICAgICAgICAgICAgICdTUUxJVEVfRVJST1InLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9BQ0NFU1MnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0NMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9ERUxFVEUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0lPRVJSX0ZTWU5DJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9TSE9SVF9SRUFEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9UUlVOQ0FURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfSU9FUlJfVU5MT0NLJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9JT0VSUl9XUklURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19FWENMVVNJVkUnLFxuICAgICAgICAgICAgICAnU1FMSVRFX0xPQ0tfTk9ORScsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS19QRU5ESU5HJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1JFU0VSVkVEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9MT0NLX1NIQVJFRCcsXG4gICAgICAgICAgICAgICdTUUxJVEVfTE9DS0VEJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9NSVNVU0UnLFxuICAgICAgICAgICAgICAnU1FMSVRFX05PVEZPVU5EJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX0NSRUFURScsXG4gICAgICAgICAgICAgICdTUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFJyxcbiAgICAgICAgICAgICAgJ1NRTElURV9PUEVOX01BSU5fREInLFxuICAgICAgICAgICAgICAnU1FMSVRFX09QRU5fUkVBRE9OTFknLFxuICAgICAgICAgICAgXS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IChzdGF0ZS5zcTNDb2Rlc1trXSA9IGNhcGlba10pKSB7XG4gICAgICAgICAgICAgICAgdG9zcygnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG5vdCBmb3VuZDonLCBrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5vcGZzRmxhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgT1BGU19VTkxPQ0tfQVNBUDogMHgwMSxcblxuICAgICAgICAgICAgICBPUEZTX1VOTElOS19CRUZPUkVfT1BFTjogMHgwMixcblxuICAgICAgICAgICAgICBkZWZhdWx0VW5sb2NrQXNhcDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgb3BSdW4gPSAob3AsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3BOZHggPSBzdGF0ZS5vcElkc1tvcF0gfHwgdG9zcygnSW52YWxpZCBvcCBJRDonLCBvcCk7XG4gICAgICAgICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKTtcbiAgICAgICAgICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3AsIG9wTmR4KTtcbiAgICAgICAgICAgICAgQXRvbWljcy5ub3RpZnkoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wKTtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgJ25vdC1lcXVhbCcgIT09XG4gICAgICAgICAgICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKVxuICAgICAgICAgICAgICApIHt9XG5cbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBBdG9taWNzLmxvYWQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYyk7XG4gICAgICAgICAgICAgIG1ldHJpY3Nbb3BdLndhaXQgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICAgICAgICBpZiAocmMgJiYgc3RhdGUuYXN5bmNTMTFuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHN0YXRlLnMxMW4uZGVzZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBlcnJvcihvcCArICcoKSBhc3luYyBlcnJvcjonLCAuLi5lcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLmRlYnVnID0ge1xuICAgICAgICAgICAgICBhc3luY1NodXRkb3duOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICdTaHV0dGluZyBkb3duIE9QRlMgYXN5bmMgbGlzdGVuZXIuIFRoZSBPUEZTIFZGUyB3aWxsIG5vIGxvbmdlciB3b3JrLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvcFJ1bignb3Bmcy1hc3luYy1zaHV0ZG93bicpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhc3luY1Jlc3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ0F0dGVtcHRpbmcgdG8gcmVzdGFydCBPUEZTIFZGUyBhc3luYyBsaXN0ZW5lci4gTWlnaHQgd29yaywgbWlnaHQgbm90LicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBXLnBvc3RNZXNzYWdlKHsgdHlwZTogJ29wZnMtYXN5bmMtcmVzdGFydCcgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBpbml0UzExbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLnMxMW4pIHJldHVybiBzdGF0ZS5zMTFuO1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLFxuICAgICAgICAgICAgICAgIHZpZXdVOCA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblNpemUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB2aWV3RFYgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuU2l6ZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdGF0ZS5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICBjb25zdCBUeXBlSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgVHlwZUlkcy5udW1iZXIgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgc2l6ZTogOCxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6ICdnZXRGbG9hdDY0JyxcbiAgICAgICAgICAgICAgICBzZXR0ZXI6ICdzZXRGbG9hdDY0JyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHlwZUlkcy5iaWdpbnQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICAgICAgc2l6ZTogOCxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6ICdnZXRCaWdJbnQ2NCcsXG4gICAgICAgICAgICAgICAgc2V0dGVyOiAnc2V0QmlnSW50NjQnLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUeXBlSWRzLmJvb2xlYW4gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDMsXG4gICAgICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgICAgICBnZXR0ZXI6ICdnZXRJbnQzMicsXG4gICAgICAgICAgICAgICAgc2V0dGVyOiAnc2V0SW50MzInLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUeXBlSWRzLnN0cmluZyA9IHsgaWQ6IDQgfTtcblxuICAgICAgICAgICAgICBjb25zdCBnZXRUeXBlSWQgPSAodikgPT5cbiAgICAgICAgICAgICAgICBUeXBlSWRzW3R5cGVvZiB2XSB8fFxuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IHRoaXMgdmFsdWUgdHlwZSBjYW5ub3QgYmUgc2VyaWFsaXplZC4nLFxuICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBnZXRUeXBlSWRCeUlkID0gKHRpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGlkKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFR5cGVJZHMubnVtYmVyLmlkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUlkcy5udW1iZXI7XG4gICAgICAgICAgICAgICAgICBjYXNlIFR5cGVJZHMuYmlnaW50LmlkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUlkcy5iaWdpbnQ7XG4gICAgICAgICAgICAgICAgICBjYXNlIFR5cGVJZHMuYm9vbGVhbi5pZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVJZHMuYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5zdHJpbmcuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlSWRzLnN0cmluZztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdHlwZSBJRDonLCB0aWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGNsZWFyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICArK21ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS5jb3VudDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnYyA9IHZpZXdVOFswXTtcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IGFyZ2MgPyBbXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ2MpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAxLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICB2O1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7ICsraSwgKytvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZEJ5SWQodmlld1U4W29mZnNldF0pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHR5cGVJZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIHYgPSB2aWV3RFZbdC5nZXR0ZXJdKG9mZnNldCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG4gPSB2aWV3RFYuZ2V0SW50MzIob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIHYgPSB0ZXh0RGVjb2Rlci5kZWNvZGUodmlld1U4LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikpO1xuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJjLnB1c2godik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhcikgdmlld1U4WzBdID0gMDtcblxuICAgICAgICAgICAgICAgIG1ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS50aW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc3RhdGUuczExbi5zZXJpYWxpemUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICArK21ldHJpY3MuczExbi5zZXJpYWxpemUuY291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0eXBlSWRzID0gW107XG4gICAgICAgICAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgICB2aWV3VThbMF0gPSBhcmdzLmxlbmd0aCAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyArK2ksICsrb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWQoYXJnc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3VThbb2Zmc2V0XSA9IHR5cGVJZHNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdHlwZUlkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmlld0RWW3Quc2V0dGVyXShvZmZzZXQsIGFyZ3NbaV0sIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHQuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gdGV4dEVuY29kZXIuZW5jb2RlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgIHZpZXdEVi5zZXRJbnQzMihvZmZzZXQsIHMuYnl0ZUxlbmd0aCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3VTguc2V0KHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2aWV3VThbMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRyaWNzLnMxMW4uc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuczExbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUZpbGVuYW1lID0gZnVuY3Rpb24gZihsZW4gPSAxNikge1xuICAgICAgICAgICAgICBpZiAoIWYuX2NoYXJzKSB7XG4gICAgICAgICAgICAgICAgZi5fY2hhcnMgPVxuICAgICAgICAgICAgICAgICAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArXG4gICAgICAgICAgICAgICAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICtcbiAgICAgICAgICAgICAgICAgICcwMTIzNDY3ODknO1xuICAgICAgICAgICAgICAgIGYuX24gPSBmLl9jaGFycy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZHggPSAoTWF0aC5yYW5kb20oKSAqIChmLl9uICogNjQpKSAlIGYuX24gfCAwO1xuICAgICAgICAgICAgICAgIGFbaV0gPSBmLl9jaGFyc1tuZHhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhLmpvaW4oJycpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgX19vcGVuRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCBvcFRpbWVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIG9wVGltZXIub3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvcFRpbWVyLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgbVRpbWVTdGFydCA9IChvcCkgPT4ge1xuICAgICAgICAgICAgICBvcFRpbWVyLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIG9wVGltZXIub3AgPSBvcDtcbiAgICAgICAgICAgICAgKyttZXRyaWNzW29wXS5jb3VudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtVGltZUVuZCA9ICgpID0+XG4gICAgICAgICAgICAgIChtZXRyaWNzW29wVGltZXIub3BdLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBvcFRpbWVyLnN0YXJ0KTtcblxuICAgICAgICAgICAgY29uc3QgaW9TeW5jV3JhcHBlcnMgPSB7XG4gICAgICAgICAgICAgIHhDaGVja1Jlc2VydmVkTG9jazogZnVuY3Rpb24gKHBGaWxlLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIDAsICdpMzInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeENsb3NlOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4Q2xvc2UnKTtcbiAgICAgICAgICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4Q2xvc2UnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZi5zcTNGaWxlKSBmLnNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeERldmljZUNoYXJhY3RlcmlzdGljczogZnVuY3Rpb24gKHBGaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeEZpbGVDb250cm9sOiBmdW5jdGlvbiAocEZpbGUsIG9wSWQsIHBBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGaWxlU2l6ZTogZnVuY3Rpb24gKHBGaWxlLCBwU3o2NCkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hGaWxlU2l6ZScpO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IG9wUnVuKCd4RmlsZVNpemUnLCBwRmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gcmMpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN6ID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpWzBdO1xuICAgICAgICAgICAgICAgICAgICB3YXNtLnBva2UocFN6NjQsIHN6LCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHJlYWRpbmcgeEZpbGVTaXplKCkgcmVzdWx0OicsIGUpO1xuICAgICAgICAgICAgICAgICAgICByYyA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhMb2NrOiBmdW5jdGlvbiAocEZpbGUsIGxvY2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneExvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWYubG9ja1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHJjID0gb3BSdW4oJ3hMb2NrJywgcEZpbGUsIGxvY2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4UmVhZDogZnVuY3Rpb24gKHBGaWxlLCBwRGVzdCwgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgICAgICAgbGV0IHJjO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4UmVhZCcsIHBGaWxlLCBuLCBOdW1iZXIob2Zmc2V0NjQpKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByYyB8fCBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEID09PSByYykge1xuICAgICAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnNldChmLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHBEZXN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcigneFJlYWQoJywgYXJndW1lbnRzLCAnKSBmYWlsZWQ6JywgZSwgZik7XG4gICAgICAgICAgICAgICAgICByYyA9IGNhcGkuU1FMSVRFX0lPRVJSX1JFQUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4U3luYzogZnVuY3Rpb24gKHBGaWxlLCBmbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hTeW5jJyk7XG4gICAgICAgICAgICAgICAgKyttZXRyaWNzLnhTeW5jLmNvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hTeW5jJywgcEZpbGUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFRydW5jYXRlOiBmdW5jdGlvbiAocEZpbGUsIHN6NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4VHJ1bmNhdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4VHJ1bmNhdGUnLCBwRmlsZSwgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeFVubG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hVbmxvY2snKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGNhcGkuU1FMSVRFX0xPQ0tfTk9ORSA9PT0gbG9ja1R5cGUgJiYgZi5sb2NrVHlwZSkge1xuICAgICAgICAgICAgICAgICAgcmMgPSBvcFJ1bigneFVubG9jaycsIHBGaWxlLCBsb2NrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgwID09PSByYykgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4V3JpdGU6IGZ1bmN0aW9uIChwRmlsZSwgcFNyYywgbiwgb2Zmc2V0NjQpIHtcbiAgICAgICAgICAgICAgICBtVGltZVN0YXJ0KCd4V3JpdGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZi5zYWJWaWV3LnNldCh3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBTcmMsIHBTcmMgKyBuKSk7XG4gICAgICAgICAgICAgICAgICByYyA9IG9wUnVuKCd4V3JpdGUnLCBwRmlsZSwgbiwgTnVtYmVyKG9mZnNldDY0KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ3hXcml0ZSgnLCBhcmd1bWVudHMsICcpIGZhaWxlZDonLCBlLCBmKTtcbiAgICAgICAgICAgICAgICAgIHJjID0gY2FwaS5TUUxJVEVfSU9FUlJfV1JJVEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdmZzU3luY1dyYXBwZXJzID0ge1xuICAgICAgICAgICAgICB4QWNjZXNzOiBmdW5jdGlvbiAocFZmcywgek5hbWUsIGZsYWdzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneEFjY2VzcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hBY2Nlc3MnLCB3YXNtLmNzdHJUb0pzKHpOYW1lKSk7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXQsIHJjID8gMCA6IDEsICdpMzInKTtcbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWU6IGZ1bmN0aW9uIChwVmZzLCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5wb2tlKFxuICAgICAgICAgICAgICAgICAgcE91dCxcbiAgICAgICAgICAgICAgICAgIDI0NDA1ODcuNSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gODY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAnZG91YmxlJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICB3YXNtLnBva2UoXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICAgMjQ0MDU4Ny41ICogODY0MDAwMDAgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICdpNjQnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhEZWxldGU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKSB7XG4gICAgICAgICAgICAgICAgbVRpbWVTdGFydCgneERlbGV0ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oXG4gICAgICAgICAgICAgICAgICAneERlbGV0ZScsXG4gICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHpOYW1lKSxcbiAgICAgICAgICAgICAgICAgIGRvU3luY0RpcixcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhGdWxsUGF0aG5hbWU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgICAgd2FybignT1BGUyB4R2V0TGFzdEVycm9yKCkgaGFzIG5vdGhpbmcgc2Vuc2libGUgdG8gcmV0dXJuLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIHhPcGVuOiBmdW5jdGlvbiBmKHBWZnMsIHpOYW1lLCBwRmlsZSwgZmxhZ3MsIHBPdXRGbGFncykge1xuICAgICAgICAgICAgICAgIG1UaW1lU3RhcnQoJ3hPcGVuJyk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZnNGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHpOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB6TmFtZSA9IHJhbmRvbUZpbGVuYW1lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YXNtLmlzUHRyKHpOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhcGkuc3FsaXRlM191cmlfYm9vbGVhbih6TmFtZSwgJ29wZnMtdW5sb2NrLWFzYXAnLCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBvcGZzRmxhZ3MgfD0gc3RhdGUub3Bmc0ZsYWdzLk9QRlNfVU5MT0NLX0FTQVA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM191cmlfYm9vbGVhbih6TmFtZSwgJ2RlbGV0ZS1iZWZvcmUtb3BlbicsIDApXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgb3Bmc0ZsYWdzIHw9IHN0YXRlLm9wZnNGbGFncy5PUEZTX1VOTElOS19CRUZPUkVfT1BFTjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHpOYW1lID0gd2FzbS5jc3RyVG9Kcyh6TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmaC5maWQgPSBwRmlsZTtcbiAgICAgICAgICAgICAgICBmaC5maWxlbmFtZSA9IHpOYW1lO1xuICAgICAgICAgICAgICAgIGZoLnNhYiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihzdGF0ZS5maWxlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgZmguZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICAgICAgICBmaC5yZWFkT25seSA9XG4gICAgICAgICAgICAgICAgICAhKHNxbGl0ZTMuU1FMSVRFX09QRU5fQ1JFQVRFICYgZmxhZ3MpICYmXG4gICAgICAgICAgICAgICAgICAhIShmbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hPcGVuJywgcEZpbGUsIHpOYW1lLCBmbGFncywgb3Bmc0ZsYWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJjKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmgucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXRGbGFncywgY2FwaS5TUUxJVEVfT1BFTl9SRUFET05MWSwgJ2kzMicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX19vcGVuRmlsZXNbcEZpbGVdID0gZmg7XG4gICAgICAgICAgICAgICAgICBmaC5zYWJWaWV3ID0gc3RhdGUuc2FiRmlsZUJ1ZlZpZXc7XG4gICAgICAgICAgICAgICAgICBmaC5zcTNGaWxlID0gbmV3IHNxbGl0ZTNfZmlsZShwRmlsZSk7XG4gICAgICAgICAgICAgICAgICBmaC5zcTNGaWxlLiRwTWV0aG9kcyA9IG9wZnNJb01ldGhvZHMucG9pbnRlcjtcbiAgICAgICAgICAgICAgICAgIGZoLmxvY2tUeXBlID0gY2FwaS5TUUxJVEVfTE9DS19OT05FO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChkVmZzKSB7XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhSYW5kb21uZXNzID0gZFZmcy4keFJhbmRvbW5lc3M7XG4gICAgICAgICAgICAgIG9wZnNWZnMuJHhTbGVlcCA9IGRWZnMuJHhTbGVlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3Bmc1Zmcy4keFJhbmRvbW5lc3MpIHtcbiAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhSYW5kb21uZXNzID0gZnVuY3Rpb24gKHBWZnMsIG5PdXQsIHBPdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBuT3V0OyArK2kpXG4gICAgICAgICAgICAgICAgICBoZWFwW3BPdXQgKyBpXSA9IChNYXRoLnJhbmRvbSgpICogMjU1MDAwKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZnNWZnMuJHhTbGVlcCkge1xuICAgICAgICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueFNsZWVwID0gZnVuY3Rpb24gKHBWZnMsIG1zKSB7XG4gICAgICAgICAgICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMueFNsZWVwLCAwLCBtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLmdldFJlc29sdmVkUGF0aCA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgc3BsaXRJdCkge1xuICAgICAgICAgICAgICBjb25zdCBwID0gbmV3IFVSTChmaWxlbmFtZSwgJ2ZpbGU6Ly9pcnJlbGV2YW50JykucGF0aG5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBzcGxpdEl0ID8gcC5zcGxpdCgnLycpLmZpbHRlcigodikgPT4gISF2KSA6IHA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZSA9IGFzeW5jIGZ1bmN0aW9uIGYoXG4gICAgICAgICAgICAgIGFic0ZpbGVuYW1lLFxuICAgICAgICAgICAgICBjcmVhdGVEaXJzID0gZmFsc2UsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IG9wZnNVdGlsLmdldFJlc29sdmVkUGF0aChhYnNGaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgbGV0IGRoID0gb3Bmc1V0aWwucm9vdERpcmVjdG9yeTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkaXJOYW1lIG9mIHBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgZGggPSBhd2FpdCBkaC5nZXREaXJlY3RvcnlIYW5kbGUoZGlyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGU6ICEhY3JlYXRlRGlycyxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gW2RoLCBmaWxlbmFtZV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5ta2RpciA9IGFzeW5jIGZ1bmN0aW9uIChhYnNEaXJOYW1lKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoXG4gICAgICAgICAgICAgICAgICBhYnNEaXJOYW1lICsgJy9maWxlcGFydCcsXG4gICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLmVudHJ5RXhpc3RzID0gYXN5bmMgZnVuY3Rpb24gKGZzRW50cnlOYW1lKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2RoLCBmbl0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShmc0VudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnJhbmRvbUZpbGVuYW1lID0gcmFuZG9tRmlsZW5hbWU7XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnRyZWVMaXN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zdCBkb0RpciA9IGFzeW5jIGZ1bmN0aW9uIGNhbGxlZShkaXJIYW5kbGUsIHRndCkge1xuICAgICAgICAgICAgICAgIHRndC5uYW1lID0gZGlySGFuZGxlLm5hbWU7XG4gICAgICAgICAgICAgICAgdGd0LmRpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0Z3QuZmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgnZGlyZWN0b3J5JyA9PT0gaGFuZGxlLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViRGlyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmRpcnMucHVzaChzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsZWUoaGFuZGxlLCBzdWJEaXIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGd0LmZpbGVzLnB1c2goaGFuZGxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgIGF3YWl0IGRvRGlyKG9wZnNVdGlsLnJvb3REaXJlY3RvcnksIHJvb3QpO1xuICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wZnNVdGlsLnJtZnIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpciA9IG9wZnNVdGlsLnJvb3REaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgb3B0ID0geyByZWN1cnNlOiB0cnVlIH07XG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGRpci5yZW1vdmVFbnRyeShoYW5kbGUubmFtZSwgb3B0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudW5saW5rID0gYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICBmc0VudHJ5TmFtZSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlID0gZmFsc2UsXG4gICAgICAgICAgICAgIHRocm93T25FcnJvciA9IGZhbHNlLFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZpbGVuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICAgIGZzRW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KGZpbGVuYW1lUGFydCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICd1bmxpbmsoJyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAnKSBmYWlsZWQ6ICcgKyBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3Bmc1V0aWwudHJhdmVyc2UgPSBhc3luYyBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHQgPSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogb3Bmc1V0aWwucm9vdERpcmVjdG9yeSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHQpIHtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IGNhbGxiYWNrOiBvcHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHQsIG9wdCB8fCB7fSk7XG4gICAgICAgICAgICAgIGNvbnN0IGRvRGlyID0gYXN5bmMgZnVuY3Rpb24gY2FsbGVlKGRpckhhbmRsZSwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gb3B0LmNhbGxiYWNrKGhhbmRsZSwgZGlySGFuZGxlLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdC5yZWN1cnNpdmUgJiYgJ2RpcmVjdG9yeScgPT09IGhhbmRsZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gKGF3YWl0IGNhbGxlZShoYW5kbGUsIGRlcHRoICsgMSkpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRvRGlyKG9wdC5kaXJlY3RvcnksIDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgaW1wb3J0RGJDaHVua2VkID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjb25zdCBbaERpciwgZm5hbWVQYXJ0XSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxldCBzYWggPSBhd2FpdCBoRmlsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgICAgIGxldCBuV3JvdGUgPSAwLFxuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBuV3JvdGUgJiYgY2h1bmsuYnl0ZUxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHsgYXQ6IG5Xcm90ZSB9KTtcbiAgICAgICAgICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobldyb3RlIDwgNTEyIHx8IDAgIT09IG5Xcm90ZSAlIDUxMikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0lucHV0IHNpemUnLFxuICAgICAgICAgICAgICAgICAgICBuV3JvdGUsXG4gICAgICAgICAgICAgICAgICAgICdpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLicsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgICAgICAgICAgIHNhaC5yZWFkKGhlYWRlciwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBzYWggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcGZzVXRpbC5pbXBvcnREYiA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RGJDaHVua2VkKGZpbGVuYW1lLCBieXRlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgICB1dGlsLmFmZmlybUlzRGIoYnl0ZXMpO1xuICAgICAgICAgICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgW2hEaXIsIGZuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgc2FoLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBuV3JvdGUgPSAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNhaCA9IGF3YWl0IGhGaWxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgICAgICAgICAgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7IGF0OiAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChuV3JvdGUgIT0gbikge1xuICAgICAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIHRvIHdyaXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG4gK1xuICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMgYnV0IHdyb3RlICcgK1xuICAgICAgICAgICAgICAgICAgICAgIG5Xcm90ZSArXG4gICAgICAgICAgICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHsgYXQ6IDE4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FoKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHNhaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmbmFtZVBhcnQpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChzYWgpIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc3FsaXRlMy5vbzEpIHtcbiAgICAgICAgICAgICAgY29uc3QgT3Bmc0RiID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBvcHQudmZzID0gb3Bmc1Zmcy4kek5hbWU7XG4gICAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT3Bmc0RiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3FsaXRlMy5vbzEuREIucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuT3Bmc0RiID0gT3Bmc0RiO1xuICAgICAgICAgICAgICBPcGZzRGIuaW1wb3J0RGIgPSBvcGZzVXRpbC5pbXBvcnREYjtcbiAgICAgICAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgb3Bmc1Zmcy5wb2ludGVyLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvbzFEYiwgc3FsaXRlMykge1xuICAgICAgICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfYnVzeV90aW1lb3V0KG9vMURiLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUoKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWQgPSBzcTNGaWxlLnBvaW50ZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlbkZsYWdzID1cbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFIHxcbiAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQjtcbiAgICAgICAgICAgICAgICBjb25zdCBwT3V0ID0gd2FzbS5zY29wZWRBbGxvYyg4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYkZpbGUgPSAnL3Nhbml0eS9jaGVjay9maWxlJyArIHJhbmRvbUZpbGVuYW1lKDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpEYkZpbGUgPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhkYkZpbGUpO1xuICAgICAgICAgICAgICAgIGxldCByYztcbiAgICAgICAgICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSgnVGhpcyBpcyDDpCBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgcmMgPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgbG9nKCdkZXNlcmlhbGl6ZSgpIHNheXM6JywgcmMpO1xuICAgICAgICAgICAgICAgIGlmICgnVGhpcyBpcyDDpCBzdHJpbmcuJyAhPT0gcmNbMF0pIHRvc3MoJ1N0cmluZyBkMTNuIGVycm9yLicpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGxvZygneEFjY2VzcygnLCBkYkZpbGUsICcpIGV4aXN0cyA/PScsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IHZmc1N5bmNXcmFwcGVycy54T3BlbihcbiAgICAgICAgICAgICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIHpEYkZpbGUsXG4gICAgICAgICAgICAgICAgICBmaWQsXG4gICAgICAgICAgICAgICAgICBvcGVuRmxhZ3MsXG4gICAgICAgICAgICAgICAgICBwT3V0LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgJ29wZW4gcmMgPScsXG4gICAgICAgICAgICAgICAgICByYyxcbiAgICAgICAgICAgICAgICAgICdzdGF0ZS5zYWJPUFZpZXdbeE9wZW5dID0nLFxuICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3W3N0YXRlLm9wSWRzLnhPcGVuXSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSByYykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ29wZW4gZmFpbGVkIHdpdGggY29kZScsIHJjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCAnaTMyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYykgdG9zcygneEFjY2VzcygpIGZhaWxlZCB0byBkZXRlY3QgZmlsZS4nKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhTeW5jKHNxM0ZpbGUucG9pbnRlciwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJjKSB0b3NzKCdzeW5jIGZhaWxlZCB3LyByYycsIHJjKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhUcnVuY2F0ZShzcTNGaWxlLnBvaW50ZXIsIDEwMjQpO1xuICAgICAgICAgICAgICAgIGlmIChyYykgdG9zcygndHJ1bmNhdGUgZmFpbGVkIHcvIHJjJywgcmMpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCAwLCAnaTY0Jyk7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54RmlsZVNpemUoc3EzRmlsZS5wb2ludGVyLCBwT3V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hGaWxlU2l6ZSBmYWlsZWQgdy8gcmMnLCByYyk7XG4gICAgICAgICAgICAgICAgbG9nKCd4RmlsZVNpemUgc2F5czonLCB3YXNtLnBlZWsocE91dCwgJ2k2NCcpKTtcbiAgICAgICAgICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhXcml0ZShzcTNGaWxlLnBvaW50ZXIsIHpEYkZpbGUsIDEwLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmMpIHRvc3MoJ3hXcml0ZSgpIGZhaWxlZCEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkQnVmID0gd2FzbS5zY29wZWRBbGxvYygxNik7XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54UmVhZChzcTNGaWxlLnBvaW50ZXIsIHJlYWRCdWYsIDYsIDIpO1xuICAgICAgICAgICAgICAgIHdhc20ucG9rZShyZWFkQnVmICsgNiwgMCk7XG4gICAgICAgICAgICAgICAgbGV0IGpSZWFkID0gd2FzbS5jc3RyVG9KcyhyZWFkQnVmKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hSZWFkKCkgZ290OicsIGpSZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3Nhbml0eScgIT09IGpSZWFkKSB0b3NzKCdVbmV4cGVjdGVkIHhSZWFkKCkgdmFsdWUuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZmc1N5bmNXcmFwcGVycy54U2xlZXApIHtcbiAgICAgICAgICAgICAgICAgIGxvZygneFNsZWVwKClpbmcgYmVmb3JlIGNsb3NlKClpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54U2xlZXAob3Bmc1Zmcy5wb2ludGVyLCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgIGxvZygnd2FraW5nIHVwIGZyb20geFNsZWVwKCknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54Q2xvc2UoZmlkKTtcbiAgICAgICAgICAgICAgICBsb2coJ3hDbG9zZSByYyA9JywgcmMsICdzYWJPUFZpZXcgPScsIHN0YXRlLnNhYk9QVmlldyk7XG4gICAgICAgICAgICAgICAgbG9nKCdEZWxldGluZyBmaWxlOicsIGRiRmlsZSk7XG4gICAgICAgICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhEZWxldGUob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAweDEyMzQpO1xuICAgICAgICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgICAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwgJ2kzMicpO1xuICAgICAgICAgICAgICAgIGlmIChyYylcbiAgICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAgICdFeHBlY3RpbmcgMCBmcm9tIHhBY2Nlc3MoJyxcbiAgICAgICAgICAgICAgICAgICAgZGJGaWxlLFxuICAgICAgICAgICAgICAgICAgICAnKSBhZnRlciB4RGVsZXRlKCkuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgd2FybignRW5kIG9mIE9QRlMgc2FuaXR5IGNoZWNrcy4nKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgVy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoeyBkYXRhIH0pIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLXVuYXZhaWxhYmxlJzpcbiAgICAgICAgICAgICAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKGRhdGEucGF5bG9hZC5qb2luKCcgJykpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtbG9hZGVkJzpcbiAgICAgICAgICAgICAgICAgIFcucG9zdE1lc3NhZ2UoeyB0eXBlOiAnb3Bmcy1hc3luYy1pbml0JywgYXJnczogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLWluaXRlZCc6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0cnVlID09PSBwcm9taXNlV2FzUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgICAgICAgICAgICAgICAgICBpbzogeyBzdHJ1Y3Q6IG9wZnNJb01ldGhvZHMsIG1ldGhvZHM6IGlvU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgdmZzOiB7IHN0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzU3luY1dyYXBwZXJzIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXcgPSBuZXcgSW50MzJBcnJheShzdGF0ZS5zYWJPUCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYkZpbGVCdWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiSU8sXG4gICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJJTyxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5TaXplLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpbml0UzExbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zYW5pdHlDaGVja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1J1bm5pbmcgc2FuaXR5IGNoZWNrcyBiZWNhdXNlIG9mIG9wZnMtc2FuaXR5LWNoZWNrIFVSTCBhcmcuLi4nLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgc2FuaXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1RocmVhZEhhc09QRlMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RGlyZWN0b3J5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFcub25lcnJvciA9IFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3FsaXRlMy5vcGZzID0gb3Bmc1V0aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wZnNVdGlsLnJvb3REaXJlY3RvcnkgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0VuZCBvZiBPUEZTIHNxbGl0ZTNfdmZzIHNldHVwLicsIG9wZnNWZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChwcm9taXNlUmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIG1lc3NhZ2UgZnJvbSB0aGUgT1BGUyBhc3luYyB3b3JrZXI6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhlUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID0gJ3NxbGl0ZTMtb3Bmcy1hc3luYy1wcm94eS5qcyc7XG4gICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYy5wdXNoKFxuICAgICAgICAgIGFzeW5jIChzcWxpdGUzKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgcHJveHlKcyA9IGluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaTtcbiAgICAgICAgICAgICAgaWYgKHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID1cbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyICsgcHJveHlKcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFsbE9wZnNWZnMoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgICAgICAgICAgICAnSWdub3JpbmcgaW5hYmlsaXR5IHRvIGluc3RhbGwgT1BGUyBzcWxpdGUzX3ZmczonLFxuICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcignaW5zdGFsbE9wZnNWZnMoKSBleGNlcHRpb246JywgZSk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoc3FsaXRlMykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGNvbnN0IHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zcztcbiAgICAgICAgY29uc3QgdG9zczMgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gICAgICAgIGNvbnN0IGluaXRQcm9taXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGk7XG4gICAgICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG5cbiAgICAgICAgY29uc3QgU0VDVE9SX1NJWkUgPSA0MDk2O1xuICAgICAgICBjb25zdCBIRUFERVJfTUFYX1BBVEhfU0laRSA9IDUxMjtcbiAgICAgICAgY29uc3QgSEVBREVSX0ZMQUdTX1NJWkUgPSA0O1xuICAgICAgICBjb25zdCBIRUFERVJfRElHRVNUX1NJWkUgPSA4O1xuICAgICAgICBjb25zdCBIRUFERVJfQ09SUFVTX1NJWkUgPSBIRUFERVJfTUFYX1BBVEhfU0laRSArIEhFQURFUl9GTEFHU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0ZMQUdTID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgICAgIGNvbnN0IEhFQURFUl9PRkZTRVRfRElHRVNUID0gSEVBREVSX0NPUlBVU19TSVpFO1xuICAgICAgICBjb25zdCBIRUFERVJfT0ZGU0VUX0RBVEEgPSBTRUNUT1JfU0laRTtcblxuICAgICAgICBjb25zdCBQRVJTSVNURU5UX0ZJTEVfVFlQRVMgPVxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQiB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwgfFxuICAgICAgICAgIGNhcGkuU1FMSVRFX09QRU5fU1VQRVJfSk9VUk5BTCB8XG4gICAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9XQUw7XG4gICAgICAgIGNvbnN0IEZMQUdfQ09NUFVURV9ESUdFU1RfVjIgPSBjYXBpLlNRTElURV9PUEVOX01FTU9SWTtcbiAgICAgICAgY29uc3QgT1BBUVVFX0RJUl9OQU1FID0gJy5vcGFxdWUnO1xuXG4gICAgICAgIGNvbnN0IGdldFJhbmRvbU5hbWUgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbkRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICAgICAgbmFtZTogJ29wZnMtc2FocG9vbCcsXG4gICAgICAgICAgZGlyZWN0b3J5OiB1bmRlZmluZWQsXG4gICAgICAgICAgaW5pdGlhbENhcGFjaXR5OiA2LFxuICAgICAgICAgIGNsZWFyT25Jbml0OiBmYWxzZSxcblxuICAgICAgICAgIHZlcmJvc2l0eTogMixcbiAgICAgICAgICBmb3JjZVJlaW5pdElmUHJldmlvdXNseUZhaWxlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGxvZ2dlcnMgPSBbXG4gICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IsXG4gICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybixcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2csXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxvZyA9IHNxbGl0ZTMuY29uZmlnLmxvZztcbiAgICAgICAgY29uc3Qgd2FybiA9IHNxbGl0ZTMuY29uZmlnLndhcm47XG4gICAgICAgIGNvbnN0IGVycm9yID0gc3FsaXRlMy5jb25maWcuZXJyb3I7XG5cbiAgICAgICAgY29uc3QgX19tYXBWZnNUb1Bvb2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGdldFBvb2xGb3JWZnMgPSAocFZmcykgPT4gX19tYXBWZnNUb1Bvb2wuZ2V0KHBWZnMpO1xuICAgICAgICBjb25zdCBzZXRQb29sRm9yVmZzID0gKHBWZnMsIHBvb2wpID0+IHtcbiAgICAgICAgICBpZiAocG9vbCkgX19tYXBWZnNUb1Bvb2wuc2V0KHBWZnMsIHBvb2wpO1xuICAgICAgICAgIGVsc2UgX19tYXBWZnNUb1Bvb2wuZGVsZXRlKHBWZnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9fbWFwU3FsaXRlM0ZpbGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGdldFBvb2xGb3JQRmlsZSA9IChwRmlsZSkgPT4gX19tYXBTcWxpdGUzRmlsZS5nZXQocEZpbGUpO1xuICAgICAgICBjb25zdCBzZXRQb29sRm9yUEZpbGUgPSAocEZpbGUsIHBvb2wpID0+IHtcbiAgICAgICAgICBpZiAocG9vbCkgX19tYXBTcWxpdGUzRmlsZS5zZXQocEZpbGUsIHBvb2wpO1xuICAgICAgICAgIGVsc2UgX19tYXBTcWxpdGUzRmlsZS5kZWxldGUocEZpbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlvTWV0aG9kcyA9IHtcbiAgICAgICAgICB4Q2hlY2tSZXNlcnZlZExvY2s6IGZ1bmN0aW9uIChwRmlsZSwgcE91dCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZygneENoZWNrUmVzZXJ2ZWRMb2NrJyk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeENsb3NlOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwb29sLmxvZyhgeENsb3NlICR7ZmlsZS5wYXRofWApO1xuICAgICAgICAgICAgICAgIHBvb2wubWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGZpbGUuc2FoLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUuZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UpIHtcbiAgICAgICAgICAgICAgICAgIHBvb2wuZGVsZXRlUGF0aChmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RGV2aWNlQ2hhcmFjdGVyaXN0aWNzOiBmdW5jdGlvbiAocEZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0NBUF9VTkRFTEVUQUJMRV9XSEVOX09QRU47XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4RmlsZUNvbnRyb2w6IGZ1bmN0aW9uIChwRmlsZSwgb3BJZCwgcEFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeEZpbGVTaXplOiBmdW5jdGlvbiAocEZpbGUsIHBTejY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4RmlsZVNpemVgKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmaWxlLnNhaC5nZXRTaXplKCkgLSBIRUFERVJfT0ZGU0VUX0RBVEE7XG5cbiAgICAgICAgICAgIHdhc20ucG9rZTY0KHBTejY0LCBCaWdJbnQoc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4TG9jazogZnVuY3Rpb24gKHBGaWxlLCBsb2NrVHlwZSkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZyhgeExvY2sgJHtsb2NrVHlwZX1gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIGZpbGUubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeFJlYWQ6IGZ1bmN0aW9uIChwRmlsZSwgcERlc3QsIG4sIG9mZnNldDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4UmVhZCAke2ZpbGUucGF0aH0gJHtufSBAICR7b2Zmc2V0NjR9YCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBuUmVhZCA9IGZpbGUuc2FoLnJlYWQoXG4gICAgICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5zdWJhcnJheShwRGVzdCwgcERlc3QgKyBuKSxcbiAgICAgICAgICAgICAgICB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIob2Zmc2V0NjQpIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChuUmVhZCA8IG4pIHtcbiAgICAgICAgICAgICAgICB3YXNtLmhlYXA4dSgpLmZpbGwoMCwgcERlc3QgKyBuUmVhZCwgcERlc3QgKyBuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlJfU0hPUlRfUkVBRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeFNlY3RvclNpemU6IGZ1bmN0aW9uIChwRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFNFQ1RPUl9TSVpFO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeFN5bmM6IGZ1bmN0aW9uIChwRmlsZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coYHhTeW5jICR7ZmxhZ3N9YCk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZpbGUuc2FoLmZsdXNoKCk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4VHJ1bmNhdGU6IGZ1bmN0aW9uIChwRmlsZSwgc3o2NCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICAgICAgICBwb29sLmxvZyhgeFRydW5jYXRlICR7c3o2NH1gKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmlsZS5zYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhVbmxvY2s6IGZ1bmN0aW9uIChwRmlsZSwgbG9ja1R5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgICAgICAgcG9vbC5sb2coJ3hVbmxvY2snKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIGZpbGUubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeFdyaXRlOiBmdW5jdGlvbiAocEZpbGUsIHBTcmMsIG4sIG9mZnNldDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4V3JpdGUgJHtmaWxlLnBhdGh9ICR7bn0gJHtvZmZzZXQ2NH1gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5CeXRlcyA9IGZpbGUuc2FoLndyaXRlKFxuICAgICAgICAgICAgICAgIHdhc20uaGVhcDh1KCkuc3ViYXJyYXkocFNyYywgcFNyYyArIG4pLFxuICAgICAgICAgICAgICAgIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihvZmZzZXQ2NCkgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG4gPT09IG5CeXRlcyA/IDAgOiB0b3NzKCdVbmtub3duIHdyaXRlKCkgZmFpbHVyZS4nKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3Bmc0lvTWV0aG9kcyA9IG5ldyBjYXBpLnNxbGl0ZTNfaW9fbWV0aG9kcygpO1xuICAgICAgICBvcGZzSW9NZXRob2RzLiRpVmVyc2lvbiA9IDE7XG4gICAgICAgIHNxbGl0ZTMudmZzLmluc3RhbGxWZnMoe1xuICAgICAgICAgIGlvOiB7IHN0cnVjdDogb3Bmc0lvTWV0aG9kcywgbWV0aG9kczogaW9NZXRob2RzIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZmc01ldGhvZHMgPSB7XG4gICAgICAgICAgeEFjY2VzczogZnVuY3Rpb24gKHBWZnMsIHpOYW1lLCBmbGFncywgcE91dCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcG9vbC5nZXRQYXRoKHpOYW1lKTtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlMzIocE91dCwgcG9vbC5oYXNGaWxlbmFtZShuYW1lKSA/IDEgOiAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlMzIocE91dCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhDdXJyZW50VGltZTogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgIHdhc20ucG9rZShcbiAgICAgICAgICAgICAgcE91dCxcbiAgICAgICAgICAgICAgMjQ0MDU4Ny41ICsgbmV3IERhdGUoKS5nZXRUaW1lKCkgLyA4NjQwMDAwMCxcbiAgICAgICAgICAgICAgJ2RvdWJsZScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24gKHBWZnMsIHBPdXQpIHtcbiAgICAgICAgICAgIHdhc20ucG9rZShwT3V0LCAyNDQwNTg3LjUgKiA4NjQwMDAwMCArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCAnaTY0Jyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhEZWxldGU6IGZ1bmN0aW9uIChwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4RGVsZXRlICR7d2FzbS5jc3RyVG9Kcyh6TmFtZSl9YCk7XG4gICAgICAgICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwb29sLmRlbGV0ZVBhdGgocG9vbC5nZXRQYXRoKHpOYW1lKSk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBwb29sLnN0b3JlRXJyKGUpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlJfREVMRVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeEZ1bGxQYXRobmFtZTogZnVuY3Rpb24gKHBWZnMsIHpOYW1lLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICBjb25zdCBpID0gd2FzbS5jc3RybmNweShwT3V0LCB6TmFtZSwgbk91dCk7XG4gICAgICAgICAgICByZXR1cm4gaSA8IG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4R2V0TGFzdEVycm9yOiBmdW5jdGlvbiAocFZmcywgbk91dCwgcE91dCkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICAgICAgICBjb25zdCBlID0gcG9vbC5wb3BFcnIoKTtcbiAgICAgICAgICAgIHBvb2wubG9nKGB4R2V0TGFzdEVycm9yICR7bk91dH0gZSA9YCwgZSk7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICBjb25zdCBzY29wZSA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2NNc2csIG5dID0gd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoZS5tZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB3YXNtLmNzdHJuY3B5KHBPdXQsIGNNc2csIG5PdXQpO1xuICAgICAgICAgICAgICAgIGlmIChuID4gbk91dCkgd2FzbS5wb2tlOChwT3V0ICsgbk91dCAtIDEsIDApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZSA/IGUuc3FsaXRlM1JjIHx8IGNhcGkuU1FMSVRFX0lPRVJSIDogMDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgeE9wZW46IGZ1bmN0aW9uIGYocFZmcywgek5hbWUsIHBGaWxlLCBmbGFncywgcE91dEZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZsYWdzICY9IH5GTEFHX0NPTVBVVEVfRElHRVNUX1YyO1xuICAgICAgICAgICAgICBwb29sLmxvZyhgeE9wZW4gJHt3YXNtLmNzdHJUb0pzKHpOYW1lKX0gJHtmbGFnc31gKTtcblxuICAgICAgICAgICAgICBjb25zdCBwYXRoID1cbiAgICAgICAgICAgICAgICB6TmFtZSAmJiB3YXNtLnBlZWs4KHpOYW1lKVxuICAgICAgICAgICAgICAgICAgPyBwb29sLmdldFBhdGgoek5hbWUpXG4gICAgICAgICAgICAgICAgICA6IGdldFJhbmRvbU5hbWUoKTtcbiAgICAgICAgICAgICAgbGV0IHNhaCA9IHBvb2wuZ2V0U0FIRm9yUGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgaWYgKCFzYWggJiYgZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0NSRUFURSkge1xuICAgICAgICAgICAgICAgIGlmIChwb29sLmdldEZpbGVDb3VudCgpIDwgcG9vbC5nZXRDYXBhY2l0eSgpKSB7XG4gICAgICAgICAgICAgICAgICBzYWggPSBwb29sLm5leHRBdmFpbGFibGVTQUgoKTtcbiAgICAgICAgICAgICAgICAgIHBvb2wuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBwYXRoLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRvc3MoJ1NBSCBwb29sIGlzIGZ1bGwuIENhbm5vdCBjcmVhdGUgZmlsZScsIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXNhaCkge1xuICAgICAgICAgICAgICAgIHRvc3MoJ2ZpbGUgbm90IGZvdW5kOicsIHBhdGgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IHsgcGF0aCwgZmxhZ3MsIHNhaCB9O1xuICAgICAgICAgICAgICBwb29sLm1hcFMzRmlsZVRvT0ZpbGUocEZpbGUsIGZpbGUpO1xuICAgICAgICAgICAgICBmaWxlLmxvY2tUeXBlID0gY2FwaS5TUUxJVEVfTE9DS19OT05FO1xuICAgICAgICAgICAgICBjb25zdCBzcTNGaWxlID0gbmV3IGNhcGkuc3FsaXRlM19maWxlKHBGaWxlKTtcbiAgICAgICAgICAgICAgc3EzRmlsZS4kcE1ldGhvZHMgPSBvcGZzSW9NZXRob2RzLnBvaW50ZXI7XG4gICAgICAgICAgICAgIHNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICB3YXNtLnBva2UzMihwT3V0RmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHBvb2wuc3RvcmVFcnIoZSk7XG4gICAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9DQU5UT1BFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNyZWF0ZU9wZnNWZnMgPSBmdW5jdGlvbiAodmZzTmFtZSkge1xuICAgICAgICAgIGlmIChzcWxpdGUzLmNhcGkuc3FsaXRlM192ZnNfZmluZCh2ZnNOYW1lKSkge1xuICAgICAgICAgICAgdG9zczMoJ1ZGUyBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZDonLCB2ZnNOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3Bmc1ZmcyA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKCk7XG5cbiAgICAgICAgICBjb25zdCBwRFZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZChudWxsKTtcbiAgICAgICAgICBjb25zdCBkVmZzID0gcERWZnMgPyBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwRFZmcykgOiBudWxsO1xuICAgICAgICAgIG9wZnNWZnMuJGlWZXJzaW9uID0gMjtcbiAgICAgICAgICBvcGZzVmZzLiRzek9zRmlsZSA9IGNhcGkuc3FsaXRlM19maWxlLnN0cnVjdEluZm8uc2l6ZW9mO1xuICAgICAgICAgIG9wZnNWZnMuJG14UGF0aG5hbWUgPSBIRUFERVJfTUFYX1BBVEhfU0laRTtcbiAgICAgICAgICBvcGZzVmZzLmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgIChvcGZzVmZzLiR6TmFtZSA9IHdhc20uYWxsb2NDU3RyaW5nKHZmc05hbWUpKSxcbiAgICAgICAgICAgICgpID0+IHNldFBvb2xGb3JWZnMob3Bmc1Zmcy5wb2ludGVyLCAwKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGRWZnMpIHtcbiAgICAgICAgICAgIG9wZnNWZnMuJHhSYW5kb21uZXNzID0gZFZmcy4keFJhbmRvbW5lc3M7XG4gICAgICAgICAgICBvcGZzVmZzLiR4U2xlZXAgPSBkVmZzLiR4U2xlZXA7XG4gICAgICAgICAgICBkVmZzLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvcGZzVmZzLiR4UmFuZG9tbmVzcyAmJiAhdmZzTWV0aG9kcy54UmFuZG9tbmVzcykge1xuICAgICAgICAgICAgdmZzTWV0aG9kcy54UmFuZG9tbmVzcyA9IGZ1bmN0aW9uIChwVmZzLCBuT3V0LCBwT3V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYXAgPSB3YXNtLmhlYXA4dSgpO1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbk91dDsgKytpKVxuICAgICAgICAgICAgICAgIGhlYXBbcE91dCArIGldID0gKE1hdGgucmFuZG9tKCkgKiAyNTUwMDApICYgMHhmZjtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wZnNWZnMuJHhTbGVlcCAmJiAhdmZzTWV0aG9kcy54U2xlZXApIHtcbiAgICAgICAgICAgIHZmc01ldGhvZHMueFNsZWVwID0gKHBWZnMsIG1zKSA9PiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgICAgICAgIHZmczogeyBzdHJ1Y3Q6IG9wZnNWZnMsIG1ldGhvZHM6IHZmc01ldGhvZHMgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gb3Bmc1ZmcztcbiAgICAgICAgfTtcblxuICAgICAgICBjbGFzcyBPcGZzU0FIUG9vbCB7XG4gICAgICAgICAgdmZzRGlyO1xuXG4gICAgICAgICAgI2RoVmZzUm9vdDtcblxuICAgICAgICAgICNkaE9wYXF1ZTtcblxuICAgICAgICAgICNkaFZmc1BhcmVudDtcblxuICAgICAgICAgICNtYXBTQUhUb05hbWUgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAjbWFwRmlsZW5hbWVUb1NBSCA9IG5ldyBNYXAoKTtcblxuICAgICAgICAgICNhdmFpbGFibGVTQUggPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAjbWFwUzNGaWxlVG9PRmlsZV8gPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAjYXBCb2R5ID0gbmV3IFVpbnQ4QXJyYXkoSEVBREVSX0NPUlBVU19TSVpFKTtcblxuICAgICAgICAgICNkdkJvZHk7XG5cbiAgICAgICAgICAjY1ZmcztcblxuICAgICAgICAgICN2ZXJib3NpdHk7XG5cbiAgICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSkge1xuICAgICAgICAgICAgdGhpcy4jdmVyYm9zaXR5ID0gb3B0aW9ucy52ZXJib3NpdHkgPz8gb3B0aW9uRGVmYXVsdHMudmVyYm9zaXR5O1xuICAgICAgICAgICAgdGhpcy52ZnNOYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbkRlZmF1bHRzLm5hbWU7XG4gICAgICAgICAgICB0aGlzLiNjVmZzID0gY3JlYXRlT3Bmc1Zmcyh0aGlzLnZmc05hbWUpO1xuICAgICAgICAgICAgc2V0UG9vbEZvclZmcyh0aGlzLiNjVmZzLnBvaW50ZXIsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52ZnNEaXIgPSBvcHRpb25zLmRpcmVjdG9yeSB8fCAnLicgKyB0aGlzLnZmc05hbWU7XG4gICAgICAgICAgICB0aGlzLiNkdkJvZHkgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICAgIHRoaXMuI2FwQm9keS5idWZmZXIsXG4gICAgICAgICAgICAgIHRoaXMuI2FwQm9keS5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkeSA9IHRoaXMucmVzZXQoXG4gICAgICAgICAgICAgICEhKG9wdGlvbnMuY2xlYXJPbkluaXQgPz8gb3B0aW9uRGVmYXVsdHMuY2xlYXJPbkluaXQpLFxuICAgICAgICAgICAgKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuJGVycm9yKSB0aHJvdyB0aGlzLiRlcnJvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWNpdHkoKVxuICAgICAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICA6IHRoaXMuYWRkQ2FwYWNpdHkoXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5pdGlhbENhcGFjaXR5IHx8IG9wdGlvbkRlZmF1bHRzLmluaXRpYWxDYXBhY2l0eSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAjbG9nSW1wbChsZXZlbCwgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZlcmJvc2l0eSA+IGxldmVsKVxuICAgICAgICAgICAgICBsb2dnZXJzW2xldmVsXSh0aGlzLnZmc05hbWUgKyAnOicsIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2coLi4uYXJncykge1xuICAgICAgICAgICAgdGhpcy4jbG9nSW1wbCgyLCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dJbXBsKDEsIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dJbXBsKDAsIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFZmcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjVmZzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldENhcGFjaXR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcFNBSFRvTmFtZS5zaXplO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldEZpbGVDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILnNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0RmlsZU5hbWVzKCkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmtleXMoKSkgcmMucHVzaChuKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyBhZGRDYXBhY2l0eShuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICAgICAgICBjb25zdCBoID0gYXdhaXQgdGhpcy4jZGhPcGFxdWUuZ2V0RmlsZUhhbmRsZShuYW1lLCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLnNldChhaCwgbmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoYWgsICcnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobikge1xuICAgICAgICAgICAgbGV0IG5SbSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFoIG9mIEFycmF5LmZyb20odGhpcy4jYXZhaWxhYmxlU0FIKSkge1xuICAgICAgICAgICAgICBpZiAoblJtID09PSBuIHx8IHRoaXMuZ2V0RmlsZUNvdW50KCkgPT09IHRoaXMuZ2V0Q2FwYWNpdHkoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLiNtYXBTQUhUb05hbWUuZ2V0KGFoKTtcblxuICAgICAgICAgICAgICBhaC5jbG9zZSgpO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaE9wYXF1ZS5yZW1vdmVFbnRyeShuYW1lKTtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLmRlbGV0ZShhaCk7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoYWgpO1xuICAgICAgICAgICAgICArK25SbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuUm07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVsZWFzZUFjY2Vzc0hhbmRsZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFoIG9mIHRoaXMuI21hcFNBSFRvTmFtZS5rZXlzKCkpIGFoLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5jbGVhcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgW25hbWUsIGhdIG9mIHRoaXMuI2RoT3BhcXVlKSB7XG4gICAgICAgICAgICAgIGlmICgnZmlsZScgPT09IGgua2luZCkge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goW25hbWUsIGhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBmaWxlcy5tYXAoYXN5bmMgKFtuYW1lLCBoXSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhaCA9IGF3YWl0IGguY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLnNldChhaCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2xlYXJGaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKGFoLCAnJywgMCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRBc3NvY2lhdGVkUGF0aChhaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5zZXQocGF0aCwgYWgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5hZGQoYWgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZUVycihlKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0QXNzb2NpYXRlZFBhdGgoc2FoKSB7XG4gICAgICAgICAgICBzYWgucmVhZCh0aGlzLiNhcEJvZHksIHsgYXQ6IDAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gdGhpcy4jZHZCb2R5LmdldFVpbnQzMihIRUFERVJfT0ZGU0VUX0ZMQUdTKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGhpcy4jYXBCb2R5WzBdICYmXG4gICAgICAgICAgICAgIChmbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fREVMRVRFT05DTE9TRSB8fFxuICAgICAgICAgICAgICAgIChmbGFncyAmIFBFUlNJU1RFTlRfRklMRV9UWVBFUykgPT09IDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBgUmVtb3ZpbmcgZmlsZSB3aXRoIHVuZXhwZWN0ZWQgZmxhZ3MgJHtmbGFncy50b1N0cmluZygxNil9YCxcbiAgICAgICAgICAgICAgICB0aGlzLiNhcEJvZHksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmlsZURpZ2VzdCA9IG5ldyBVaW50MzJBcnJheShIRUFERVJfRElHRVNUX1NJWkUgLyA0KTtcbiAgICAgICAgICAgIHNhaC5yZWFkKGZpbGVEaWdlc3QsIHsgYXQ6IEhFQURFUl9PRkZTRVRfRElHRVNUIH0pO1xuICAgICAgICAgICAgY29uc3QgY29tcERpZ2VzdCA9IHRoaXMuY29tcHV0ZURpZ2VzdCh0aGlzLiNhcEJvZHksIGZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKGZpbGVEaWdlc3QuZXZlcnkoKHYsIGkpID0+IHYgPT09IGNvbXBEaWdlc3RbaV0pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhCeXRlcyA9IHRoaXMuI2FwQm9keS5maW5kSW5kZXgoKHYpID0+IDAgPT09IHYpO1xuICAgICAgICAgICAgICBpZiAoMCA9PT0gcGF0aEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgc2FoLnRydW5jYXRlKEhFQURFUl9PRkZTRVRfREFUQSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcGF0aEJ5dGVzXG4gICAgICAgICAgICAgICAgPyB0ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy4jYXBCb2R5LnN1YmFycmF5KDAsIHBhdGhCeXRlcykpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oJ0Rpc2Fzc29jaWF0aW5nIGZpbGUgd2l0aCBiYWQgZGlnZXN0LicpO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBwYXRoLCBmbGFncykge1xuICAgICAgICAgICAgY29uc3QgZW5jID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhwYXRoLCB0aGlzLiNhcEJvZHkpO1xuICAgICAgICAgICAgaWYgKEhFQURFUl9NQVhfUEFUSF9TSVpFIDw9IGVuYy53cml0dGVuICsgMSkge1xuICAgICAgICAgICAgICB0b3NzKCdQYXRoIHRvbyBsb25nOicsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGggJiYgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRkxBR19DT01QVVRFX0RJR0VTVF9WMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2FwQm9keS5maWxsKDAsIGVuYy53cml0dGVuLCBIRUFERVJfTUFYX1BBVEhfU0laRSk7XG4gICAgICAgICAgICB0aGlzLiNkdkJvZHkuc2V0VWludDMyKEhFQURFUl9PRkZTRVRfRkxBR1MsIGZsYWdzKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IHRoaXMuY29tcHV0ZURpZ2VzdCh0aGlzLiNhcEJvZHksIGZsYWdzKTtcblxuICAgICAgICAgICAgc2FoLndyaXRlKHRoaXMuI2FwQm9keSwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgIHNhaC53cml0ZShkaWdlc3QsIHsgYXQ6IEhFQURFUl9PRkZTRVRfRElHRVNUIH0pO1xuICAgICAgICAgICAgc2FoLmZsdXNoKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIHNhaCk7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoc2FoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKHNhaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tcHV0ZURpZ2VzdChieXRlQXJyYXksIGZpbGVGbGFncykge1xuICAgICAgICAgICAgaWYgKGZpbGVGbGFncyAmIEZMQUdfQ09NUFVURV9ESUdFU1RfVjIpIHtcbiAgICAgICAgICAgICAgbGV0IGgxID0gMHhkZWFkYmVlZjtcbiAgICAgICAgICAgICAgbGV0IGgyID0gMHg0MWM2Y2U1NztcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJ5dGVBcnJheSkge1xuICAgICAgICAgICAgICAgIGgxID0gTWF0aC5pbXVsKGgxIF4gdiwgMjY1NDQzNTc2MSk7XG4gICAgICAgICAgICAgICAgaDIgPSBNYXRoLmltdWwoaDIgXiB2LCAxMDQ3MjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoW2gxID4+PiAwLCBoMiA+Pj4gMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShbMCwgMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlc2V0KGNsZWFyRmlsZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXNSZWFkeTtcbiAgICAgICAgICAgIGxldCBoID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgICAgICAgICBsZXQgcHJldiwgcHJldk5hbWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgdGhpcy52ZnNEaXIuc3BsaXQoJy8nKSkge1xuICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBoO1xuICAgICAgICAgICAgICAgIGggPSBhd2FpdCBoLmdldERpcmVjdG9yeUhhbmRsZShkLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jZGhWZnNSb290ID0gaDtcbiAgICAgICAgICAgIHRoaXMuI2RoVmZzUGFyZW50ID0gcHJldjtcbiAgICAgICAgICAgIHRoaXMuI2RoT3BhcXVlID0gYXdhaXQgdGhpcy4jZGhWZnNSb290LmdldERpcmVjdG9yeUhhbmRsZShcbiAgICAgICAgICAgICAgT1BBUVVFX0RJUl9OQU1FLFxuICAgICAgICAgICAgICB7IGNyZWF0ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFBhdGgoYXJnKSB7XG4gICAgICAgICAgICBpZiAod2FzbS5pc1B0cihhcmcpKSBhcmcgPSB3YXNtLmNzdHJUb0pzKGFyZyk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBhcmcgaW5zdGFuY2VvZiBVUkwgPyBhcmcgOiBuZXcgVVJMKGFyZywgJ2ZpbGU6Ly9sb2NhbGhvc3QvJylcbiAgICAgICAgICAgICkucGF0aG5hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlUGF0aChwYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBzYWggPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChwYXRoKTtcbiAgICAgICAgICAgIGlmIChzYWgpIHtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISFzYWg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RvcmVFcnIoZSwgY29kZSkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgZS5zcWxpdGUzUmMgPSBjb2RlIHx8IGNhcGkuU1FMSVRFX0lPRVJSO1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZXJyb3IgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9wRXJyKCkge1xuICAgICAgICAgICAgY29uc3QgcmMgPSB0aGlzLiRlcnJvcjtcbiAgICAgICAgICAgIHRoaXMuJGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHRBdmFpbGFibGVTQUgoKSB7XG4gICAgICAgICAgICBjb25zdCBbcmNdID0gdGhpcy4jYXZhaWxhYmxlU0FILmtleXMoKTtcbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRPRmlsZUZvclMzRmlsZShwRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLmdldChwRmlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmlsZSkge1xuICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uc2V0KHBGaWxlLCBmaWxlKTtcbiAgICAgICAgICAgICAgc2V0UG9vbEZvclBGaWxlKHBGaWxlLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLmRlbGV0ZShwRmlsZSk7XG4gICAgICAgICAgICAgIHNldFBvb2xGb3JQRmlsZShwRmlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhc0ZpbGVuYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmhhcyhuYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRTQUhGb3JQYXRoKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyByZW1vdmVWZnMoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2NWZnMucG9pbnRlciB8fCAhdGhpcy4jZGhPcGFxdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM192ZnNfdW5yZWdpc3Rlcih0aGlzLiNjVmZzLnBvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy4jY1Zmcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkZWxldGUgaW5pdFByb21pc2VzW3RoaXMudmZzTmFtZV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2RoVmZzUm9vdC5yZW1vdmVFbnRyeShPUEFRVUVfRElSX05BTUUsIHtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLiNkaE9wYXF1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGhWZnNQYXJlbnQucmVtb3ZlRW50cnkodGhpcy4jZGhWZnNSb290Lm5hbWUsIHtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLiNkaFZmc1Jvb3QgPSB0aGlzLiNkaFZmc1BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy52ZnNOYW1lLFxuICAgICAgICAgICAgICAgICdyZW1vdmVWZnMoKSBmYWlsZWQgd2l0aCBubyByZWNvdmVyeSBzdHJhdGVneTonLFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXVzZVZmcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXBTM0ZpbGVUb09GaWxlXy5zaXplID4gMCkge1xuICAgICAgICAgICAgICBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAnQ2Fubm90IHBhdXNlIFZGUycsXG4gICAgICAgICAgICAgICAgdGhpcy52ZnNOYW1lLFxuICAgICAgICAgICAgICAgICdiZWNhdXNlIGl0IGhhcyBvcGVuZWQgZmlsZXMuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXBTQUhUb05hbWUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHRoaXMudmZzTmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzUGF1c2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIDAgPT09IHRoaXMuI21hcFNBSFRvTmFtZS5zaXplO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHVucGF1c2VWZnMoKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gdGhpcy4jbWFwU0FIVG9OYW1lLnNpemUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZUFjY2Vzc0hhbmRsZXMoZmFsc2UpLnRoZW4oXG4gICAgICAgICAgICAgICAgKCkgPT4gY2FwaS5zcWxpdGUzX3Zmc19yZWdpc3Rlcih0aGlzLiNjVmZzLCAwKSxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0RmlsZShuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBzYWggPVxuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fCB0b3NzKCdGaWxlIG5vdCBmb3VuZDonLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzYWguZ2V0U2l6ZSgpIC0gSEVBREVSX09GRlNFVF9EQVRBO1xuICAgICAgICAgICAgY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KG4gPiAwID8gbiA6IDApO1xuICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5SZWFkID0gc2FoLnJlYWQoYiwgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBIH0pO1xuICAgICAgICAgICAgICBpZiAoblJlYWQgIT0gbikge1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgdG8gcmVhZCAnICsgbiArICcgYnl0ZXMgYnV0IHJlYWQgJyArIG5SZWFkICsgJy4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGltcG9ydERiQ2h1bmtlZChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3Qgc2FoID1cbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSkgfHxcbiAgICAgICAgICAgICAgdGhpcy5uZXh0QXZhaWxhYmxlU0FIKCkgfHxcbiAgICAgICAgICAgICAgdG9zcygnTm8gYXZhaWxhYmxlIGhhbmRsZXMgdG8gaW1wb3J0IHRvLicpO1xuICAgICAgICAgICAgc2FoLnRydW5jYXRlKDApO1xuICAgICAgICAgICAgbGV0IG5Xcm90ZSA9IDAsXG4gICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICBjaGVja2VkSGVhZGVyID0gZmFsc2UsXG4gICAgICAgICAgICAgIGVyciA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2hpbGUgKHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IG5Xcm90ZSAmJiBjaHVuay5ieXRlTGVuZ3RoID49IDE1KSB7XG4gICAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIG5Xcm90ZSB9KTtcbiAgICAgICAgICAgICAgICBuV3JvdGUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobldyb3RlIDwgNTEyIHx8IDAgIT09IG5Xcm90ZSAlIDUxMikge1xuICAgICAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICAgICAnSW5wdXQgc2l6ZScsXG4gICAgICAgICAgICAgICAgICBuV3JvdGUsXG4gICAgICAgICAgICAgICAgICAnaXMgbm90IGNvcnJlY3QgZm9yIGFuIFNRTGl0ZSBkYXRhYmFzZS4nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFjaGVja2VkSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICAgICAgICAgIHNhaC5yZWFkKGhlYWRlciwgeyBhdDogMCB9KTtcbiAgICAgICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGhlYWRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHtcbiAgICAgICAgICAgICAgICBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgMTgsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsIG5hbWUsIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQik7XG4gICAgICAgICAgICByZXR1cm4gbldyb3RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGltcG9ydERiKG5hbWUsIGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnREYkNodW5rZWQobmFtZSwgYnl0ZXMpO1xuICAgICAgICAgICAgY29uc3Qgc2FoID1cbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSkgfHxcbiAgICAgICAgICAgICAgdGhpcy5uZXh0QXZhaWxhYmxlU0FIKCkgfHxcbiAgICAgICAgICAgICAgdG9zcygnTm8gYXZhaWxhYmxlIGhhbmRsZXMgdG8gaW1wb3J0IHRvLicpO1xuICAgICAgICAgICAgY29uc3QgbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA8IDUxMiB8fCBuICUgNTEyICE9IDApIHtcbiAgICAgICAgICAgICAgdG9zcygnQnl0ZSBhcnJheSBzaXplIGlzIGludmFsaWQgZm9yIGFuIFNRTGl0ZSBkYi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9ICdTUUxpdGUgZm9ybWF0IDMnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGhlYWRlci5jaGFyQ29kZUF0KGkpICE9PSBieXRlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRvc3MoJ0lucHV0IGRvZXMgbm90IGNvbnRhaW4gYW4gU1FMaXRlIGRhdGFiYXNlIGhlYWRlci4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgfSk7XG4gICAgICAgICAgICBpZiAobldyb3RlICE9IG4pIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgICAgICAgdG9zcyhcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgdG8gd3JpdGUgJyArIG4gKyAnIGJ5dGVzIGJ1dCB3cm90ZSAnICsgbldyb3RlICsgJy4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLCAxXSksIHtcbiAgICAgICAgICAgICAgICBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgMTgsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgbmFtZSwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3MgT3Bmc1NBSFBvb2xVdGlsIHtcbiAgICAgICAgICAjcDtcblxuICAgICAgICAgIGNvbnN0cnVjdG9yKHNhaFBvb2wpIHtcbiAgICAgICAgICAgIHRoaXMuI3AgPSBzYWhQb29sO1xuICAgICAgICAgICAgdGhpcy52ZnNOYW1lID0gc2FoUG9vbC52ZnNOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIGFkZENhcGFjaXR5KG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmFkZENhcGFjaXR5KG4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlZHVjZUNhcGFjaXR5KG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLnJlZHVjZUNhcGFjaXR5KG4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldENhcGFjaXR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZ2V0Q2FwYWNpdHkodGhpcy4jcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0RmlsZUNvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3AuZ2V0RmlsZUNvdW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldEZpbGVOYW1lcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmdldEZpbGVOYW1lcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlc2VydmVNaW5pbXVtQ2FwYWNpdHkobWluKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy4jcC5nZXRDYXBhY2l0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGMgPCBtaW4gPyB0aGlzLiNwLmFkZENhcGFjaXR5KG1pbiAtIGMpIDogYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRGaWxlKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmV4cG9ydEZpbGUobmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW1wb3J0RGIobmFtZSwgYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmltcG9ydERiKG5hbWUsIGJ5dGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3luYyB3aXBlRmlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5yZXNldCh0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1bmxpbmsoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLmRlbGV0ZVBhdGgoZmlsZW5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzeW5jIHJlbW92ZVZmcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwLnJlbW92ZVZmcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdXNlVmZzKCkge1xuICAgICAgICAgICAgdGhpcy4jcC5wYXVzZVZmcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzeW5jIHVucGF1c2VWZnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC51bnBhdXNlVmZzKCkudGhlbigoKSA9PiB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQYXVzZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcC5pc1BhdXNlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb25DaGVjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkaCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgICAgICAgIGNvbnN0IGZuID0gJy5vcGZzLXNhaHBvb2wtc3luYy1jaGVjay0nICsgZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICAgIGNvbnN0IGZoID0gYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbiwgeyBjcmVhdGU6IHRydWUgfSk7XG4gICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBmaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgICAgY29uc3QgY2xvc2UgPSBhaC5jbG9zZSgpO1xuICAgICAgICAgIGF3YWl0IGNsb3NlO1xuICAgICAgICAgIGF3YWl0IGRoLnJlbW92ZUVudHJ5KGZuKTtcbiAgICAgICAgICBpZiAoY2xvc2U/LnRoZW4pIHtcbiAgICAgICAgICAgIHRvc3MoXG4gICAgICAgICAgICAgICdUaGUgbG9jYWwgT1BGUyBBUEkgaXMgdG9vIG9sZCBmb3Igb3Bmcy1zYWhwb29sOicsXG4gICAgICAgICAgICAgICdpdCBoYXMgYW4gYXN5bmMgRmlsZVN5c3RlbVN5bmNBY2Nlc3NIYW5kbGUuY2xvc2UoKSBtZXRob2QuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNxbGl0ZTMuaW5zdGFsbE9wZnNTQUhQb29sVmZzID0gYXN5bmMgZnVuY3Rpb24gKFxuICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBvcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB2ZnNOYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgICAgIGlmIChvcHRpb25zLiR0ZXN0VGhyb3dQaGFzZTEpIHtcbiAgICAgICAgICAgIHRocm93IG9wdGlvbnMuJHRlc3RUaHJvd1BoYXNlMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluaXRQcm9taXNlc1t2ZnNOYW1lXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IGF3YWl0IGluaXRQcm9taXNlc1t2ZnNOYW1lXTtcblxuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9yY2VSZWluaXRJZlByZXZpb3VzbHlGYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5pdFByb21pc2VzW3Zmc05hbWVdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8fFxuICAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgfHxcbiAgICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlIHx8XG4gICAgICAgICAgICAhbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3RvcnlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBPUEZTIEFQSXMuJyksXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKGluaXRQcm9taXNlc1t2ZnNOYW1lXSA9IGFwaVZlcnNpb25DaGVjaygpXG4gICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLiR0ZXN0VGhyb3dQaGFzZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBvcHRpb25zLiR0ZXN0VGhyb3dQaGFzZTI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGhlUG9vbCA9IG5ldyBPcGZzU0FIUG9vbChvcHRpb25zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZVBvb2wuaXNSZWFkeVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBvb2xVdGlsID0gbmV3IE9wZnNTQUhQb29sVXRpbCh0aGVQb29sKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzcWxpdGUzLm9vMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbzEgPSBzcWxpdGUzLm9vMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlVmZzID0gdGhlUG9vbC5nZXRWZnMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgT3Bmc1NBSFBvb2xEYiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gb28xLkRCLmRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgIG9wdC52ZnMgPSB0aGVWZnMuJHpOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIG9vMS5EQi5kYkN0b3JIZWxwZXIuY2FsbCh0aGlzLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBPcGZzU0FIUG9vbERiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUob28xLkRCLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvb2xVdGlsLk9wZnNTQUhQb29sRGIgPSBPcGZzU0FIUG9vbERiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhlUG9vbC5sb2coJ1ZGUyBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwb29sVXRpbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhlUG9vbC5yZW1vdmVWZnMoKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgKCd1c2Ugc3RyaWN0Jyk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgU0FCQyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHBvcnRzOlxuICAgICAgICAgICAgICAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdhc21FeHBvcnRzID8gTW9kdWxlWydhc20nXSA6IHdhc21FeHBvcnRzLFxuICAgICAgICAgICAgbWVtb3J5OiBNb2R1bGUud2FzbU1lbW9yeSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fCB7fSxcbiAgICAgICAgKTtcblxuICAgICAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgPSBTQUJDO1xuICAgICAgICBsZXQgc3FsaXRlMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzcWxpdGUzID0gZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdzcWxpdGUzQXBpQm9vdHN0cmFwKCkgZXJyb3I6JywgZSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwO1xuICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWc7XG4gICAgICAgIH1cblxuICAgICAgICBNb2R1bGUuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoaXMgaXMgbm90IHJ1bm5pbmcgaW4gYW4gRW1zY3JpcHRlbiBtb2R1bGUgY29udGV4dCwgc28nLFxuICAgICAgICAgICdnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAoKSBpcyBfbm90XyBiZWluZyBjYWxsZWQgZHVlIHRvIGxhY2snLFxuICAgICAgICAgICdvZiBjb25maWcgaW5mbyBmb3IgdGhlIFdBU00gZW52aXJvbm1lbnQuJyxcbiAgICAgICAgICAnSXQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlUnRuID0gcmVhZHlQcm9taXNlO1xuXG4gICAgcmV0dXJuIG1vZHVsZVJ0bjtcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IHRvRXhwb3J0Rm9yRVNNID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgb3JpZ2luYWxJbml0ID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIGlmICghb3JpZ2luYWxJbml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0V4cGVjdGluZyBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlIHRvIGJlIGRlZmluZWQgYnkgdGhlIEVtc2NyaXB0ZW4gYnVpbGQuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5pdE1vZHVsZVN0YXRlID0gKGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICB7XG4gICAgICBtb2R1bGVTY3JpcHQ6IGdsb2JhbFRoaXM/LmRvY3VtZW50Py5jdXJyZW50U2NyaXB0LFxuICAgICAgaXNXb3JrZXI6ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUsXG4gICAgICBsb2NhdGlvbjogZ2xvYmFsVGhpcy5sb2NhdGlvbixcbiAgICAgIHVybFBhcmFtczogZ2xvYmFsVGhpcz8ubG9jYXRpb24/LmhyZWZcbiAgICAgICAgPyBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zXG4gICAgICAgIDogbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgIH0sXG4gICkpO1xuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUgPSBpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcyhcbiAgICAnc3FsaXRlMy5kZWJ1Z01vZHVsZScsXG4gIClcbiAgICA/ICguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4oJ3NxbGl0ZTMuZGVidWdNb2R1bGU6JywgLi4uYXJncylcbiAgICA6ICgpID0+IHt9O1xuXG4gIGlmIChpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcygnc3FsaXRlMy5kaXInKSkge1xuICAgIGluaXRNb2R1bGVTdGF0ZS5zcWxpdGUzRGlyID1cbiAgICAgIGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuZ2V0KCdzcWxpdGUzLmRpcicpICsgJy8nO1xuICB9IGVsc2UgaWYgKGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQpIHtcbiAgICBjb25zdCBsaSA9IGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQuc3JjLnNwbGl0KCcvJyk7XG4gICAgbGkucG9wKCk7XG4gICAgaW5pdE1vZHVsZVN0YXRlLnNxbGl0ZTNEaXIgPSBsaS5qb2luKCcvJykgKyAnLyc7XG4gIH1cblxuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlID0gZnVuY3Rpb24gZmYoLi4uYXJncykge1xuICAgIHJldHVybiBvcmlnaW5hbEluaXQoLi4uYXJncylcbiAgICAgIC50aGVuKChFbXNjcmlwdGVuTW9kdWxlKSA9PiB7XG4gICAgICAgIEVtc2NyaXB0ZW5Nb2R1bGUucnVuU1FMaXRlM1Bvc3RMb2FkSW5pdChFbXNjcmlwdGVuTW9kdWxlKTtcbiAgICAgICAgY29uc3QgcyA9IEVtc2NyaXB0ZW5Nb2R1bGUuc3FsaXRlMztcbiAgICAgICAgcy5zY3JpcHRJbmZvID0gaW5pdE1vZHVsZVN0YXRlO1xuXG4gICAgICAgIGlmIChmZi5fX2lzVW5kZXJUZXN0KSBzLl9faXNVbmRlclRlc3QgPSB0cnVlO1xuICAgICAgICBjb25zdCBmID0gcy5hc3luY1Bvc3RJbml0O1xuICAgICAgICBkZWxldGUgcy5hc3luY1Bvc3RJbml0O1xuICAgICAgICBjb25zdCBydiA9IGYoKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gbG9hZGluZyBzcWxpdGUzIG1vZHVsZTonLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICB9O1xuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlLnJlYWR5ID0gb3JpZ2luYWxJbml0LnJlYWR5O1xuXG4gIGlmIChnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUubW9kdWxlU2NyaXB0KSB7XG4gICAgY29uc3Qgc2ltID0gZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuICAgIGxldCBzcmMgPSBzaW0ubW9kdWxlU2NyaXB0LnNyYy5zcGxpdCgnLycpO1xuICAgIHNyYy5wb3AoKTtcbiAgICBzaW0uc2NyaXB0RGlyID0gc3JjLmpvaW4oJy8nKSArICcvJztcbiAgfVxuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoJ3NxbGl0ZTNJbml0TW9kdWxlU3RhdGUgPScsIGluaXRNb2R1bGVTdGF0ZSk7XG4gIGlmICgwKSB7XG4gICAgY29uc29sZS53YXJuKCdSZXBsYWNlZCBzcWxpdGUzSW5pdE1vZHVsZSgpJyk7XG4gICAgY29uc29sZS53YXJuKCdnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYgPScsIGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZik7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZG9jdW1lbnQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjID0nLFxuICAgICAgICBkb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGU7XG59KSgpO1xuc3FsaXRlM0luaXRNb2R1bGUgPSB0b0V4cG9ydEZvckVTTTtcbmV4cG9ydCBkZWZhdWx0IHNxbGl0ZTNJbml0TW9kdWxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n  2022-08-24\n\n  The author disclaims copyright to this source code.  In place of a\n  legal notice, here is a blessing:\n\n  *   May you do good and not evil.\n  *   May you find forgiveness for yourself and forgive others.\n  *   May you share freely, never taking more than you give.\n\n  ***********************************************************************\n\n  This file implements a Promise-based proxy for the sqlite3 Worker\n  API #1. It is intended to be included either from the main thread or\n  a Worker, but only if (A) the environment supports nested Workers\n  and (B) it's _not_ a Worker which loads the sqlite3 WASM/JS\n  module. This file's features will load that module and provide a\n  slightly simpler client-side interface than the slightly-lower-level\n  Worker API does.\n\n  This script necessarily exposes one global symbol, but clients may\n  freely `delete` that symbol after calling it.\n*/\n\n\nglobalThis.sqlite3Worker1Promiser = function callee(\n  config = callee.defaultConfig,\n) {\n  if (1 === arguments.length && 'function' === typeof arguments[0]) {\n    const f = config;\n    config = Object.assign(Object.create(null), callee.defaultConfig);\n    config.onready = f;\n  } else {\n    config = Object.assign(Object.create(null), callee.defaultConfig, config);\n  }\n  const handlerMap = Object.create(null);\n  const noop = function () {};\n  const err = config.onerror || noop;\n  const debug = config.debug || noop;\n  const idTypeMap = config.generateMessageId ? undefined : Object.create(null);\n  const genMsgId =\n    config.generateMessageId ||\n    function (msg) {\n      return (\n        msg.type + '#' + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1)\n      );\n    };\n  const toss = (...args) => {\n    throw new Error(args.join(' '));\n  };\n  if (!config.worker) config.worker = callee.defaultConfig.worker;\n  if ('function' === typeof config.worker) config.worker = config.worker();\n  let dbId;\n  let promiserFunc;\n  config.worker.onmessage = function (ev) {\n    ev = ev.data;\n    debug('worker1.onmessage', ev);\n    let msgHandler = handlerMap[ev.messageId];\n    if (!msgHandler) {\n      if (ev && 'sqlite3-api' === ev.type && 'worker1-ready' === ev.result) {\n        if (config.onready) config.onready(promiserFunc);\n        return;\n      }\n      msgHandler = handlerMap[ev.type];\n      if (msgHandler && msgHandler.onrow) {\n        msgHandler.onrow(ev);\n        return;\n      }\n      if (config.onunhandled) config.onunhandled(arguments[0]);\n      else err('sqlite3Worker1Promiser() unhandled worker message:', ev);\n      return;\n    }\n    delete handlerMap[ev.messageId];\n    switch (ev.type) {\n      case 'error':\n        msgHandler.reject(ev);\n        return;\n      case 'open':\n        if (!dbId) dbId = ev.dbId;\n        break;\n      case 'close':\n        if (ev.dbId === dbId) dbId = undefined;\n        break;\n      default:\n        break;\n    }\n    try {\n      msgHandler.resolve(ev);\n    } catch (e) {\n      msgHandler.reject(e);\n    }\n  };\n  return (promiserFunc = function () {\n    let msg;\n    if (1 === arguments.length) {\n      msg = arguments[0];\n    } else if (2 === arguments.length) {\n      msg = Object.create(null);\n      msg.type = arguments[0];\n      msg.args = arguments[1];\n      msg.dbId = msg.args.dbId;\n    } else {\n      toss('Invalid arguments for sqlite3Worker1Promiser()-created factory.');\n    }\n    if (!msg.dbId && msg.type !== 'open') msg.dbId = dbId;\n    msg.messageId = genMsgId(msg);\n    msg.departureTime = performance.now();\n    const proxy = Object.create(null);\n    proxy.message = msg;\n    let rowCallbackId;\n    if ('exec' === msg.type && msg.args) {\n      if ('function' === typeof msg.args.callback) {\n        rowCallbackId = msg.messageId + ':row';\n        proxy.onrow = msg.args.callback;\n        msg.args.callback = rowCallbackId;\n        handlerMap[rowCallbackId] = proxy;\n      } else if ('string' === typeof msg.args.callback) {\n        toss(\n          'exec callback may not be a string when using the Promise interface.',\n        );\n      }\n    }\n\n    let p = new Promise(function (resolve, reject) {\n      proxy.resolve = resolve;\n      proxy.reject = reject;\n      handlerMap[msg.messageId] = proxy;\n      debug(\n        'Posting',\n        msg.type,\n        'message to Worker dbId=' + (dbId || 'default') + ':',\n        msg,\n      );\n      config.worker.postMessage(msg);\n    });\n    if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);\n    return p;\n  });\n};\n\nglobalThis.sqlite3Worker1Promiser.defaultConfig = {\n  worker: function () {\n    return new Worker(\n      __webpack_require__.tu(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"_app-pages-browser_node_modules_sqlite_org_sqlite-wasm_sqlite-wasm_jswasm_sqlite3-worker1-bun-bb258a\"), __webpack_require__.b)),\n      {\n        type: undefined,\n      },\n    );\n  },\n  onerror: (...args) => console.error('worker1 promiser error', ...args),\n};\n\nsqlite3Worker1Promiser.v2 = function (config) {\n  let oldFunc;\n  if ('function' == typeof config) {\n    oldFunc = config;\n    config = {};\n  } else if ('function' === typeof config?.onready) {\n    oldFunc = config.onready;\n    delete config.onready;\n  }\n  const promiseProxy = Object.create(null);\n  config = Object.assign(config || Object.create(null), {\n    onready: async function (func) {\n      try {\n        if (oldFunc) await oldFunc(func);\n        promiseProxy.resolve(func);\n      } catch (e) {\n        promiseProxy.reject(e);\n      }\n    },\n  });\n  const p = new Promise(function (resolve, reject) {\n    promiseProxy.resolve = resolve;\n    promiseProxy.reject = reject;\n  });\n  try {\n    this.original(config);\n  } catch (e) {\n    promiseProxy.reject(e);\n  }\n  return p;\n}.bind({\n  original: sqlite3Worker1Promiser,\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sqlite3Worker1Promiser.v2);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9zcWxpdGUtd2FzbS9qc3dhc20vc3FsaXRlMy13b3JrZXIxLXByb21pc2VyLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0JBQVEsZ01BQXVELENBQUM7QUFDdEU7QUFDQSxjQUFjLFNBQVE7QUFDdEIsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSx5QkFBeUIsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BpeXVzaC5kYWdhQHBvc3RtYW4uY29tL0RvY3VtZW50cy9Qcm9qZWN0cy9waXl1c2gtZGFnYS9ldmEtMi9zZXNzaW9uMS1idWlsZC10b2RvLWNhbGVuZGFyL25vZGVfbW9kdWxlcy9Ac3FsaXRlLm9yZy9zcWxpdGUtd2FzbS9zcWxpdGUtd2FzbS9qc3dhc20vc3FsaXRlMy13b3JrZXIxLXByb21pc2VyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAyMDIyLTA4LTI0XG5cbiAgVGhlIGF1dGhvciBkaXNjbGFpbXMgY29weXJpZ2h0IHRvIHRoaXMgc291cmNlIGNvZGUuICBJbiBwbGFjZSBvZiBhXG4gIGxlZ2FsIG5vdGljZSwgaGVyZSBpcyBhIGJsZXNzaW5nOlxuXG4gICogICBNYXkgeW91IGRvIGdvb2QgYW5kIG5vdCBldmlsLlxuICAqICAgTWF5IHlvdSBmaW5kIGZvcmdpdmVuZXNzIGZvciB5b3Vyc2VsZiBhbmQgZm9yZ2l2ZSBvdGhlcnMuXG4gICogICBNYXkgeW91IHNoYXJlIGZyZWVseSwgbmV2ZXIgdGFraW5nIG1vcmUgdGhhbiB5b3UgZ2l2ZS5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGEgUHJvbWlzZS1iYXNlZCBwcm94eSBmb3IgdGhlIHNxbGl0ZTMgV29ya2VyXG4gIEFQSSAjMS4gSXQgaXMgaW50ZW5kZWQgdG8gYmUgaW5jbHVkZWQgZWl0aGVyIGZyb20gdGhlIG1haW4gdGhyZWFkIG9yXG4gIGEgV29ya2VyLCBidXQgb25seSBpZiAoQSkgdGhlIGVudmlyb25tZW50IHN1cHBvcnRzIG5lc3RlZCBXb3JrZXJzXG4gIGFuZCAoQikgaXQncyBfbm90XyBhIFdvcmtlciB3aGljaCBsb2FkcyB0aGUgc3FsaXRlMyBXQVNNL0pTXG4gIG1vZHVsZS4gVGhpcyBmaWxlJ3MgZmVhdHVyZXMgd2lsbCBsb2FkIHRoYXQgbW9kdWxlIGFuZCBwcm92aWRlIGFcbiAgc2xpZ2h0bHkgc2ltcGxlciBjbGllbnQtc2lkZSBpbnRlcmZhY2UgdGhhbiB0aGUgc2xpZ2h0bHktbG93ZXItbGV2ZWxcbiAgV29ya2VyIEFQSSBkb2VzLlxuXG4gIFRoaXMgc2NyaXB0IG5lY2Vzc2FyaWx5IGV4cG9zZXMgb25lIGdsb2JhbCBzeW1ib2wsIGJ1dCBjbGllbnRzIG1heVxuICBmcmVlbHkgYGRlbGV0ZWAgdGhhdCBzeW1ib2wgYWZ0ZXIgY2FsbGluZyBpdC5cbiovXG4ndXNlIHN0cmljdCc7XG5cbmdsb2JhbFRoaXMuc3FsaXRlM1dvcmtlcjFQcm9taXNlciA9IGZ1bmN0aW9uIGNhbGxlZShcbiAgY29uZmlnID0gY2FsbGVlLmRlZmF1bHRDb25maWcsXG4pIHtcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgIGNvbnN0IGYgPSBjb25maWc7XG4gICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBjYWxsZWUuZGVmYXVsdENvbmZpZyk7XG4gICAgY29uZmlnLm9ucmVhZHkgPSBmO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgY2FsbGVlLmRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG4gIH1cbiAgY29uc3QgaGFuZGxlck1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgY29uc3QgZXJyID0gY29uZmlnLm9uZXJyb3IgfHwgbm9vcDtcbiAgY29uc3QgZGVidWcgPSBjb25maWcuZGVidWcgfHwgbm9vcDtcbiAgY29uc3QgaWRUeXBlTWFwID0gY29uZmlnLmdlbmVyYXRlTWVzc2FnZUlkID8gdW5kZWZpbmVkIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgZ2VuTXNnSWQgPVxuICAgIGNvbmZpZy5nZW5lcmF0ZU1lc3NhZ2VJZCB8fFxuICAgIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG1zZy50eXBlICsgJyMnICsgKGlkVHlwZU1hcFttc2cudHlwZV0gPSAoaWRUeXBlTWFwW21zZy50eXBlXSB8fCAwKSArIDEpXG4gICAgICApO1xuICAgIH07XG4gIGNvbnN0IHRvc3MgPSAoLi4uYXJncykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSk7XG4gIH07XG4gIGlmICghY29uZmlnLndvcmtlcikgY29uZmlnLndvcmtlciA9IGNhbGxlZS5kZWZhdWx0Q29uZmlnLndvcmtlcjtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBjb25maWcud29ya2VyKSBjb25maWcud29ya2VyID0gY29uZmlnLndvcmtlcigpO1xuICBsZXQgZGJJZDtcbiAgbGV0IHByb21pc2VyRnVuYztcbiAgY29uZmlnLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBldiA9IGV2LmRhdGE7XG4gICAgZGVidWcoJ3dvcmtlcjEub25tZXNzYWdlJywgZXYpO1xuICAgIGxldCBtc2dIYW5kbGVyID0gaGFuZGxlck1hcFtldi5tZXNzYWdlSWRdO1xuICAgIGlmICghbXNnSGFuZGxlcikge1xuICAgICAgaWYgKGV2ICYmICdzcWxpdGUzLWFwaScgPT09IGV2LnR5cGUgJiYgJ3dvcmtlcjEtcmVhZHknID09PSBldi5yZXN1bHQpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5vbnJlYWR5KSBjb25maWcub25yZWFkeShwcm9taXNlckZ1bmMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtc2dIYW5kbGVyID0gaGFuZGxlck1hcFtldi50eXBlXTtcbiAgICAgIGlmIChtc2dIYW5kbGVyICYmIG1zZ0hhbmRsZXIub25yb3cpIHtcbiAgICAgICAgbXNnSGFuZGxlci5vbnJvdyhldik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcub251bmhhbmRsZWQpIGNvbmZpZy5vbnVuaGFuZGxlZChhcmd1bWVudHNbMF0pO1xuICAgICAgZWxzZSBlcnIoJ3NxbGl0ZTNXb3JrZXIxUHJvbWlzZXIoKSB1bmhhbmRsZWQgd29ya2VyIG1lc3NhZ2U6JywgZXYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgaGFuZGxlck1hcFtldi5tZXNzYWdlSWRdO1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBtc2dIYW5kbGVyLnJlamVjdChldik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICBpZiAoIWRiSWQpIGRiSWQgPSBldi5kYklkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgaWYgKGV2LmRiSWQgPT09IGRiSWQpIGRiSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBtc2dIYW5kbGVyLnJlc29sdmUoZXYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1zZ0hhbmRsZXIucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcm9taXNlckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1zZztcbiAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgbXNnID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgbXNnID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1zZy50eXBlID0gYXJndW1lbnRzWzBdO1xuICAgICAgbXNnLmFyZ3MgPSBhcmd1bWVudHNbMV07XG4gICAgICBtc2cuZGJJZCA9IG1zZy5hcmdzLmRiSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvc3MoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBzcWxpdGUzV29ya2VyMVByb21pc2VyKCktY3JlYXRlZCBmYWN0b3J5LicpO1xuICAgIH1cbiAgICBpZiAoIW1zZy5kYklkICYmIG1zZy50eXBlICE9PSAnb3BlbicpIG1zZy5kYklkID0gZGJJZDtcbiAgICBtc2cubWVzc2FnZUlkID0gZ2VuTXNnSWQobXNnKTtcbiAgICBtc2cuZGVwYXJ0dXJlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHByb3h5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBwcm94eS5tZXNzYWdlID0gbXNnO1xuICAgIGxldCByb3dDYWxsYmFja0lkO1xuICAgIGlmICgnZXhlYycgPT09IG1zZy50eXBlICYmIG1zZy5hcmdzKSB7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG1zZy5hcmdzLmNhbGxiYWNrKSB7XG4gICAgICAgIHJvd0NhbGxiYWNrSWQgPSBtc2cubWVzc2FnZUlkICsgJzpyb3cnO1xuICAgICAgICBwcm94eS5vbnJvdyA9IG1zZy5hcmdzLmNhbGxiYWNrO1xuICAgICAgICBtc2cuYXJncy5jYWxsYmFjayA9IHJvd0NhbGxiYWNrSWQ7XG4gICAgICAgIGhhbmRsZXJNYXBbcm93Q2FsbGJhY2tJZF0gPSBwcm94eTtcbiAgICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBtc2cuYXJncy5jYWxsYmFjaykge1xuICAgICAgICB0b3NzKFxuICAgICAgICAgICdleGVjIGNhbGxiYWNrIG1heSBub3QgYmUgYSBzdHJpbmcgd2hlbiB1c2luZyB0aGUgUHJvbWlzZSBpbnRlcmZhY2UuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb3h5LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJveHkucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgaGFuZGxlck1hcFttc2cubWVzc2FnZUlkXSA9IHByb3h5O1xuICAgICAgZGVidWcoXG4gICAgICAgICdQb3N0aW5nJyxcbiAgICAgICAgbXNnLnR5cGUsXG4gICAgICAgICdtZXNzYWdlIHRvIFdvcmtlciBkYklkPScgKyAoZGJJZCB8fCAnZGVmYXVsdCcpICsgJzonLFxuICAgICAgICBtc2csXG4gICAgICApO1xuICAgICAgY29uZmlnLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH0pO1xuICAgIGlmIChyb3dDYWxsYmFja0lkKSBwID0gcC5maW5hbGx5KCgpID0+IGRlbGV0ZSBoYW5kbGVyTWFwW3Jvd0NhbGxiYWNrSWRdKTtcbiAgICByZXR1cm4gcDtcbiAgfSk7XG59O1xuXG5nbG9iYWxUaGlzLnNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIuZGVmYXVsdENvbmZpZyA9IHtcbiAgd29ya2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIoXG4gICAgICBuZXcgVVJMKCdzcWxpdGUzLXdvcmtlcjEtYnVuZGxlci1mcmllbmRseS5tanMnLCBpbXBvcnQubWV0YS51cmwpLFxuICAgICAge1xuICAgICAgICB0eXBlOiAnbW9kdWxlJyxcbiAgICAgIH0sXG4gICAgKTtcbiAgfSxcbiAgb25lcnJvcjogKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ3dvcmtlcjEgcHJvbWlzZXIgZXJyb3InLCAuLi5hcmdzKSxcbn07XG5cbnNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIudjIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIGxldCBvbGRGdW5jO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY29uZmlnKSB7XG4gICAgb2xkRnVuYyA9IGNvbmZpZztcbiAgICBjb25maWcgPSB7fTtcbiAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgY29uZmlnPy5vbnJlYWR5KSB7XG4gICAgb2xkRnVuYyA9IGNvbmZpZy5vbnJlYWR5O1xuICAgIGRlbGV0ZSBjb25maWcub25yZWFkeTtcbiAgfVxuICBjb25zdCBwcm9taXNlUHJveHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25maWcgPSBPYmplY3QuYXNzaWduKGNvbmZpZyB8fCBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgb25yZWFkeTogYXN5bmMgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvbGRGdW5jKSBhd2FpdCBvbGRGdW5jKGZ1bmMpO1xuICAgICAgICBwcm9taXNlUHJveHkucmVzb2x2ZShmdW5jKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZVByb3h5LnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbiAgY29uc3QgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBwcm9taXNlUHJveHkucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgcHJvbWlzZVByb3h5LnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHRyeSB7XG4gICAgdGhpcy5vcmlnaW5hbChjb25maWcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvbWlzZVByb3h5LnJlamVjdChlKTtcbiAgfVxuICByZXR1cm4gcDtcbn0uYmluZCh7XG4gIG9yaWdpbmFsOiBzcWxpdGUzV29ya2VyMVByb21pc2VyLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNxbGl0ZTNXb3JrZXIxUHJvbWlzZXIudjI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm":
/*!******************************************************************************!*\
  !*** ./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.wasm ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/sqlite3.8457fa2a.wasm";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === 'object' ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyIvVXNlcnMvcGl5dXNoLmRhZ2FAcG9zdG1hbi5jb20vRG9jdW1lbnRzL1Byb2plY3RzL3BpeXVzaC1kYWdhL2V2YS0yL3Nlc3Npb24xLWJ1aWxkLXRvZG8tY2FsZW5kYXIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09ICdvYmplY3QnID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2VzcycpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3BpeXVzaC5kYWdhQHBvc3RtYW4uY29tL0RvY3VtZW50cy9Qcm9qZWN0cy9waXl1c2gtZGFnYS9ldmEtMi9zZXNzaW9uMS1idWlsZC10b2RvLWNhbGVuZGFyL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./workers/db.worker.ts":
/*!******************************!*\
  !*** ./workers/db.worker.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sqlite.org/sqlite-wasm */ \"(app-pages-browser)/./node_modules/@sqlite.org/sqlite-wasm/index.mjs\");\n/* eslint-disable no-restricted-globals */ \nlet db = null;\nlet sqlite3 = null;\nasync function ensureDB() {\n    if (db) return db;\n    if (!sqlite3) {\n        sqlite3 = await (0,_sqlite_org_sqlite_wasm__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({});\n    }\n    try {\n        db = new sqlite3.oo1.OpfsDb('/clarity/main.sqlite3');\n    } catch (e) {\n        // Fallback to transient db if OPFS unavailable\n        db = new sqlite3.oo1.DB('/clarity/main.sqlite3', 'ct');\n    }\n    return db;\n}\nfunction migrateSQL() {\n    return \"\\nCREATE TABLE IF NOT EXISTS calendars (\\n  id TEXT PRIMARY KEY,\\n  title TEXT NOT NULL,\\n  enabled INTEGER NOT NULL DEFAULT 1,\\n  kind TEXT NOT NULL CHECK(kind IN ('local','google')),\\n  readOnly INTEGER NOT NULL DEFAULT 0\\n);\\n\\nCREATE TABLE IF NOT EXISTS tasks (\\n  id TEXT PRIMARY KEY,\\n  title TEXT NOT NULL,\\n  description TEXT,\\n  stage TEXT NOT NULL CHECK(stage IN ('todo','in-progress','done')),\\n  checked INTEGER NOT NULL DEFAULT 0,\\n  start TEXT,\\n  end TEXT,\\n  allDay INTEGER,\\n  isEvent INTEGER NOT NULL DEFAULT 0,\\n  hiddenOnCalendar INTEGER NOT NULL DEFAULT 0,\\n  linkedTo TEXT,\\n  parentId TEXT,\\n  subTasks TEXT,\\n  createdAt TEXT NOT NULL,\\n  updatedAt TEXT NOT NULL,\\n  calendarId TEXT NOT NULL REFERENCES calendars(id) ON DELETE CASCADE,\\n  sortOrder REAL NOT NULL DEFAULT 0\\n);\\n\\nCREATE INDEX IF NOT EXISTS idx_tasks_stage ON tasks(stage);\\nCREATE INDEX IF NOT EXISTS idx_tasks_calendar ON tasks(calendarId);\\nCREATE INDEX IF NOT EXISTS idx_tasks_time ON tasks(start, end);\\n\\nINSERT OR IGNORE INTO calendars(id,title,enabled,kind,readOnly)\\nVALUES ('local','Local Tasks',1,'local',0);\\n\";\n}\nself.onmessage = async (e)=>{\n    const msg = e.data;\n    const send = (res)=>self.postMessage(res);\n    try {\n        switch(msg.type){\n            case 'init':\n                {\n                    await ensureDB();\n                    send({\n                        id: msg.id,\n                        ok: true\n                    });\n                    break;\n                }\n            case 'migrate':\n                {\n                    const dbi = await ensureDB();\n                    dbi.exec(migrateSQL());\n                    // Attempt to migrate old column name 'order' -> 'sortOrder'\n                    try {\n                        dbi.exec('ALTER TABLE tasks RENAME COLUMN \"order\" TO sortOrder;');\n                    } catch (_) {\n                    // ignore if not present or already migrated\n                    }\n                    // If legacy 'color' column exists, rebuild table without it\n                    try {\n                        const cols = dbi.exec({\n                            sql: 'PRAGMA table_info(tasks);',\n                            returnValue: 'resultRows',\n                            rowMode: 'object'\n                        });\n                        const hasColor = Array.isArray(cols) && cols.some((r)=>String(r.name || '') === 'color');\n                        if (hasColor) {\n                            dbi.exec('BEGIN;');\n                            dbi.exec(\"\\nCREATE TABLE IF NOT EXISTS tasks__new (\\n  id TEXT PRIMARY KEY,\\n  title TEXT NOT NULL,\\n  description TEXT,\\n  stage TEXT NOT NULL CHECK(stage IN ('todo','in-progress','done')),\\n  checked INTEGER NOT NULL DEFAULT 0,\\n  start TEXT,\\n  end TEXT,\\n  allDay INTEGER,\\n  isEvent INTEGER NOT NULL DEFAULT 0,\\n  hiddenOnCalendar INTEGER NOT NULL DEFAULT 0,\\n  linkedTo TEXT,\\n  parentId TEXT,\\n  subTasks TEXT,\\n  createdAt TEXT NOT NULL,\\n  updatedAt TEXT NOT NULL,\\n  calendarId TEXT NOT NULL REFERENCES calendars(id) ON DELETE CASCADE,\\n  sortOrder REAL NOT NULL DEFAULT 0\\n);\\n\");\n                            dbi.exec(\"INSERT INTO tasks__new (id,title,description,stage,checked,start,end,allDay,isEvent,hiddenOnCalendar,linkedTo,parentId,subTasks,createdAt,updatedAt,calendarId,sortOrder)\\nSELECT id,title,description,stage,checked,start,end,allDay,isEvent,hiddenOnCalendar,linkedTo,parentId,subTasks,createdAt,updatedAt,calendarId,sortOrder FROM tasks;\");\n                            dbi.exec('DROP TABLE tasks;');\n                            dbi.exec('ALTER TABLE tasks__new RENAME TO tasks;');\n                            dbi.exec('CREATE INDEX IF NOT EXISTS idx_tasks_stage ON tasks(stage);');\n                            dbi.exec('CREATE INDEX IF NOT EXISTS idx_tasks_calendar ON tasks(calendarId);');\n                            dbi.exec('CREATE INDEX IF NOT EXISTS idx_tasks_time ON tasks(start, end);');\n                            dbi.exec('COMMIT;');\n                        }\n                    } catch (_) {\n                        try {\n                            dbi.exec('ROLLBACK;');\n                        } catch (e) {}\n                    }\n                    send({\n                        id: msg.id,\n                        ok: true\n                    });\n                    break;\n                }\n            case 'run':\n                {\n                    const dbi = await ensureDB();\n                    var _msg_params;\n                    dbi.exec({\n                        sql: msg.sql,\n                        bind: (_msg_params = msg.params) !== null && _msg_params !== void 0 ? _msg_params : []\n                    });\n                    send({\n                        id: msg.id,\n                        ok: true\n                    });\n                    break;\n                }\n            case 'all':\n                {\n                    const dbi = await ensureDB();\n                    var _msg_params1;\n                    const rows = dbi.exec({\n                        sql: msg.sql,\n                        bind: (_msg_params1 = msg.params) !== null && _msg_params1 !== void 0 ? _msg_params1 : [],\n                        returnValue: 'resultRows',\n                        rowMode: 'object'\n                    });\n                    send({\n                        id: msg.id,\n                        ok: true,\n                        result: rows\n                    });\n                    break;\n                }\n        }\n    } catch (err) {\n        const error = err instanceof Error ? err.message : String(err);\n        send({\n            id: msg.id,\n            ok: false,\n            error\n        });\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3dvcmtlcnMvZGIud29ya2VyLnRzIiwibWFwcGluZ3MiOiI7O0FBQUEsd0NBQXdDLEdBQ2dCO0FBWXhELElBQUlDLEtBQVU7QUFDZCxJQUFJQyxVQUFlO0FBRW5CLGVBQWVDO0lBQ2IsSUFBSUYsSUFBSSxPQUFPQTtJQUNmLElBQUksQ0FBQ0MsU0FBUztRQUNaQSxVQUFVLE1BQU1GLG1FQUFpQkEsQ0FBQyxDQUFDO0lBQ3JDO0lBQ0EsSUFBSTtRQUNGQyxLQUFLLElBQUlDLFFBQVFFLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDO0lBQzlCLEVBQUUsT0FBT0MsR0FBRztRQUNWLCtDQUErQztRQUMvQ0wsS0FBSyxJQUFJQyxRQUFRRSxHQUFHLENBQUNHLEVBQUUsQ0FBQyx5QkFBeUI7SUFDbkQ7SUFDQSxPQUFPTjtBQUNUO0FBRUEsU0FBU087SUFDUCxPQUFRO0FBb0NWO0FBRUFDLEtBQUtDLFNBQVMsR0FBRyxPQUFPSjtJQUN0QixNQUFNSyxNQUFNTCxFQUFFTSxJQUFJO0lBQ2xCLE1BQU1DLE9BQU8sQ0FBQ0MsTUFBa0IsS0FBNEJDLFdBQVcsQ0FBQ0Q7SUFDeEUsSUFBSTtRQUNGLE9BQVFILElBQUlLLElBQUk7WUFDZCxLQUFLO2dCQUFRO29CQUNYLE1BQU1iO29CQUNOVSxLQUFLO3dCQUFFSSxJQUFJTixJQUFJTSxFQUFFO3dCQUFFQyxJQUFJO29CQUFLO29CQUM1QjtnQkFDRjtZQUNBLEtBQUs7Z0JBQVc7b0JBQ2QsTUFBTUMsTUFBTSxNQUFNaEI7b0JBQ2xCZ0IsSUFBSUMsSUFBSSxDQUFDWjtvQkFDVCw0REFBNEQ7b0JBQzVELElBQUk7d0JBQ0ZXLElBQUlDLElBQUksQ0FBQztvQkFDWCxFQUFFLE9BQU9DLEdBQUc7b0JBQ1YsNENBQTRDO29CQUM5QztvQkFDQSw0REFBNEQ7b0JBQzVELElBQUk7d0JBQ0YsTUFBTUMsT0FBT0gsSUFBSUMsSUFBSSxDQUFDOzRCQUFFRyxLQUFLOzRCQUE2QkMsYUFBYTs0QkFBY0MsU0FBUzt3QkFBUzt3QkFDdkcsTUFBTUMsV0FBV0MsTUFBTUMsT0FBTyxDQUFDTixTQUFTQSxLQUFLTyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUMsT0FBTyxFQUFXQyxJQUFJLElBQUksUUFBUTt3QkFDM0YsSUFBSU4sVUFBVTs0QkFDWlAsSUFBSUMsSUFBSSxDQUFDOzRCQUNURCxJQUFJQyxJQUFJLENBQUU7NEJBcUJWRCxJQUFJQyxJQUFJLENBQUU7NEJBRVZELElBQUlDLElBQUksQ0FBQzs0QkFDVEQsSUFBSUMsSUFBSSxDQUFDOzRCQUNURCxJQUFJQyxJQUFJLENBQUM7NEJBQ1RELElBQUlDLElBQUksQ0FBQzs0QkFDVEQsSUFBSUMsSUFBSSxDQUFDOzRCQUNURCxJQUFJQyxJQUFJLENBQUM7d0JBQ1g7b0JBQ0YsRUFBRSxPQUFPQyxHQUFHO3dCQUNWLElBQUk7NEJBQUVGLElBQUlDLElBQUksQ0FBQzt3QkFBYyxFQUFFLFVBQU0sQ0FBQztvQkFDeEM7b0JBQ0FQLEtBQUs7d0JBQUVJLElBQUlOLElBQUlNLEVBQUU7d0JBQUVDLElBQUk7b0JBQUs7b0JBQzVCO2dCQUNGO1lBQ0EsS0FBSztnQkFBTztvQkFDVixNQUFNQyxNQUFNLE1BQU1oQjt3QkFDYVE7b0JBQS9CUSxJQUFJQyxJQUFJLENBQUM7d0JBQUVHLEtBQUtaLElBQUlZLEdBQUc7d0JBQUVVLE1BQU10QixDQUFBQSxjQUFBQSxJQUFJdUIsTUFBTSxjQUFWdkIseUJBQUFBLGNBQWMsRUFBRTtvQkFBQztvQkFDaERFLEtBQUs7d0JBQUVJLElBQUlOLElBQUlNLEVBQUU7d0JBQUVDLElBQUk7b0JBQUs7b0JBQzVCO2dCQUNGO1lBQ0EsS0FBSztnQkFBTztvQkFDVixNQUFNQyxNQUFNLE1BQU1oQjt3QkFHVlE7b0JBRlIsTUFBTXdCLE9BQU9oQixJQUFJQyxJQUFJLENBQUM7d0JBQ3BCRyxLQUFLWixJQUFJWSxHQUFHO3dCQUNaVSxNQUFNdEIsQ0FBQUEsZUFBQUEsSUFBSXVCLE1BQU0sY0FBVnZCLDBCQUFBQSxlQUFjLEVBQUU7d0JBQ3RCYSxhQUFhO3dCQUNiQyxTQUFTO29CQUNYO29CQUNBWixLQUFLO3dCQUFFSSxJQUFJTixJQUFJTSxFQUFFO3dCQUFFQyxJQUFJO3dCQUFNa0IsUUFBUUQ7b0JBQUs7b0JBQzFDO2dCQUNGO1FBQ0Y7SUFDRixFQUFFLE9BQU9FLEtBQWM7UUFDckIsTUFBTUMsUUFBUUQsZUFBZUUsUUFBUUYsSUFBSUcsT0FBTyxHQUFHVCxPQUFPTTtRQUMxRHhCLEtBQUs7WUFBRUksSUFBSU4sSUFBSU0sRUFBRTtZQUFFQyxJQUFJO1lBQU9vQjtRQUFNO0lBQ3RDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXl1c2guZGFnYUBwb3N0bWFuLmNvbS9Eb2N1bWVudHMvUHJvamVjdHMvcGl5dXNoLWRhZ2EvZXZhLTIvc2Vzc2lvbjEtYnVpbGQtdG9kby1jYWxlbmRhci93b3JrZXJzL2RiLndvcmtlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmltcG9ydCBzcWxpdGUzSW5pdE1vZHVsZSBmcm9tICdAc3FsaXRlLm9yZy9zcWxpdGUtd2FzbSc7XG5cbnR5cGUgTWVzc2FnZSA9XG4gIHwgeyBpZDogc3RyaW5nOyB0eXBlOiAnaW5pdCcgfVxuICB8IHsgaWQ6IHN0cmluZzsgdHlwZTogJ21pZ3JhdGUnIH1cbiAgfCB7IGlkOiBzdHJpbmc7IHR5cGU6ICdydW4nOyBzcWw6IHN0cmluZzsgcGFyYW1zPzogdW5rbm93bltdIH1cbiAgfCB7IGlkOiBzdHJpbmc7IHR5cGU6ICdhbGwnOyBzcWw6IHN0cmluZzsgcGFyYW1zPzogdW5rbm93bltdIH07XG5cbnR5cGUgUmVzcG9uc2UgPVxuICB8IHsgaWQ6IHN0cmluZzsgb2s6IHRydWU7IHJlc3VsdD86IHVua25vd24gfVxuICB8IHsgaWQ6IHN0cmluZzsgb2s6IGZhbHNlOyBlcnJvcjogc3RyaW5nIH07XG5cbmxldCBkYjogYW55ID0gbnVsbDtcbmxldCBzcWxpdGUzOiBhbnkgPSBudWxsO1xuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVEQigpIHtcbiAgaWYgKGRiKSByZXR1cm4gZGI7XG4gIGlmICghc3FsaXRlMykge1xuICAgIHNxbGl0ZTMgPSBhd2FpdCBzcWxpdGUzSW5pdE1vZHVsZSh7fSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBkYiA9IG5ldyBzcWxpdGUzLm9vMS5PcGZzRGIoJy9jbGFyaXR5L21haW4uc3FsaXRlMycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gdHJhbnNpZW50IGRiIGlmIE9QRlMgdW5hdmFpbGFibGVcbiAgICBkYiA9IG5ldyBzcWxpdGUzLm9vMS5EQignL2NsYXJpdHkvbWFpbi5zcWxpdGUzJywgJ2N0Jyk7XG4gIH1cbiAgcmV0dXJuIGRiO1xufVxuXG5mdW5jdGlvbiBtaWdyYXRlU1FMKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG5DUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBjYWxlbmRhcnMgKFxuICBpZCBURVhUIFBSSU1BUlkgS0VZLFxuICB0aXRsZSBURVhUIE5PVCBOVUxMLFxuICBlbmFibGVkIElOVEVHRVIgTk9UIE5VTEwgREVGQVVMVCAxLFxuICBraW5kIFRFWFQgTk9UIE5VTEwgQ0hFQ0soa2luZCBJTiAoJ2xvY2FsJywnZ29vZ2xlJykpLFxuICByZWFkT25seSBJTlRFR0VSIE5PVCBOVUxMIERFRkFVTFQgMFxuKTtcblxuQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgdGFza3MgKFxuICBpZCBURVhUIFBSSU1BUlkgS0VZLFxuICB0aXRsZSBURVhUIE5PVCBOVUxMLFxuICBkZXNjcmlwdGlvbiBURVhULFxuICBzdGFnZSBURVhUIE5PVCBOVUxMIENIRUNLKHN0YWdlIElOICgndG9kbycsJ2luLXByb2dyZXNzJywnZG9uZScpKSxcbiAgY2hlY2tlZCBJTlRFR0VSIE5PVCBOVUxMIERFRkFVTFQgMCxcbiAgc3RhcnQgVEVYVCxcbiAgZW5kIFRFWFQsXG4gIGFsbERheSBJTlRFR0VSLFxuICBpc0V2ZW50IElOVEVHRVIgTk9UIE5VTEwgREVGQVVMVCAwLFxuICBoaWRkZW5PbkNhbGVuZGFyIElOVEVHRVIgTk9UIE5VTEwgREVGQVVMVCAwLFxuICBsaW5rZWRUbyBURVhULFxuICBwYXJlbnRJZCBURVhULFxuICBzdWJUYXNrcyBURVhULFxuICBjcmVhdGVkQXQgVEVYVCBOT1QgTlVMTCxcbiAgdXBkYXRlZEF0IFRFWFQgTk9UIE5VTEwsXG4gIGNhbGVuZGFySWQgVEVYVCBOT1QgTlVMTCBSRUZFUkVOQ0VTIGNhbGVuZGFycyhpZCkgT04gREVMRVRFIENBU0NBREUsXG4gIHNvcnRPcmRlciBSRUFMIE5PVCBOVUxMIERFRkFVTFQgMFxuKTtcblxuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X3Rhc2tzX3N0YWdlIE9OIHRhc2tzKHN0YWdlKTtcbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF90YXNrc19jYWxlbmRhciBPTiB0YXNrcyhjYWxlbmRhcklkKTtcbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF90YXNrc190aW1lIE9OIHRhc2tzKHN0YXJ0LCBlbmQpO1xuXG5JTlNFUlQgT1IgSUdOT1JFIElOVE8gY2FsZW5kYXJzKGlkLHRpdGxlLGVuYWJsZWQsa2luZCxyZWFkT25seSlcblZBTFVFUyAoJ2xvY2FsJywnTG9jYWwgVGFza3MnLDEsJ2xvY2FsJywwKTtcbmA7XG59XG5cbnNlbGYub25tZXNzYWdlID0gYXN5bmMgKGU6IE1lc3NhZ2VFdmVudDxNZXNzYWdlPikgPT4ge1xuICBjb25zdCBtc2cgPSBlLmRhdGE7XG4gIGNvbnN0IHNlbmQgPSAocmVzOiBSZXNwb25zZSkgPT4gKHNlbGYgYXMgdW5rbm93biBhcyBXb3JrZXIpLnBvc3RNZXNzYWdlKHJlcyk7XG4gIHRyeSB7XG4gICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgY2FzZSAnaW5pdCc6IHtcbiAgICAgICAgYXdhaXQgZW5zdXJlREIoKTtcbiAgICAgICAgc2VuZCh7IGlkOiBtc2cuaWQsIG9rOiB0cnVlIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ21pZ3JhdGUnOiB7XG4gICAgICAgIGNvbnN0IGRiaSA9IGF3YWl0IGVuc3VyZURCKCk7XG4gICAgICAgIGRiaS5leGVjKG1pZ3JhdGVTUUwoKSk7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gbWlncmF0ZSBvbGQgY29sdW1uIG5hbWUgJ29yZGVyJyAtPiAnc29ydE9yZGVyJ1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRiaS5leGVjKCdBTFRFUiBUQUJMRSB0YXNrcyBSRU5BTUUgQ09MVU1OIFwib3JkZXJcIiBUTyBzb3J0T3JkZXI7Jyk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAvLyBpZ25vcmUgaWYgbm90IHByZXNlbnQgb3IgYWxyZWFkeSBtaWdyYXRlZFxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGxlZ2FjeSAnY29sb3InIGNvbHVtbiBleGlzdHMsIHJlYnVpbGQgdGFibGUgd2l0aG91dCBpdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbHMgPSBkYmkuZXhlYyh7IHNxbDogJ1BSQUdNQSB0YWJsZV9pbmZvKHRhc2tzKTsnLCByZXR1cm5WYWx1ZTogJ3Jlc3VsdFJvd3MnLCByb3dNb2RlOiAnb2JqZWN0JyB9KSBhcyBhbnlbXTtcbiAgICAgICAgICBjb25zdCBoYXNDb2xvciA9IEFycmF5LmlzQXJyYXkoY29scykgJiYgY29scy5zb21lKChyKSA9PiBTdHJpbmcoKHIgYXMgYW55KS5uYW1lIHx8ICcnKSA9PT0gJ2NvbG9yJyk7XG4gICAgICAgICAgaWYgKGhhc0NvbG9yKSB7XG4gICAgICAgICAgICBkYmkuZXhlYygnQkVHSU47Jyk7XG4gICAgICAgICAgICBkYmkuZXhlYyhgXG5DUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyB0YXNrc19fbmV3IChcbiAgaWQgVEVYVCBQUklNQVJZIEtFWSxcbiAgdGl0bGUgVEVYVCBOT1QgTlVMTCxcbiAgZGVzY3JpcHRpb24gVEVYVCxcbiAgc3RhZ2UgVEVYVCBOT1QgTlVMTCBDSEVDSyhzdGFnZSBJTiAoJ3RvZG8nLCdpbi1wcm9ncmVzcycsJ2RvbmUnKSksXG4gIGNoZWNrZWQgSU5URUdFUiBOT1QgTlVMTCBERUZBVUxUIDAsXG4gIHN0YXJ0IFRFWFQsXG4gIGVuZCBURVhULFxuICBhbGxEYXkgSU5URUdFUixcbiAgaXNFdmVudCBJTlRFR0VSIE5PVCBOVUxMIERFRkFVTFQgMCxcbiAgaGlkZGVuT25DYWxlbmRhciBJTlRFR0VSIE5PVCBOVUxMIERFRkFVTFQgMCxcbiAgbGlua2VkVG8gVEVYVCxcbiAgcGFyZW50SWQgVEVYVCxcbiAgc3ViVGFza3MgVEVYVCxcbiAgY3JlYXRlZEF0IFRFWFQgTk9UIE5VTEwsXG4gIHVwZGF0ZWRBdCBURVhUIE5PVCBOVUxMLFxuICBjYWxlbmRhcklkIFRFWFQgTk9UIE5VTEwgUkVGRVJFTkNFUyBjYWxlbmRhcnMoaWQpIE9OIERFTEVURSBDQVNDQURFLFxuICBzb3J0T3JkZXIgUkVBTCBOT1QgTlVMTCBERUZBVUxUIDBcbik7XG5gKTtcbiAgICAgICAgICAgIGRiaS5leGVjKGBJTlNFUlQgSU5UTyB0YXNrc19fbmV3IChpZCx0aXRsZSxkZXNjcmlwdGlvbixzdGFnZSxjaGVja2VkLHN0YXJ0LGVuZCxhbGxEYXksaXNFdmVudCxoaWRkZW5PbkNhbGVuZGFyLGxpbmtlZFRvLHBhcmVudElkLHN1YlRhc2tzLGNyZWF0ZWRBdCx1cGRhdGVkQXQsY2FsZW5kYXJJZCxzb3J0T3JkZXIpXG5TRUxFQ1QgaWQsdGl0bGUsZGVzY3JpcHRpb24sc3RhZ2UsY2hlY2tlZCxzdGFydCxlbmQsYWxsRGF5LGlzRXZlbnQsaGlkZGVuT25DYWxlbmRhcixsaW5rZWRUbyxwYXJlbnRJZCxzdWJUYXNrcyxjcmVhdGVkQXQsdXBkYXRlZEF0LGNhbGVuZGFySWQsc29ydE9yZGVyIEZST00gdGFza3M7YCk7XG4gICAgICAgICAgICBkYmkuZXhlYygnRFJPUCBUQUJMRSB0YXNrczsnKTtcbiAgICAgICAgICAgIGRiaS5leGVjKCdBTFRFUiBUQUJMRSB0YXNrc19fbmV3IFJFTkFNRSBUTyB0YXNrczsnKTtcbiAgICAgICAgICAgIGRiaS5leGVjKCdDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfdGFza3Nfc3RhZ2UgT04gdGFza3Moc3RhZ2UpOycpO1xuICAgICAgICAgICAgZGJpLmV4ZWMoJ0NSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF90YXNrc19jYWxlbmRhciBPTiB0YXNrcyhjYWxlbmRhcklkKTsnKTtcbiAgICAgICAgICAgIGRiaS5leGVjKCdDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfdGFza3NfdGltZSBPTiB0YXNrcyhzdGFydCwgZW5kKTsnKTtcbiAgICAgICAgICAgIGRiaS5leGVjKCdDT01NSVQ7Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgdHJ5IHsgZGJpLmV4ZWMoJ1JPTExCQUNLOycpOyB9IGNhdGNoIHt9XG4gICAgICAgIH1cbiAgICAgICAgc2VuZCh7IGlkOiBtc2cuaWQsIG9rOiB0cnVlIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3J1bic6IHtcbiAgICAgICAgY29uc3QgZGJpID0gYXdhaXQgZW5zdXJlREIoKTtcbiAgICAgICAgZGJpLmV4ZWMoeyBzcWw6IG1zZy5zcWwsIGJpbmQ6IG1zZy5wYXJhbXMgPz8gW10gfSk7XG4gICAgICAgIHNlbmQoeyBpZDogbXNnLmlkLCBvazogdHJ1ZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdhbGwnOiB7XG4gICAgICAgIGNvbnN0IGRiaSA9IGF3YWl0IGVuc3VyZURCKCk7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBkYmkuZXhlYyh7XG4gICAgICAgICAgc3FsOiBtc2cuc3FsLFxuICAgICAgICAgIGJpbmQ6IG1zZy5wYXJhbXMgPz8gW10sXG4gICAgICAgICAgcmV0dXJuVmFsdWU6ICdyZXN1bHRSb3dzJyxcbiAgICAgICAgICByb3dNb2RlOiAnb2JqZWN0JyxcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbmQoeyBpZDogbXNnLmlkLCBvazogdHJ1ZSwgcmVzdWx0OiByb3dzIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgIGNvbnN0IGVycm9yID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFN0cmluZyhlcnIpO1xuICAgIHNlbmQoeyBpZDogbXNnLmlkLCBvazogZmFsc2UsIGVycm9yIH0pO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbInNxbGl0ZTNJbml0TW9kdWxlIiwiZGIiLCJzcWxpdGUzIiwiZW5zdXJlREIiLCJvbzEiLCJPcGZzRGIiLCJlIiwiREIiLCJtaWdyYXRlU1FMIiwic2VsZiIsIm9ubWVzc2FnZSIsIm1zZyIsImRhdGEiLCJzZW5kIiwicmVzIiwicG9zdE1lc3NhZ2UiLCJ0eXBlIiwiaWQiLCJvayIsImRiaSIsImV4ZWMiLCJfIiwiY29scyIsInNxbCIsInJldHVyblZhbHVlIiwicm93TW9kZSIsImhhc0NvbG9yIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsInIiLCJTdHJpbmciLCJuYW1lIiwiYmluZCIsInBhcmFtcyIsInJvd3MiLCJyZXN1bHQiLCJlcnIiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./workers/db.worker.ts\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/chunks/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("static/webpack/" + __webpack_require__.h() + ".58998b4c466308d0.hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("84300688a80b52c1")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/relative url */
/******/ 	(() => {
/******/ 		__webpack_require__.U = function RelativeURL(url) {
/******/ 			var realUrl = new URL(url, "x:/");
/******/ 			var values = {};
/******/ 			for (var key in realUrl) values[key] = realUrl[key];
/******/ 			values.href = url;
/******/ 			values.pathname = url.replace(/[?#].*/, "");
/******/ 			values.origin = values.protocol = "";
/******/ 			values.toString = values.toJSON = () => (url);
/******/ 			for (var key in values) Object.defineProperty(this, key, { enumerable: true, configurable: true, value: values[key] });
/******/ 		};
/******/ 		__webpack_require__.U.prototype = URL.prototype;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script),
/******/ 					createScriptURL: (url) => (url)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	(() => {
/******/ 		__webpack_require__.tu = (url) => (__webpack_require__.tt().createScriptURL(url));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		var createStylesheet = (chunkId, fullhref, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 			if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {
/******/ 				linkTag.crossOrigin = "anonymous";
/******/ 			}
/******/ 			(function(linkTag) {
/******/ 			                if (typeof _N_E_STYLE_LOAD === 'function') {
/******/ 			                    const { href, onload, onerror } = linkTag;
/******/ 			                    _N_E_STYLE_LOAD(href.indexOf(window.location.origin) === 0 ? new URL(href).pathname : href).then(()=>onload == null ? void 0 : onload.call(linkTag, {
/******/ 			                            type: 'load'
/******/ 			                        }), ()=>onerror == null ? void 0 : onerror.call(linkTag, {}));
/******/ 			                } else {
/******/ 			                    document.head.appendChild(linkTag);
/******/ 			                }
/******/ 			            })(linkTag)
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = (options) => {
/******/ 			return { dispose: () => {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: () => {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = (chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) => {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach((chunkId) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise((resolve, reject) => {
/******/ 					var tag = createStylesheet(chunkId, fullhref, () => {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "/../../../";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"_app-pages-browser_workers_db_worker_ts": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = (_, moreModules, runtime) => {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScriptsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScripts = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScripts = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScriptsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("(app-pages-browser)/./workers/db.worker.ts");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;